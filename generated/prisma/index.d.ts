
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model AvatarUser
 * 
 */
export type AvatarUser = $Result.DefaultSelection<Prisma.$AvatarUserPayload>
/**
 * Model Addresses
 * 
 */
export type Addresses = $Result.DefaultSelection<Prisma.$AddressesPayload>
/**
 * Model UserUsedCoupons
 * 
 */
export type UserUsedCoupons = $Result.DefaultSelection<Prisma.$UserUsedCouponsPayload>
/**
 * Model Stores
 * 
 */
export type Stores = $Result.DefaultSelection<Prisma.$StoresPayload>
/**
 * Model AvatarStore
 * 
 */
export type AvatarStore = $Result.DefaultSelection<Prisma.$AvatarStorePayload>
/**
 * Model StoreAvaliations
 * 
 */
export type StoreAvaliations = $Result.DefaultSelection<Prisma.$StoreAvaliationsPayload>
/**
 * Model StoreAvaliationImages
 * 
 */
export type StoreAvaliationImages = $Result.DefaultSelection<Prisma.$StoreAvaliationImagesPayload>
/**
 * Model Coupons
 * 
 */
export type Coupons = $Result.DefaultSelection<Prisma.$CouponsPayload>
/**
 * Model Products
 * 
 */
export type Products = $Result.DefaultSelection<Prisma.$ProductsPayload>
/**
 * Model ProductImages
 * 
 */
export type ProductImages = $Result.DefaultSelection<Prisma.$ProductImagesPayload>
/**
 * Model Wishlist
 * 
 */
export type Wishlist = $Result.DefaultSelection<Prisma.$WishlistPayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model Promotion
 * 
 */
export type Promotion = $Result.DefaultSelection<Prisma.$PromotionPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model ProductAvaliations
 * 
 */
export type ProductAvaliations = $Result.DefaultSelection<Prisma.$ProductAvaliationsPayload>
/**
 * Model ProductAvaliationImages
 * 
 */
export type ProductAvaliationImages = $Result.DefaultSelection<Prisma.$ProductAvaliationImagesPayload>
/**
 * Model Cart
 * 
 */
export type Cart = $Result.DefaultSelection<Prisma.$CartPayload>
/**
 * Model CartItems
 * 
 */
export type CartItems = $Result.DefaultSelection<Prisma.$CartItemsPayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model OrderStatus
 * 
 */
export type OrderStatus = $Result.DefaultSelection<Prisma.$OrderStatusPayload>
/**
 * Model Orders
 * 
 */
export type Orders = $Result.DefaultSelection<Prisma.$OrdersPayload>
/**
 * Model OrderHistory
 * 
 */
export type OrderHistory = $Result.DefaultSelection<Prisma.$OrderHistoryPayload>
/**
 * Model OrderItems
 * 
 */
export type OrderItems = $Result.DefaultSelection<Prisma.$OrderItemsPayload>
/**
 * Model Shipping
 * 
 */
export type Shipping = $Result.DefaultSelection<Prisma.$ShippingPayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model chatMessages
 * 
 */
export type chatMessages = $Result.DefaultSelection<Prisma.$chatMessagesPayload>
/**
 * Model MessageImages
 * 
 */
export type MessageImages = $Result.DefaultSelection<Prisma.$MessageImagesPayload>
/**
 * Model LoginToken
 * 
 */
export type LoginToken = $Result.DefaultSelection<Prisma.$LoginTokenPayload>
/**
 * Model ConfirmationToken
 * 
 */
export type ConfirmationToken = $Result.DefaultSelection<Prisma.$ConfirmationTokenPayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model TwoFactorAuth
 * 
 */
export type TwoFactorAuth = $Result.DefaultSelection<Prisma.$TwoFactorAuthPayload>
/**
 * Model AbandonedCart
 * 
 */
export type AbandonedCart = $Result.DefaultSelection<Prisma.$AbandonedCartPayload>
/**
 * Model ReturnExchange
 * 
 */
export type ReturnExchange = $Result.DefaultSelection<Prisma.$ReturnExchangePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PaymentMethodType: {
  CREDIT_CARD: 'CREDIT_CARD',
  PIX: 'PIX',
  BOLETO: 'BOLETO',
  BANK_TRANSFER: 'BANK_TRANSFER'
};

export type PaymentMethodType = (typeof PaymentMethodType)[keyof typeof PaymentMethodType]


export const OrderStatusType: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  SHIPPED: 'SHIPPED',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED',
  RETURNED: 'RETURNED'
};

export type OrderStatusType = (typeof OrderStatusType)[keyof typeof OrderStatusType]


export const ReturnExchangeStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  COMPLETED: 'COMPLETED'
};

export type ReturnExchangeStatus = (typeof ReturnExchangeStatus)[keyof typeof ReturnExchangeStatus]

}

export type PaymentMethodType = $Enums.PaymentMethodType

export const PaymentMethodType: typeof $Enums.PaymentMethodType

export type OrderStatusType = $Enums.OrderStatusType

export const OrderStatusType: typeof $Enums.OrderStatusType

export type ReturnExchangeStatus = $Enums.ReturnExchangeStatus

export const ReturnExchangeStatus: typeof $Enums.ReturnExchangeStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.avatarUser`: Exposes CRUD operations for the **AvatarUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AvatarUsers
    * const avatarUsers = await prisma.avatarUser.findMany()
    * ```
    */
  get avatarUser(): Prisma.AvatarUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addresses`: Exposes CRUD operations for the **Addresses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.addresses.findMany()
    * ```
    */
  get addresses(): Prisma.AddressesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userUsedCoupons`: Exposes CRUD operations for the **UserUsedCoupons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserUsedCoupons
    * const userUsedCoupons = await prisma.userUsedCoupons.findMany()
    * ```
    */
  get userUsedCoupons(): Prisma.UserUsedCouponsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stores`: Exposes CRUD operations for the **Stores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.stores.findMany()
    * ```
    */
  get stores(): Prisma.StoresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.avatarStore`: Exposes CRUD operations for the **AvatarStore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AvatarStores
    * const avatarStores = await prisma.avatarStore.findMany()
    * ```
    */
  get avatarStore(): Prisma.AvatarStoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storeAvaliations`: Exposes CRUD operations for the **StoreAvaliations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreAvaliations
    * const storeAvaliations = await prisma.storeAvaliations.findMany()
    * ```
    */
  get storeAvaliations(): Prisma.StoreAvaliationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storeAvaliationImages`: Exposes CRUD operations for the **StoreAvaliationImages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreAvaliationImages
    * const storeAvaliationImages = await prisma.storeAvaliationImages.findMany()
    * ```
    */
  get storeAvaliationImages(): Prisma.StoreAvaliationImagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coupons`: Exposes CRUD operations for the **Coupons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupons.findMany()
    * ```
    */
  get coupons(): Prisma.CouponsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **Products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.ProductsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productImages`: Exposes CRUD operations for the **ProductImages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductImages
    * const productImages = await prisma.productImages.findMany()
    * ```
    */
  get productImages(): Prisma.ProductImagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wishlist`: Exposes CRUD operations for the **Wishlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wishlists
    * const wishlists = await prisma.wishlist.findMany()
    * ```
    */
  get wishlist(): Prisma.WishlistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promotion`: Exposes CRUD operations for the **Promotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promotions
    * const promotions = await prisma.promotion.findMany()
    * ```
    */
  get promotion(): Prisma.PromotionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productAvaliations`: Exposes CRUD operations for the **ProductAvaliations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductAvaliations
    * const productAvaliations = await prisma.productAvaliations.findMany()
    * ```
    */
  get productAvaliations(): Prisma.ProductAvaliationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productAvaliationImages`: Exposes CRUD operations for the **ProductAvaliationImages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductAvaliationImages
    * const productAvaliationImages = await prisma.productAvaliationImages.findMany()
    * ```
    */
  get productAvaliationImages(): Prisma.ProductAvaliationImagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): Prisma.CartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cartItems`: Exposes CRUD operations for the **CartItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartItems
    * const cartItems = await prisma.cartItems.findMany()
    * ```
    */
  get cartItems(): Prisma.CartItemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderStatus`: Exposes CRUD operations for the **OrderStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderStatuses
    * const orderStatuses = await prisma.orderStatus.findMany()
    * ```
    */
  get orderStatus(): Prisma.OrderStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orders`: Exposes CRUD operations for the **Orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.orders.findMany()
    * ```
    */
  get orders(): Prisma.OrdersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderHistory`: Exposes CRUD operations for the **OrderHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderHistories
    * const orderHistories = await prisma.orderHistory.findMany()
    * ```
    */
  get orderHistory(): Prisma.OrderHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItems`: Exposes CRUD operations for the **OrderItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItems.findMany()
    * ```
    */
  get orderItems(): Prisma.OrderItemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shipping`: Exposes CRUD operations for the **Shipping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shippings
    * const shippings = await prisma.shipping.findMany()
    * ```
    */
  get shipping(): Prisma.ShippingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessages`: Exposes CRUD operations for the **chatMessages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessages.findMany()
    * ```
    */
  get chatMessages(): Prisma.chatMessagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageImages`: Exposes CRUD operations for the **MessageImages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageImages
    * const messageImages = await prisma.messageImages.findMany()
    * ```
    */
  get messageImages(): Prisma.MessageImagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loginToken`: Exposes CRUD operations for the **LoginToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoginTokens
    * const loginTokens = await prisma.loginToken.findMany()
    * ```
    */
  get loginToken(): Prisma.LoginTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.confirmationToken`: Exposes CRUD operations for the **ConfirmationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfirmationTokens
    * const confirmationTokens = await prisma.confirmationToken.findMany()
    * ```
    */
  get confirmationToken(): Prisma.ConfirmationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.twoFactorAuth`: Exposes CRUD operations for the **TwoFactorAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwoFactorAuths
    * const twoFactorAuths = await prisma.twoFactorAuth.findMany()
    * ```
    */
  get twoFactorAuth(): Prisma.TwoFactorAuthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.abandonedCart`: Exposes CRUD operations for the **AbandonedCart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AbandonedCarts
    * const abandonedCarts = await prisma.abandonedCart.findMany()
    * ```
    */
  get abandonedCart(): Prisma.AbandonedCartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.returnExchange`: Exposes CRUD operations for the **ReturnExchange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReturnExchanges
    * const returnExchanges = await prisma.returnExchange.findMany()
    * ```
    */
  get returnExchange(): Prisma.ReturnExchangeDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Admin: 'Admin',
    User: 'User',
    AvatarUser: 'AvatarUser',
    Addresses: 'Addresses',
    UserUsedCoupons: 'UserUsedCoupons',
    Stores: 'Stores',
    AvatarStore: 'AvatarStore',
    StoreAvaliations: 'StoreAvaliations',
    StoreAvaliationImages: 'StoreAvaliationImages',
    Coupons: 'Coupons',
    Products: 'Products',
    ProductImages: 'ProductImages',
    Wishlist: 'Wishlist',
    Inventory: 'Inventory',
    Promotion: 'Promotion',
    Category: 'Category',
    ProductAvaliations: 'ProductAvaliations',
    ProductAvaliationImages: 'ProductAvaliationImages',
    Cart: 'Cart',
    CartItems: 'CartItems',
    PaymentMethod: 'PaymentMethod',
    Payment: 'Payment',
    OrderStatus: 'OrderStatus',
    Orders: 'Orders',
    OrderHistory: 'OrderHistory',
    OrderItems: 'OrderItems',
    Shipping: 'Shipping',
    Chat: 'Chat',
    chatMessages: 'chatMessages',
    MessageImages: 'MessageImages',
    LoginToken: 'LoginToken',
    ConfirmationToken: 'ConfirmationToken',
    Log: 'Log',
    TwoFactorAuth: 'TwoFactorAuth',
    AbandonedCart: 'AbandonedCart',
    ReturnExchange: 'ReturnExchange'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "admin" | "user" | "avatarUser" | "addresses" | "userUsedCoupons" | "stores" | "avatarStore" | "storeAvaliations" | "storeAvaliationImages" | "coupons" | "products" | "productImages" | "wishlist" | "inventory" | "promotion" | "category" | "productAvaliations" | "productAvaliationImages" | "cart" | "cartItems" | "paymentMethod" | "payment" | "orderStatus" | "orders" | "orderHistory" | "orderItems" | "shipping" | "chat" | "chatMessages" | "messageImages" | "loginToken" | "confirmationToken" | "log" | "twoFactorAuth" | "abandonedCart" | "returnExchange"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      AvatarUser: {
        payload: Prisma.$AvatarUserPayload<ExtArgs>
        fields: Prisma.AvatarUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvatarUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvatarUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarUserPayload>
          }
          findFirst: {
            args: Prisma.AvatarUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvatarUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarUserPayload>
          }
          findMany: {
            args: Prisma.AvatarUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarUserPayload>[]
          }
          create: {
            args: Prisma.AvatarUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarUserPayload>
          }
          createMany: {
            args: Prisma.AvatarUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AvatarUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarUserPayload>
          }
          update: {
            args: Prisma.AvatarUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarUserPayload>
          }
          deleteMany: {
            args: Prisma.AvatarUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvatarUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AvatarUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarUserPayload>
          }
          aggregate: {
            args: Prisma.AvatarUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvatarUser>
          }
          groupBy: {
            args: Prisma.AvatarUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvatarUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvatarUserCountArgs<ExtArgs>
            result: $Utils.Optional<AvatarUserCountAggregateOutputType> | number
          }
        }
      }
      Addresses: {
        payload: Prisma.$AddressesPayload<ExtArgs>
        fields: Prisma.AddressesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          findFirst: {
            args: Prisma.AddressesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          findMany: {
            args: Prisma.AddressesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>[]
          }
          create: {
            args: Prisma.AddressesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          createMany: {
            args: Prisma.AddressesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AddressesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          update: {
            args: Prisma.AddressesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          deleteMany: {
            args: Prisma.AddressesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddressesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          aggregate: {
            args: Prisma.AddressesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddresses>
          }
          groupBy: {
            args: Prisma.AddressesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressesCountArgs<ExtArgs>
            result: $Utils.Optional<AddressesCountAggregateOutputType> | number
          }
        }
      }
      UserUsedCoupons: {
        payload: Prisma.$UserUsedCouponsPayload<ExtArgs>
        fields: Prisma.UserUsedCouponsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserUsedCouponsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUsedCouponsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserUsedCouponsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUsedCouponsPayload>
          }
          findFirst: {
            args: Prisma.UserUsedCouponsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUsedCouponsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserUsedCouponsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUsedCouponsPayload>
          }
          findMany: {
            args: Prisma.UserUsedCouponsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUsedCouponsPayload>[]
          }
          create: {
            args: Prisma.UserUsedCouponsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUsedCouponsPayload>
          }
          createMany: {
            args: Prisma.UserUsedCouponsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserUsedCouponsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUsedCouponsPayload>
          }
          update: {
            args: Prisma.UserUsedCouponsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUsedCouponsPayload>
          }
          deleteMany: {
            args: Prisma.UserUsedCouponsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUsedCouponsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUsedCouponsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUsedCouponsPayload>
          }
          aggregate: {
            args: Prisma.UserUsedCouponsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserUsedCoupons>
          }
          groupBy: {
            args: Prisma.UserUsedCouponsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserUsedCouponsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserUsedCouponsCountArgs<ExtArgs>
            result: $Utils.Optional<UserUsedCouponsCountAggregateOutputType> | number
          }
        }
      }
      Stores: {
        payload: Prisma.$StoresPayload<ExtArgs>
        fields: Prisma.StoresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          findFirst: {
            args: Prisma.StoresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          findMany: {
            args: Prisma.StoresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>[]
          }
          create: {
            args: Prisma.StoresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          createMany: {
            args: Prisma.StoresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StoresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          update: {
            args: Prisma.StoresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          deleteMany: {
            args: Prisma.StoresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          aggregate: {
            args: Prisma.StoresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStores>
          }
          groupBy: {
            args: Prisma.StoresGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoresGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoresCountArgs<ExtArgs>
            result: $Utils.Optional<StoresCountAggregateOutputType> | number
          }
        }
      }
      AvatarStore: {
        payload: Prisma.$AvatarStorePayload<ExtArgs>
        fields: Prisma.AvatarStoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvatarStoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarStorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvatarStoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarStorePayload>
          }
          findFirst: {
            args: Prisma.AvatarStoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarStorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvatarStoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarStorePayload>
          }
          findMany: {
            args: Prisma.AvatarStoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarStorePayload>[]
          }
          create: {
            args: Prisma.AvatarStoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarStorePayload>
          }
          createMany: {
            args: Prisma.AvatarStoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AvatarStoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarStorePayload>
          }
          update: {
            args: Prisma.AvatarStoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarStorePayload>
          }
          deleteMany: {
            args: Prisma.AvatarStoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvatarStoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AvatarStoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarStorePayload>
          }
          aggregate: {
            args: Prisma.AvatarStoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvatarStore>
          }
          groupBy: {
            args: Prisma.AvatarStoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvatarStoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvatarStoreCountArgs<ExtArgs>
            result: $Utils.Optional<AvatarStoreCountAggregateOutputType> | number
          }
        }
      }
      StoreAvaliations: {
        payload: Prisma.$StoreAvaliationsPayload<ExtArgs>
        fields: Prisma.StoreAvaliationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreAvaliationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreAvaliationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationsPayload>
          }
          findFirst: {
            args: Prisma.StoreAvaliationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreAvaliationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationsPayload>
          }
          findMany: {
            args: Prisma.StoreAvaliationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationsPayload>[]
          }
          create: {
            args: Prisma.StoreAvaliationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationsPayload>
          }
          createMany: {
            args: Prisma.StoreAvaliationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StoreAvaliationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationsPayload>
          }
          update: {
            args: Prisma.StoreAvaliationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationsPayload>
          }
          deleteMany: {
            args: Prisma.StoreAvaliationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreAvaliationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreAvaliationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationsPayload>
          }
          aggregate: {
            args: Prisma.StoreAvaliationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreAvaliations>
          }
          groupBy: {
            args: Prisma.StoreAvaliationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreAvaliationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreAvaliationsCountArgs<ExtArgs>
            result: $Utils.Optional<StoreAvaliationsCountAggregateOutputType> | number
          }
        }
      }
      StoreAvaliationImages: {
        payload: Prisma.$StoreAvaliationImagesPayload<ExtArgs>
        fields: Prisma.StoreAvaliationImagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreAvaliationImagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationImagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreAvaliationImagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationImagesPayload>
          }
          findFirst: {
            args: Prisma.StoreAvaliationImagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationImagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreAvaliationImagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationImagesPayload>
          }
          findMany: {
            args: Prisma.StoreAvaliationImagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationImagesPayload>[]
          }
          create: {
            args: Prisma.StoreAvaliationImagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationImagesPayload>
          }
          createMany: {
            args: Prisma.StoreAvaliationImagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StoreAvaliationImagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationImagesPayload>
          }
          update: {
            args: Prisma.StoreAvaliationImagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationImagesPayload>
          }
          deleteMany: {
            args: Prisma.StoreAvaliationImagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreAvaliationImagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreAvaliationImagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreAvaliationImagesPayload>
          }
          aggregate: {
            args: Prisma.StoreAvaliationImagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreAvaliationImages>
          }
          groupBy: {
            args: Prisma.StoreAvaliationImagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreAvaliationImagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreAvaliationImagesCountArgs<ExtArgs>
            result: $Utils.Optional<StoreAvaliationImagesCountAggregateOutputType> | number
          }
        }
      }
      Coupons: {
        payload: Prisma.$CouponsPayload<ExtArgs>
        fields: Prisma.CouponsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouponsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouponsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponsPayload>
          }
          findFirst: {
            args: Prisma.CouponsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouponsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponsPayload>
          }
          findMany: {
            args: Prisma.CouponsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponsPayload>[]
          }
          create: {
            args: Prisma.CouponsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponsPayload>
          }
          createMany: {
            args: Prisma.CouponsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CouponsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponsPayload>
          }
          update: {
            args: Prisma.CouponsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponsPayload>
          }
          deleteMany: {
            args: Prisma.CouponsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouponsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CouponsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponsPayload>
          }
          aggregate: {
            args: Prisma.CouponsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupons>
          }
          groupBy: {
            args: Prisma.CouponsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouponsCountArgs<ExtArgs>
            result: $Utils.Optional<CouponsCountAggregateOutputType> | number
          }
        }
      }
      Products: {
        payload: Prisma.$ProductsPayload<ExtArgs>
        fields: Prisma.ProductsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          findFirst: {
            args: Prisma.ProductsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          findMany: {
            args: Prisma.ProductsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>[]
          }
          create: {
            args: Prisma.ProductsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          createMany: {
            args: Prisma.ProductsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          update: {
            args: Prisma.ProductsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          deleteMany: {
            args: Prisma.ProductsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          aggregate: {
            args: Prisma.ProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducts>
          }
          groupBy: {
            args: Prisma.ProductsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductsCountArgs<ExtArgs>
            result: $Utils.Optional<ProductsCountAggregateOutputType> | number
          }
        }
      }
      ProductImages: {
        payload: Prisma.$ProductImagesPayload<ExtArgs>
        fields: Prisma.ProductImagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductImagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductImagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagesPayload>
          }
          findFirst: {
            args: Prisma.ProductImagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductImagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagesPayload>
          }
          findMany: {
            args: Prisma.ProductImagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagesPayload>[]
          }
          create: {
            args: Prisma.ProductImagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagesPayload>
          }
          createMany: {
            args: Prisma.ProductImagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductImagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagesPayload>
          }
          update: {
            args: Prisma.ProductImagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagesPayload>
          }
          deleteMany: {
            args: Prisma.ProductImagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductImagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductImagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagesPayload>
          }
          aggregate: {
            args: Prisma.ProductImagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductImages>
          }
          groupBy: {
            args: Prisma.ProductImagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductImagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductImagesCountArgs<ExtArgs>
            result: $Utils.Optional<ProductImagesCountAggregateOutputType> | number
          }
        }
      }
      Wishlist: {
        payload: Prisma.$WishlistPayload<ExtArgs>
        fields: Prisma.WishlistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WishlistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WishlistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          findFirst: {
            args: Prisma.WishlistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WishlistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          findMany: {
            args: Prisma.WishlistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>[]
          }
          create: {
            args: Prisma.WishlistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          createMany: {
            args: Prisma.WishlistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WishlistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          update: {
            args: Prisma.WishlistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          deleteMany: {
            args: Prisma.WishlistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WishlistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WishlistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistPayload>
          }
          aggregate: {
            args: Prisma.WishlistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWishlist>
          }
          groupBy: {
            args: Prisma.WishlistGroupByArgs<ExtArgs>
            result: $Utils.Optional<WishlistGroupByOutputType>[]
          }
          count: {
            args: Prisma.WishlistCountArgs<ExtArgs>
            result: $Utils.Optional<WishlistCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      Promotion: {
        payload: Prisma.$PromotionPayload<ExtArgs>
        fields: Prisma.PromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findFirst: {
            args: Prisma.PromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findMany: {
            args: Prisma.PromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          create: {
            args: Prisma.PromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          createMany: {
            args: Prisma.PromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          update: {
            args: Prisma.PromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          aggregate: {
            args: Prisma.PromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotion>
          }
          groupBy: {
            args: Prisma.PromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      ProductAvaliations: {
        payload: Prisma.$ProductAvaliationsPayload<ExtArgs>
        fields: Prisma.ProductAvaliationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductAvaliationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductAvaliationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationsPayload>
          }
          findFirst: {
            args: Prisma.ProductAvaliationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductAvaliationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationsPayload>
          }
          findMany: {
            args: Prisma.ProductAvaliationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationsPayload>[]
          }
          create: {
            args: Prisma.ProductAvaliationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationsPayload>
          }
          createMany: {
            args: Prisma.ProductAvaliationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductAvaliationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationsPayload>
          }
          update: {
            args: Prisma.ProductAvaliationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationsPayload>
          }
          deleteMany: {
            args: Prisma.ProductAvaliationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductAvaliationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductAvaliationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationsPayload>
          }
          aggregate: {
            args: Prisma.ProductAvaliationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductAvaliations>
          }
          groupBy: {
            args: Prisma.ProductAvaliationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductAvaliationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductAvaliationsCountArgs<ExtArgs>
            result: $Utils.Optional<ProductAvaliationsCountAggregateOutputType> | number
          }
        }
      }
      ProductAvaliationImages: {
        payload: Prisma.$ProductAvaliationImagesPayload<ExtArgs>
        fields: Prisma.ProductAvaliationImagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductAvaliationImagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationImagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductAvaliationImagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationImagesPayload>
          }
          findFirst: {
            args: Prisma.ProductAvaliationImagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationImagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductAvaliationImagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationImagesPayload>
          }
          findMany: {
            args: Prisma.ProductAvaliationImagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationImagesPayload>[]
          }
          create: {
            args: Prisma.ProductAvaliationImagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationImagesPayload>
          }
          createMany: {
            args: Prisma.ProductAvaliationImagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductAvaliationImagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationImagesPayload>
          }
          update: {
            args: Prisma.ProductAvaliationImagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationImagesPayload>
          }
          deleteMany: {
            args: Prisma.ProductAvaliationImagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductAvaliationImagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductAvaliationImagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAvaliationImagesPayload>
          }
          aggregate: {
            args: Prisma.ProductAvaliationImagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductAvaliationImages>
          }
          groupBy: {
            args: Prisma.ProductAvaliationImagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductAvaliationImagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductAvaliationImagesCountArgs<ExtArgs>
            result: $Utils.Optional<ProductAvaliationImagesCountAggregateOutputType> | number
          }
        }
      }
      Cart: {
        payload: Prisma.$CartPayload<ExtArgs>
        fields: Prisma.CartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findFirst: {
            args: Prisma.CartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findMany: {
            args: Prisma.CartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          create: {
            args: Prisma.CartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          createMany: {
            args: Prisma.CartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          update: {
            args: Prisma.CartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          deleteMany: {
            args: Prisma.CartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCart>
          }
          groupBy: {
            args: Prisma.CartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartCountArgs<ExtArgs>
            result: $Utils.Optional<CartCountAggregateOutputType> | number
          }
        }
      }
      CartItems: {
        payload: Prisma.$CartItemsPayload<ExtArgs>
        fields: Prisma.CartItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemsPayload>
          }
          findFirst: {
            args: Prisma.CartItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemsPayload>
          }
          findMany: {
            args: Prisma.CartItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemsPayload>[]
          }
          create: {
            args: Prisma.CartItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemsPayload>
          }
          createMany: {
            args: Prisma.CartItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CartItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemsPayload>
          }
          update: {
            args: Prisma.CartItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemsPayload>
          }
          deleteMany: {
            args: Prisma.CartItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CartItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemsPayload>
          }
          aggregate: {
            args: Prisma.CartItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCartItems>
          }
          groupBy: {
            args: Prisma.CartItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartItemsCountArgs<ExtArgs>
            result: $Utils.Optional<CartItemsCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      OrderStatus: {
        payload: Prisma.$OrderStatusPayload<ExtArgs>
        fields: Prisma.OrderStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          findFirst: {
            args: Prisma.OrderStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          findMany: {
            args: Prisma.OrderStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>[]
          }
          create: {
            args: Prisma.OrderStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          createMany: {
            args: Prisma.OrderStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          update: {
            args: Prisma.OrderStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          deleteMany: {
            args: Prisma.OrderStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          aggregate: {
            args: Prisma.OrderStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderStatus>
          }
          groupBy: {
            args: Prisma.OrderStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderStatusCountArgs<ExtArgs>
            result: $Utils.Optional<OrderStatusCountAggregateOutputType> | number
          }
        }
      }
      Orders: {
        payload: Prisma.$OrdersPayload<ExtArgs>
        fields: Prisma.OrdersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrdersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrdersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          findFirst: {
            args: Prisma.OrdersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrdersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          findMany: {
            args: Prisma.OrdersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>[]
          }
          create: {
            args: Prisma.OrdersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          createMany: {
            args: Prisma.OrdersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrdersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          update: {
            args: Prisma.OrdersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          deleteMany: {
            args: Prisma.OrdersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrdersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrdersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          aggregate: {
            args: Prisma.OrdersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrders>
          }
          groupBy: {
            args: Prisma.OrdersGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrdersGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrdersCountArgs<ExtArgs>
            result: $Utils.Optional<OrdersCountAggregateOutputType> | number
          }
        }
      }
      OrderHistory: {
        payload: Prisma.$OrderHistoryPayload<ExtArgs>
        fields: Prisma.OrderHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
          }
          findFirst: {
            args: Prisma.OrderHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
          }
          findMany: {
            args: Prisma.OrderHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload>[]
          }
          create: {
            args: Prisma.OrderHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
          }
          createMany: {
            args: Prisma.OrderHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
          }
          update: {
            args: Prisma.OrderHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
          }
          deleteMany: {
            args: Prisma.OrderHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
          }
          aggregate: {
            args: Prisma.OrderHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderHistory>
          }
          groupBy: {
            args: Prisma.OrderHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<OrderHistoryCountAggregateOutputType> | number
          }
        }
      }
      OrderItems: {
        payload: Prisma.$OrderItemsPayload<ExtArgs>
        fields: Prisma.OrderItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          findFirst: {
            args: Prisma.OrderItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          findMany: {
            args: Prisma.OrderItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>[]
          }
          create: {
            args: Prisma.OrderItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          createMany: {
            args: Prisma.OrderItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          update: {
            args: Prisma.OrderItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          aggregate: {
            args: Prisma.OrderItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItems>
          }
          groupBy: {
            args: Prisma.OrderItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemsCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemsCountAggregateOutputType> | number
          }
        }
      }
      Shipping: {
        payload: Prisma.$ShippingPayload<ExtArgs>
        fields: Prisma.ShippingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShippingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShippingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload>
          }
          findFirst: {
            args: Prisma.ShippingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShippingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload>
          }
          findMany: {
            args: Prisma.ShippingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload>[]
          }
          create: {
            args: Prisma.ShippingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload>
          }
          createMany: {
            args: Prisma.ShippingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShippingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload>
          }
          update: {
            args: Prisma.ShippingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload>
          }
          deleteMany: {
            args: Prisma.ShippingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShippingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShippingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload>
          }
          aggregate: {
            args: Prisma.ShippingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShipping>
          }
          groupBy: {
            args: Prisma.ShippingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShippingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShippingCountArgs<ExtArgs>
            result: $Utils.Optional<ShippingCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      chatMessages: {
        payload: Prisma.$chatMessagesPayload<ExtArgs>
        fields: Prisma.chatMessagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatMessagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatMessagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatMessagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatMessagesPayload>
          }
          findFirst: {
            args: Prisma.chatMessagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatMessagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatMessagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatMessagesPayload>
          }
          findMany: {
            args: Prisma.chatMessagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatMessagesPayload>[]
          }
          create: {
            args: Prisma.chatMessagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatMessagesPayload>
          }
          createMany: {
            args: Prisma.chatMessagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.chatMessagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatMessagesPayload>
          }
          update: {
            args: Prisma.chatMessagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatMessagesPayload>
          }
          deleteMany: {
            args: Prisma.chatMessagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatMessagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.chatMessagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatMessagesPayload>
          }
          aggregate: {
            args: Prisma.ChatMessagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessages>
          }
          groupBy: {
            args: Prisma.chatMessagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatMessagesCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessagesCountAggregateOutputType> | number
          }
        }
      }
      MessageImages: {
        payload: Prisma.$MessageImagesPayload<ExtArgs>
        fields: Prisma.MessageImagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageImagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageImagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageImagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageImagesPayload>
          }
          findFirst: {
            args: Prisma.MessageImagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageImagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageImagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageImagesPayload>
          }
          findMany: {
            args: Prisma.MessageImagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageImagesPayload>[]
          }
          create: {
            args: Prisma.MessageImagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageImagesPayload>
          }
          createMany: {
            args: Prisma.MessageImagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageImagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageImagesPayload>
          }
          update: {
            args: Prisma.MessageImagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageImagesPayload>
          }
          deleteMany: {
            args: Prisma.MessageImagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageImagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageImagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageImagesPayload>
          }
          aggregate: {
            args: Prisma.MessageImagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageImages>
          }
          groupBy: {
            args: Prisma.MessageImagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageImagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageImagesCountArgs<ExtArgs>
            result: $Utils.Optional<MessageImagesCountAggregateOutputType> | number
          }
        }
      }
      LoginToken: {
        payload: Prisma.$LoginTokenPayload<ExtArgs>
        fields: Prisma.LoginTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoginTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoginTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginTokenPayload>
          }
          findFirst: {
            args: Prisma.LoginTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoginTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginTokenPayload>
          }
          findMany: {
            args: Prisma.LoginTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginTokenPayload>[]
          }
          create: {
            args: Prisma.LoginTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginTokenPayload>
          }
          createMany: {
            args: Prisma.LoginTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LoginTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginTokenPayload>
          }
          update: {
            args: Prisma.LoginTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginTokenPayload>
          }
          deleteMany: {
            args: Prisma.LoginTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoginTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoginTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginTokenPayload>
          }
          aggregate: {
            args: Prisma.LoginTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoginToken>
          }
          groupBy: {
            args: Prisma.LoginTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoginTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoginTokenCountArgs<ExtArgs>
            result: $Utils.Optional<LoginTokenCountAggregateOutputType> | number
          }
        }
      }
      ConfirmationToken: {
        payload: Prisma.$ConfirmationTokenPayload<ExtArgs>
        fields: Prisma.ConfirmationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfirmationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfirmationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfirmationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfirmationTokenPayload>
          }
          findFirst: {
            args: Prisma.ConfirmationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfirmationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfirmationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfirmationTokenPayload>
          }
          findMany: {
            args: Prisma.ConfirmationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfirmationTokenPayload>[]
          }
          create: {
            args: Prisma.ConfirmationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfirmationTokenPayload>
          }
          createMany: {
            args: Prisma.ConfirmationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ConfirmationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfirmationTokenPayload>
          }
          update: {
            args: Prisma.ConfirmationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfirmationTokenPayload>
          }
          deleteMany: {
            args: Prisma.ConfirmationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfirmationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConfirmationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfirmationTokenPayload>
          }
          aggregate: {
            args: Prisma.ConfirmationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfirmationToken>
          }
          groupBy: {
            args: Prisma.ConfirmationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfirmationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfirmationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<ConfirmationTokenCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      TwoFactorAuth: {
        payload: Prisma.$TwoFactorAuthPayload<ExtArgs>
        fields: Prisma.TwoFactorAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TwoFactorAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwoFactorAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>
          }
          findFirst: {
            args: Prisma.TwoFactorAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwoFactorAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>
          }
          findMany: {
            args: Prisma.TwoFactorAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>[]
          }
          create: {
            args: Prisma.TwoFactorAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>
          }
          createMany: {
            args: Prisma.TwoFactorAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TwoFactorAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>
          }
          update: {
            args: Prisma.TwoFactorAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>
          }
          deleteMany: {
            args: Prisma.TwoFactorAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TwoFactorAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TwoFactorAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>
          }
          aggregate: {
            args: Prisma.TwoFactorAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTwoFactorAuth>
          }
          groupBy: {
            args: Prisma.TwoFactorAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.TwoFactorAuthCountArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorAuthCountAggregateOutputType> | number
          }
        }
      }
      AbandonedCart: {
        payload: Prisma.$AbandonedCartPayload<ExtArgs>
        fields: Prisma.AbandonedCartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AbandonedCartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbandonedCartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AbandonedCartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbandonedCartPayload>
          }
          findFirst: {
            args: Prisma.AbandonedCartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbandonedCartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AbandonedCartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbandonedCartPayload>
          }
          findMany: {
            args: Prisma.AbandonedCartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbandonedCartPayload>[]
          }
          create: {
            args: Prisma.AbandonedCartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbandonedCartPayload>
          }
          createMany: {
            args: Prisma.AbandonedCartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AbandonedCartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbandonedCartPayload>
          }
          update: {
            args: Prisma.AbandonedCartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbandonedCartPayload>
          }
          deleteMany: {
            args: Prisma.AbandonedCartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AbandonedCartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AbandonedCartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbandonedCartPayload>
          }
          aggregate: {
            args: Prisma.AbandonedCartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAbandonedCart>
          }
          groupBy: {
            args: Prisma.AbandonedCartGroupByArgs<ExtArgs>
            result: $Utils.Optional<AbandonedCartGroupByOutputType>[]
          }
          count: {
            args: Prisma.AbandonedCartCountArgs<ExtArgs>
            result: $Utils.Optional<AbandonedCartCountAggregateOutputType> | number
          }
        }
      }
      ReturnExchange: {
        payload: Prisma.$ReturnExchangePayload<ExtArgs>
        fields: Prisma.ReturnExchangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReturnExchangeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnExchangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReturnExchangeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnExchangePayload>
          }
          findFirst: {
            args: Prisma.ReturnExchangeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnExchangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReturnExchangeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnExchangePayload>
          }
          findMany: {
            args: Prisma.ReturnExchangeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnExchangePayload>[]
          }
          create: {
            args: Prisma.ReturnExchangeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnExchangePayload>
          }
          createMany: {
            args: Prisma.ReturnExchangeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReturnExchangeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnExchangePayload>
          }
          update: {
            args: Prisma.ReturnExchangeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnExchangePayload>
          }
          deleteMany: {
            args: Prisma.ReturnExchangeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReturnExchangeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReturnExchangeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnExchangePayload>
          }
          aggregate: {
            args: Prisma.ReturnExchangeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReturnExchange>
          }
          groupBy: {
            args: Prisma.ReturnExchangeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReturnExchangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReturnExchangeCountArgs<ExtArgs>
            result: $Utils.Optional<ReturnExchangeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    admin?: AdminOmit
    user?: UserOmit
    avatarUser?: AvatarUserOmit
    addresses?: AddressesOmit
    userUsedCoupons?: UserUsedCouponsOmit
    stores?: StoresOmit
    avatarStore?: AvatarStoreOmit
    storeAvaliations?: StoreAvaliationsOmit
    storeAvaliationImages?: StoreAvaliationImagesOmit
    coupons?: CouponsOmit
    products?: ProductsOmit
    productImages?: ProductImagesOmit
    wishlist?: WishlistOmit
    inventory?: InventoryOmit
    promotion?: PromotionOmit
    category?: CategoryOmit
    productAvaliations?: ProductAvaliationsOmit
    productAvaliationImages?: ProductAvaliationImagesOmit
    cart?: CartOmit
    cartItems?: CartItemsOmit
    paymentMethod?: PaymentMethodOmit
    payment?: PaymentOmit
    orderStatus?: OrderStatusOmit
    orders?: OrdersOmit
    orderHistory?: OrderHistoryOmit
    orderItems?: OrderItemsOmit
    shipping?: ShippingOmit
    chat?: ChatOmit
    chatMessages?: chatMessagesOmit
    messageImages?: MessageImagesOmit
    loginToken?: LoginTokenOmit
    confirmationToken?: ConfirmationTokenOmit
    log?: LogOmit
    twoFactorAuth?: TwoFactorAuthOmit
    abandonedCart?: AbandonedCartOmit
    returnExchange?: ReturnExchangeOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    addresses: number
    productAvaliations: number
    storeAvaliations: number
    orders: number
    usedCoupons: number
    chat: number
    sentMessages: number
    receivedMessages: number
    logs: number
    TwoFactorAuth: number
    Wishlist: number
    AbandonedCart: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | UserCountOutputTypeCountAddressesArgs
    productAvaliations?: boolean | UserCountOutputTypeCountProductAvaliationsArgs
    storeAvaliations?: boolean | UserCountOutputTypeCountStoreAvaliationsArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    usedCoupons?: boolean | UserCountOutputTypeCountUsedCouponsArgs
    chat?: boolean | UserCountOutputTypeCountChatArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    logs?: boolean | UserCountOutputTypeCountLogsArgs
    TwoFactorAuth?: boolean | UserCountOutputTypeCountTwoFactorAuthArgs
    Wishlist?: boolean | UserCountOutputTypeCountWishlistArgs
    AbandonedCart?: boolean | UserCountOutputTypeCountAbandonedCartArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductAvaliationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductAvaliationsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStoreAvaliationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreAvaliationsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsedCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserUsedCouponsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatMessagesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatMessagesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTwoFactorAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorAuthWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWishlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAbandonedCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbandonedCartWhereInput
  }


  /**
   * Count Type AddressesCountOutputType
   */

  export type AddressesCountOutputType = {
    order: number
  }

  export type AddressesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | AddressesCountOutputTypeCountOrderArgs
  }

  // Custom InputTypes
  /**
   * AddressesCountOutputType without action
   */
  export type AddressesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressesCountOutputType
     */
    select?: AddressesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddressesCountOutputType without action
   */
  export type AddressesCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
  }


  /**
   * Count Type StoresCountOutputType
   */

  export type StoresCountOutputType = {
    product: number
    avaliations: number
    coupons: number
    chat: number
    sentMessages: number
    receivedMessages: number
    orderItems: number
    promotions: number
  }

  export type StoresCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | StoresCountOutputTypeCountProductArgs
    avaliations?: boolean | StoresCountOutputTypeCountAvaliationsArgs
    coupons?: boolean | StoresCountOutputTypeCountCouponsArgs
    chat?: boolean | StoresCountOutputTypeCountChatArgs
    sentMessages?: boolean | StoresCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | StoresCountOutputTypeCountReceivedMessagesArgs
    orderItems?: boolean | StoresCountOutputTypeCountOrderItemsArgs
    promotions?: boolean | StoresCountOutputTypeCountPromotionsArgs
  }

  // Custom InputTypes
  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoresCountOutputType
     */
    select?: StoresCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountAvaliationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreAvaliationsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatMessagesWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatMessagesWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountPromotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
  }


  /**
   * Count Type StoreAvaliationsCountOutputType
   */

  export type StoreAvaliationsCountOutputType = {
    images: number
  }

  export type StoreAvaliationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | StoreAvaliationsCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * StoreAvaliationsCountOutputType without action
   */
  export type StoreAvaliationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliationsCountOutputType
     */
    select?: StoreAvaliationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreAvaliationsCountOutputType without action
   */
  export type StoreAvaliationsCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreAvaliationImagesWhereInput
  }


  /**
   * Count Type CouponsCountOutputType
   */

  export type CouponsCountOutputType = {
    usedCoupons: number
  }

  export type CouponsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usedCoupons?: boolean | CouponsCountOutputTypeCountUsedCouponsArgs
  }

  // Custom InputTypes
  /**
   * CouponsCountOutputType without action
   */
  export type CouponsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponsCountOutputType
     */
    select?: CouponsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CouponsCountOutputType without action
   */
  export type CouponsCountOutputTypeCountUsedCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserUsedCouponsWhereInput
  }


  /**
   * Count Type ProductsCountOutputType
   */

  export type ProductsCountOutputType = {
    images: number
    category: number
    avaliations: number
    promotions: number
    cartItem: number
    orderItems: number
    wishlists: number
  }

  export type ProductsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | ProductsCountOutputTypeCountImagesArgs
    category?: boolean | ProductsCountOutputTypeCountCategoryArgs
    avaliations?: boolean | ProductsCountOutputTypeCountAvaliationsArgs
    promotions?: boolean | ProductsCountOutputTypeCountPromotionsArgs
    cartItem?: boolean | ProductsCountOutputTypeCountCartItemArgs
    orderItems?: boolean | ProductsCountOutputTypeCountOrderItemsArgs
    wishlists?: boolean | ProductsCountOutputTypeCountWishlistsArgs
  }

  // Custom InputTypes
  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductsCountOutputType
     */
    select?: ProductsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImagesWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountAvaliationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductAvaliationsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountPromotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountCartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountWishlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistWhereInput
  }


  /**
   * Count Type WishlistCountOutputType
   */

  export type WishlistCountOutputType = {
    products: number
  }

  export type WishlistCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | WishlistCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * WishlistCountOutputType without action
   */
  export type WishlistCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistCountOutputType
     */
    select?: WishlistCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WishlistCountOutputType without action
   */
  export type WishlistCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductsWhereInput
  }


  /**
   * Count Type PromotionCountOutputType
   */

  export type PromotionCountOutputType = {
    products: number
  }

  export type PromotionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | PromotionCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCountOutputType
     */
    select?: PromotionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductsWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    product: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | CategoryCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductsWhereInput
  }


  /**
   * Count Type ProductAvaliationsCountOutputType
   */

  export type ProductAvaliationsCountOutputType = {
    images: number
  }

  export type ProductAvaliationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | ProductAvaliationsCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * ProductAvaliationsCountOutputType without action
   */
  export type ProductAvaliationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliationsCountOutputType
     */
    select?: ProductAvaliationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductAvaliationsCountOutputType without action
   */
  export type ProductAvaliationsCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductAvaliationImagesWhereInput
  }


  /**
   * Count Type CartCountOutputType
   */

  export type CartCountOutputType = {
    cartItems: number
  }

  export type CartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cartItems?: boolean | CartCountOutputTypeCountCartItemsArgs
  }

  // Custom InputTypes
  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartCountOutputType
     */
    select?: CartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeCountCartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemsWhereInput
  }


  /**
   * Count Type PaymentMethodCountOutputType
   */

  export type PaymentMethodCountOutputType = {
    payments: number
  }

  export type PaymentMethodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | PaymentMethodCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodCountOutputType
     */
    select?: PaymentMethodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type OrderStatusCountOutputType
   */

  export type OrderStatusCountOutputType = {
    orders: number
  }

  export type OrderStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | OrderStatusCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * OrderStatusCountOutputType without action
   */
  export type OrderStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusCountOutputType
     */
    select?: OrderStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderStatusCountOutputType without action
   */
  export type OrderStatusCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
  }


  /**
   * Count Type OrdersCountOutputType
   */

  export type OrdersCountOutputType = {
    usedCoupons: number
    orderItems: number
    orderHistory: number
    ReturnExchange: number
  }

  export type OrdersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usedCoupons?: boolean | OrdersCountOutputTypeCountUsedCouponsArgs
    orderItems?: boolean | OrdersCountOutputTypeCountOrderItemsArgs
    orderHistory?: boolean | OrdersCountOutputTypeCountOrderHistoryArgs
    ReturnExchange?: boolean | OrdersCountOutputTypeCountReturnExchangeArgs
  }

  // Custom InputTypes
  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersCountOutputType
     */
    select?: OrdersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountUsedCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserUsedCouponsWhereInput
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemsWhereInput
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountOrderHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderHistoryWhereInput
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountReturnExchangeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnExchangeWhereInput
  }


  /**
   * Count Type ChatCountOutputType
   */

  export type ChatCountOutputType = {
    messages: number
  }

  export type ChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatMessagesWhereInput
  }


  /**
   * Count Type AbandonedCartCountOutputType
   */

  export type AbandonedCartCountOutputType = {
    cartItems: number
  }

  export type AbandonedCartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cartItems?: boolean | AbandonedCartCountOutputTypeCountCartItemsArgs
  }

  // Custom InputTypes
  /**
   * AbandonedCartCountOutputType without action
   */
  export type AbandonedCartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbandonedCartCountOutputType
     */
    select?: AbandonedCartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AbandonedCartCountOutputType without action
   */
  export type AbandonedCartCountOutputTypeCountCartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    userId: number
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>



  export type AdminSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly userId: FieldRef<"Admin", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    avatarId: number | null
    principalAddressId: number | null
    cartId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    avatarId: number | null
    principalAddressId: number | null
    cartId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    cpf: string | null
    email: string | null
    password: string | null
    bornDate: Date | null
    avatarId: number | null
    principalAddressId: number | null
    cartId: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    cpf: string | null
    email: string | null
    password: string | null
    bornDate: Date | null
    avatarId: number | null
    principalAddressId: number | null
    cartId: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    cpf: number
    email: number
    password: number
    bornDate: number
    avatarId: number
    principalAddressId: number
    cartId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    avatarId?: true
    principalAddressId?: true
    cartId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    avatarId?: true
    principalAddressId?: true
    cartId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    cpf?: true
    email?: true
    password?: true
    bornDate?: true
    avatarId?: true
    principalAddressId?: true
    cartId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    cpf?: true
    email?: true
    password?: true
    bornDate?: true
    avatarId?: true
    principalAddressId?: true
    cartId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    cpf?: true
    email?: true
    password?: true
    bornDate?: true
    avatarId?: true
    principalAddressId?: true
    cartId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    created_at: Date
    updated_at: Date
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date
    avatarId: number | null
    principalAddressId: number | null
    cartId: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    cpf?: boolean
    email?: boolean
    password?: boolean
    bornDate?: boolean
    avatarId?: boolean
    principalAddressId?: boolean
    cartId?: boolean
    avatar?: boolean | User$avatarArgs<ExtArgs>
    tokenLogin?: boolean | User$tokenLoginArgs<ExtArgs>
    confirmationToken?: boolean | User$confirmationTokenArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    principalAddress?: boolean | User$principalAddressArgs<ExtArgs>
    addresses?: boolean | User$addressesArgs<ExtArgs>
    store?: boolean | User$storeArgs<ExtArgs>
    productAvaliations?: boolean | User$productAvaliationsArgs<ExtArgs>
    storeAvaliations?: boolean | User$storeAvaliationsArgs<ExtArgs>
    cart?: boolean | CartDefaultArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    usedCoupons?: boolean | User$usedCouponsArgs<ExtArgs>
    chat?: boolean | User$chatArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    TwoFactorAuth?: boolean | User$TwoFactorAuthArgs<ExtArgs>
    Wishlist?: boolean | User$WishlistArgs<ExtArgs>
    AbandonedCart?: boolean | User$AbandonedCartArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    cpf?: boolean
    email?: boolean
    password?: boolean
    bornDate?: boolean
    avatarId?: boolean
    principalAddressId?: boolean
    cartId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "name" | "cpf" | "email" | "password" | "bornDate" | "avatarId" | "principalAddressId" | "cartId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatar?: boolean | User$avatarArgs<ExtArgs>
    tokenLogin?: boolean | User$tokenLoginArgs<ExtArgs>
    confirmationToken?: boolean | User$confirmationTokenArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    principalAddress?: boolean | User$principalAddressArgs<ExtArgs>
    addresses?: boolean | User$addressesArgs<ExtArgs>
    store?: boolean | User$storeArgs<ExtArgs>
    productAvaliations?: boolean | User$productAvaliationsArgs<ExtArgs>
    storeAvaliations?: boolean | User$storeAvaliationsArgs<ExtArgs>
    cart?: boolean | CartDefaultArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    usedCoupons?: boolean | User$usedCouponsArgs<ExtArgs>
    chat?: boolean | User$chatArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    TwoFactorAuth?: boolean | User$TwoFactorAuthArgs<ExtArgs>
    Wishlist?: boolean | User$WishlistArgs<ExtArgs>
    AbandonedCart?: boolean | User$AbandonedCartArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      avatar: Prisma.$AvatarUserPayload<ExtArgs> | null
      tokenLogin: Prisma.$LoginTokenPayload<ExtArgs> | null
      confirmationToken: Prisma.$ConfirmationTokenPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
      principalAddress: Prisma.$AddressesPayload<ExtArgs> | null
      addresses: Prisma.$AddressesPayload<ExtArgs>[]
      store: Prisma.$StoresPayload<ExtArgs> | null
      productAvaliations: Prisma.$ProductAvaliationsPayload<ExtArgs>[]
      storeAvaliations: Prisma.$StoreAvaliationsPayload<ExtArgs>[]
      cart: Prisma.$CartPayload<ExtArgs>
      orders: Prisma.$OrdersPayload<ExtArgs>[]
      usedCoupons: Prisma.$UserUsedCouponsPayload<ExtArgs>[]
      chat: Prisma.$ChatPayload<ExtArgs>[]
      sentMessages: Prisma.$chatMessagesPayload<ExtArgs>[]
      receivedMessages: Prisma.$chatMessagesPayload<ExtArgs>[]
      logs: Prisma.$LogPayload<ExtArgs>[]
      TwoFactorAuth: Prisma.$TwoFactorAuthPayload<ExtArgs>[]
      Wishlist: Prisma.$WishlistPayload<ExtArgs>[]
      AbandonedCart: Prisma.$AbandonedCartPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_at: Date
      updated_at: Date
      name: string
      cpf: string
      email: string
      password: string
      bornDate: Date
      avatarId: number | null
      principalAddressId: number | null
      cartId: number
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    avatar<T extends User$avatarArgs<ExtArgs> = {}>(args?: Subset<T, User$avatarArgs<ExtArgs>>): Prisma__AvatarUserClient<$Result.GetResult<Prisma.$AvatarUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tokenLogin<T extends User$tokenLoginArgs<ExtArgs> = {}>(args?: Subset<T, User$tokenLoginArgs<ExtArgs>>): Prisma__LoginTokenClient<$Result.GetResult<Prisma.$LoginTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    confirmationToken<T extends User$confirmationTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$confirmationTokenArgs<ExtArgs>>): Prisma__ConfirmationTokenClient<$Result.GetResult<Prisma.$ConfirmationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    principalAddress<T extends User$principalAddressArgs<ExtArgs> = {}>(args?: Subset<T, User$principalAddressArgs<ExtArgs>>): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    addresses<T extends User$addressesArgs<ExtArgs> = {}>(args?: Subset<T, User$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    store<T extends User$storeArgs<ExtArgs> = {}>(args?: Subset<T, User$storeArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    productAvaliations<T extends User$productAvaliationsArgs<ExtArgs> = {}>(args?: Subset<T, User$productAvaliationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductAvaliationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    storeAvaliations<T extends User$storeAvaliationsArgs<ExtArgs> = {}>(args?: Subset<T, User$storeAvaliationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreAvaliationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cart<T extends CartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CartDefaultArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usedCoupons<T extends User$usedCouponsArgs<ExtArgs> = {}>(args?: Subset<T, User$usedCouponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserUsedCouponsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chat<T extends User$chatArgs<ExtArgs> = {}>(args?: Subset<T, User$chatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatMessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatMessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends User$logsArgs<ExtArgs> = {}>(args?: Subset<T, User$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TwoFactorAuth<T extends User$TwoFactorAuthArgs<ExtArgs> = {}>(args?: Subset<T, User$TwoFactorAuthArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Wishlist<T extends User$WishlistArgs<ExtArgs> = {}>(args?: Subset<T, User$WishlistArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AbandonedCart<T extends User$AbandonedCartArgs<ExtArgs> = {}>(args?: Subset<T, User$AbandonedCartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbandonedCartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
    readonly name: FieldRef<"User", 'String'>
    readonly cpf: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly bornDate: FieldRef<"User", 'DateTime'>
    readonly avatarId: FieldRef<"User", 'Int'>
    readonly principalAddressId: FieldRef<"User", 'Int'>
    readonly cartId: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.avatar
   */
  export type User$avatarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarUser
     */
    select?: AvatarUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarUser
     */
    omit?: AvatarUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarUserInclude<ExtArgs> | null
    where?: AvatarUserWhereInput
  }

  /**
   * User.tokenLogin
   */
  export type User$tokenLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginToken
     */
    select?: LoginTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginToken
     */
    omit?: LoginTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginTokenInclude<ExtArgs> | null
    where?: LoginTokenWhereInput
  }

  /**
   * User.confirmationToken
   */
  export type User$confirmationTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmationToken
     */
    select?: ConfirmationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfirmationToken
     */
    omit?: ConfirmationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfirmationTokenInclude<ExtArgs> | null
    where?: ConfirmationTokenWhereInput
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User.principalAddress
   */
  export type User$principalAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addresses
     */
    omit?: AddressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressesInclude<ExtArgs> | null
    where?: AddressesWhereInput
  }

  /**
   * User.addresses
   */
  export type User$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addresses
     */
    omit?: AddressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressesInclude<ExtArgs> | null
    where?: AddressesWhereInput
    orderBy?: AddressesOrderByWithRelationInput | AddressesOrderByWithRelationInput[]
    cursor?: AddressesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[]
  }

  /**
   * User.store
   */
  export type User$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    where?: StoresWhereInput
  }

  /**
   * User.productAvaliations
   */
  export type User$productAvaliationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliations
     */
    select?: ProductAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliations
     */
    omit?: ProductAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationsInclude<ExtArgs> | null
    where?: ProductAvaliationsWhereInput
    orderBy?: ProductAvaliationsOrderByWithRelationInput | ProductAvaliationsOrderByWithRelationInput[]
    cursor?: ProductAvaliationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductAvaliationsScalarFieldEnum | ProductAvaliationsScalarFieldEnum[]
  }

  /**
   * User.storeAvaliations
   */
  export type User$storeAvaliationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliations
     */
    select?: StoreAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliations
     */
    omit?: StoreAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationsInclude<ExtArgs> | null
    where?: StoreAvaliationsWhereInput
    orderBy?: StoreAvaliationsOrderByWithRelationInput | StoreAvaliationsOrderByWithRelationInput[]
    cursor?: StoreAvaliationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreAvaliationsScalarFieldEnum | StoreAvaliationsScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    cursor?: OrdersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * User.usedCoupons
   */
  export type User$usedCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUsedCoupons
     */
    select?: UserUsedCouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUsedCoupons
     */
    omit?: UserUsedCouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUsedCouponsInclude<ExtArgs> | null
    where?: UserUsedCouponsWhereInput
    orderBy?: UserUsedCouponsOrderByWithRelationInput | UserUsedCouponsOrderByWithRelationInput[]
    cursor?: UserUsedCouponsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserUsedCouponsScalarFieldEnum | UserUsedCouponsScalarFieldEnum[]
  }

  /**
   * User.chat
   */
  export type User$chatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatMessages
     */
    select?: chatMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatMessages
     */
    omit?: chatMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatMessagesInclude<ExtArgs> | null
    where?: chatMessagesWhereInput
    orderBy?: chatMessagesOrderByWithRelationInput | chatMessagesOrderByWithRelationInput[]
    cursor?: chatMessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessagesScalarFieldEnum | ChatMessagesScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatMessages
     */
    select?: chatMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatMessages
     */
    omit?: chatMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatMessagesInclude<ExtArgs> | null
    where?: chatMessagesWhereInput
    orderBy?: chatMessagesOrderByWithRelationInput | chatMessagesOrderByWithRelationInput[]
    cursor?: chatMessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessagesScalarFieldEnum | ChatMessagesScalarFieldEnum[]
  }

  /**
   * User.logs
   */
  export type User$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * User.TwoFactorAuth
   */
  export type User$TwoFactorAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    where?: TwoFactorAuthWhereInput
    orderBy?: TwoFactorAuthOrderByWithRelationInput | TwoFactorAuthOrderByWithRelationInput[]
    cursor?: TwoFactorAuthWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TwoFactorAuthScalarFieldEnum | TwoFactorAuthScalarFieldEnum[]
  }

  /**
   * User.Wishlist
   */
  export type User$WishlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    where?: WishlistWhereInput
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    cursor?: WishlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * User.AbandonedCart
   */
  export type User$AbandonedCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbandonedCart
     */
    select?: AbandonedCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbandonedCart
     */
    omit?: AbandonedCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbandonedCartInclude<ExtArgs> | null
    where?: AbandonedCartWhereInput
    orderBy?: AbandonedCartOrderByWithRelationInput | AbandonedCartOrderByWithRelationInput[]
    cursor?: AbandonedCartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbandonedCartScalarFieldEnum | AbandonedCartScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model AvatarUser
   */

  export type AggregateAvatarUser = {
    _count: AvatarUserCountAggregateOutputType | null
    _avg: AvatarUserAvgAggregateOutputType | null
    _sum: AvatarUserSumAggregateOutputType | null
    _min: AvatarUserMinAggregateOutputType | null
    _max: AvatarUserMaxAggregateOutputType | null
  }

  export type AvatarUserAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AvatarUserSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AvatarUserMinAggregateOutputType = {
    id: number | null
    url: string | null
    publicId: string | null
    userId: number | null
  }

  export type AvatarUserMaxAggregateOutputType = {
    id: number | null
    url: string | null
    publicId: string | null
    userId: number | null
  }

  export type AvatarUserCountAggregateOutputType = {
    id: number
    url: number
    publicId: number
    userId: number
    _all: number
  }


  export type AvatarUserAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AvatarUserSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AvatarUserMinAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
    userId?: true
  }

  export type AvatarUserMaxAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
    userId?: true
  }

  export type AvatarUserCountAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
    userId?: true
    _all?: true
  }

  export type AvatarUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvatarUser to aggregate.
     */
    where?: AvatarUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarUsers to fetch.
     */
    orderBy?: AvatarUserOrderByWithRelationInput | AvatarUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvatarUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AvatarUsers
    **/
    _count?: true | AvatarUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvatarUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvatarUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvatarUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvatarUserMaxAggregateInputType
  }

  export type GetAvatarUserAggregateType<T extends AvatarUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAvatarUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvatarUser[P]>
      : GetScalarType<T[P], AggregateAvatarUser[P]>
  }




  export type AvatarUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvatarUserWhereInput
    orderBy?: AvatarUserOrderByWithAggregationInput | AvatarUserOrderByWithAggregationInput[]
    by: AvatarUserScalarFieldEnum[] | AvatarUserScalarFieldEnum
    having?: AvatarUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvatarUserCountAggregateInputType | true
    _avg?: AvatarUserAvgAggregateInputType
    _sum?: AvatarUserSumAggregateInputType
    _min?: AvatarUserMinAggregateInputType
    _max?: AvatarUserMaxAggregateInputType
  }

  export type AvatarUserGroupByOutputType = {
    id: number
    url: string
    publicId: string
    userId: number
    _count: AvatarUserCountAggregateOutputType | null
    _avg: AvatarUserAvgAggregateOutputType | null
    _sum: AvatarUserSumAggregateOutputType | null
    _min: AvatarUserMinAggregateOutputType | null
    _max: AvatarUserMaxAggregateOutputType | null
  }

  type GetAvatarUserGroupByPayload<T extends AvatarUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvatarUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvatarUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvatarUserGroupByOutputType[P]>
            : GetScalarType<T[P], AvatarUserGroupByOutputType[P]>
        }
      >
    >


  export type AvatarUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    publicId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avatarUser"]>



  export type AvatarUserSelectScalar = {
    id?: boolean
    url?: boolean
    publicId?: boolean
    userId?: boolean
  }

  export type AvatarUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "publicId" | "userId", ExtArgs["result"]["avatarUser"]>
  export type AvatarUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AvatarUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AvatarUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      publicId: string
      userId: number
    }, ExtArgs["result"]["avatarUser"]>
    composites: {}
  }

  type AvatarUserGetPayload<S extends boolean | null | undefined | AvatarUserDefaultArgs> = $Result.GetResult<Prisma.$AvatarUserPayload, S>

  type AvatarUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvatarUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvatarUserCountAggregateInputType | true
    }

  export interface AvatarUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AvatarUser'], meta: { name: 'AvatarUser' } }
    /**
     * Find zero or one AvatarUser that matches the filter.
     * @param {AvatarUserFindUniqueArgs} args - Arguments to find a AvatarUser
     * @example
     * // Get one AvatarUser
     * const avatarUser = await prisma.avatarUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvatarUserFindUniqueArgs>(args: SelectSubset<T, AvatarUserFindUniqueArgs<ExtArgs>>): Prisma__AvatarUserClient<$Result.GetResult<Prisma.$AvatarUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AvatarUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvatarUserFindUniqueOrThrowArgs} args - Arguments to find a AvatarUser
     * @example
     * // Get one AvatarUser
     * const avatarUser = await prisma.avatarUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvatarUserFindUniqueOrThrowArgs>(args: SelectSubset<T, AvatarUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvatarUserClient<$Result.GetResult<Prisma.$AvatarUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvatarUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarUserFindFirstArgs} args - Arguments to find a AvatarUser
     * @example
     * // Get one AvatarUser
     * const avatarUser = await prisma.avatarUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvatarUserFindFirstArgs>(args?: SelectSubset<T, AvatarUserFindFirstArgs<ExtArgs>>): Prisma__AvatarUserClient<$Result.GetResult<Prisma.$AvatarUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvatarUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarUserFindFirstOrThrowArgs} args - Arguments to find a AvatarUser
     * @example
     * // Get one AvatarUser
     * const avatarUser = await prisma.avatarUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvatarUserFindFirstOrThrowArgs>(args?: SelectSubset<T, AvatarUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvatarUserClient<$Result.GetResult<Prisma.$AvatarUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AvatarUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AvatarUsers
     * const avatarUsers = await prisma.avatarUser.findMany()
     * 
     * // Get first 10 AvatarUsers
     * const avatarUsers = await prisma.avatarUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const avatarUserWithIdOnly = await prisma.avatarUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvatarUserFindManyArgs>(args?: SelectSubset<T, AvatarUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvatarUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AvatarUser.
     * @param {AvatarUserCreateArgs} args - Arguments to create a AvatarUser.
     * @example
     * // Create one AvatarUser
     * const AvatarUser = await prisma.avatarUser.create({
     *   data: {
     *     // ... data to create a AvatarUser
     *   }
     * })
     * 
     */
    create<T extends AvatarUserCreateArgs>(args: SelectSubset<T, AvatarUserCreateArgs<ExtArgs>>): Prisma__AvatarUserClient<$Result.GetResult<Prisma.$AvatarUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AvatarUsers.
     * @param {AvatarUserCreateManyArgs} args - Arguments to create many AvatarUsers.
     * @example
     * // Create many AvatarUsers
     * const avatarUser = await prisma.avatarUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvatarUserCreateManyArgs>(args?: SelectSubset<T, AvatarUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AvatarUser.
     * @param {AvatarUserDeleteArgs} args - Arguments to delete one AvatarUser.
     * @example
     * // Delete one AvatarUser
     * const AvatarUser = await prisma.avatarUser.delete({
     *   where: {
     *     // ... filter to delete one AvatarUser
     *   }
     * })
     * 
     */
    delete<T extends AvatarUserDeleteArgs>(args: SelectSubset<T, AvatarUserDeleteArgs<ExtArgs>>): Prisma__AvatarUserClient<$Result.GetResult<Prisma.$AvatarUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AvatarUser.
     * @param {AvatarUserUpdateArgs} args - Arguments to update one AvatarUser.
     * @example
     * // Update one AvatarUser
     * const avatarUser = await prisma.avatarUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvatarUserUpdateArgs>(args: SelectSubset<T, AvatarUserUpdateArgs<ExtArgs>>): Prisma__AvatarUserClient<$Result.GetResult<Prisma.$AvatarUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AvatarUsers.
     * @param {AvatarUserDeleteManyArgs} args - Arguments to filter AvatarUsers to delete.
     * @example
     * // Delete a few AvatarUsers
     * const { count } = await prisma.avatarUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvatarUserDeleteManyArgs>(args?: SelectSubset<T, AvatarUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AvatarUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AvatarUsers
     * const avatarUser = await prisma.avatarUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvatarUserUpdateManyArgs>(args: SelectSubset<T, AvatarUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AvatarUser.
     * @param {AvatarUserUpsertArgs} args - Arguments to update or create a AvatarUser.
     * @example
     * // Update or create a AvatarUser
     * const avatarUser = await prisma.avatarUser.upsert({
     *   create: {
     *     // ... data to create a AvatarUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AvatarUser we want to update
     *   }
     * })
     */
    upsert<T extends AvatarUserUpsertArgs>(args: SelectSubset<T, AvatarUserUpsertArgs<ExtArgs>>): Prisma__AvatarUserClient<$Result.GetResult<Prisma.$AvatarUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AvatarUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarUserCountArgs} args - Arguments to filter AvatarUsers to count.
     * @example
     * // Count the number of AvatarUsers
     * const count = await prisma.avatarUser.count({
     *   where: {
     *     // ... the filter for the AvatarUsers we want to count
     *   }
     * })
    **/
    count<T extends AvatarUserCountArgs>(
      args?: Subset<T, AvatarUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvatarUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AvatarUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvatarUserAggregateArgs>(args: Subset<T, AvatarUserAggregateArgs>): Prisma.PrismaPromise<GetAvatarUserAggregateType<T>>

    /**
     * Group by AvatarUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvatarUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvatarUserGroupByArgs['orderBy'] }
        : { orderBy?: AvatarUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvatarUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvatarUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AvatarUser model
   */
  readonly fields: AvatarUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AvatarUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvatarUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AvatarUser model
   */
  interface AvatarUserFieldRefs {
    readonly id: FieldRef<"AvatarUser", 'Int'>
    readonly url: FieldRef<"AvatarUser", 'String'>
    readonly publicId: FieldRef<"AvatarUser", 'String'>
    readonly userId: FieldRef<"AvatarUser", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AvatarUser findUnique
   */
  export type AvatarUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarUser
     */
    select?: AvatarUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarUser
     */
    omit?: AvatarUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarUserInclude<ExtArgs> | null
    /**
     * Filter, which AvatarUser to fetch.
     */
    where: AvatarUserWhereUniqueInput
  }

  /**
   * AvatarUser findUniqueOrThrow
   */
  export type AvatarUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarUser
     */
    select?: AvatarUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarUser
     */
    omit?: AvatarUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarUserInclude<ExtArgs> | null
    /**
     * Filter, which AvatarUser to fetch.
     */
    where: AvatarUserWhereUniqueInput
  }

  /**
   * AvatarUser findFirst
   */
  export type AvatarUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarUser
     */
    select?: AvatarUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarUser
     */
    omit?: AvatarUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarUserInclude<ExtArgs> | null
    /**
     * Filter, which AvatarUser to fetch.
     */
    where?: AvatarUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarUsers to fetch.
     */
    orderBy?: AvatarUserOrderByWithRelationInput | AvatarUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvatarUsers.
     */
    cursor?: AvatarUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvatarUsers.
     */
    distinct?: AvatarUserScalarFieldEnum | AvatarUserScalarFieldEnum[]
  }

  /**
   * AvatarUser findFirstOrThrow
   */
  export type AvatarUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarUser
     */
    select?: AvatarUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarUser
     */
    omit?: AvatarUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarUserInclude<ExtArgs> | null
    /**
     * Filter, which AvatarUser to fetch.
     */
    where?: AvatarUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarUsers to fetch.
     */
    orderBy?: AvatarUserOrderByWithRelationInput | AvatarUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvatarUsers.
     */
    cursor?: AvatarUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvatarUsers.
     */
    distinct?: AvatarUserScalarFieldEnum | AvatarUserScalarFieldEnum[]
  }

  /**
   * AvatarUser findMany
   */
  export type AvatarUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarUser
     */
    select?: AvatarUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarUser
     */
    omit?: AvatarUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarUserInclude<ExtArgs> | null
    /**
     * Filter, which AvatarUsers to fetch.
     */
    where?: AvatarUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarUsers to fetch.
     */
    orderBy?: AvatarUserOrderByWithRelationInput | AvatarUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AvatarUsers.
     */
    cursor?: AvatarUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarUsers.
     */
    skip?: number
    distinct?: AvatarUserScalarFieldEnum | AvatarUserScalarFieldEnum[]
  }

  /**
   * AvatarUser create
   */
  export type AvatarUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarUser
     */
    select?: AvatarUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarUser
     */
    omit?: AvatarUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarUserInclude<ExtArgs> | null
    /**
     * The data needed to create a AvatarUser.
     */
    data: XOR<AvatarUserCreateInput, AvatarUserUncheckedCreateInput>
  }

  /**
   * AvatarUser createMany
   */
  export type AvatarUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AvatarUsers.
     */
    data: AvatarUserCreateManyInput | AvatarUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AvatarUser update
   */
  export type AvatarUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarUser
     */
    select?: AvatarUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarUser
     */
    omit?: AvatarUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarUserInclude<ExtArgs> | null
    /**
     * The data needed to update a AvatarUser.
     */
    data: XOR<AvatarUserUpdateInput, AvatarUserUncheckedUpdateInput>
    /**
     * Choose, which AvatarUser to update.
     */
    where: AvatarUserWhereUniqueInput
  }

  /**
   * AvatarUser updateMany
   */
  export type AvatarUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AvatarUsers.
     */
    data: XOR<AvatarUserUpdateManyMutationInput, AvatarUserUncheckedUpdateManyInput>
    /**
     * Filter which AvatarUsers to update
     */
    where?: AvatarUserWhereInput
    /**
     * Limit how many AvatarUsers to update.
     */
    limit?: number
  }

  /**
   * AvatarUser upsert
   */
  export type AvatarUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarUser
     */
    select?: AvatarUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarUser
     */
    omit?: AvatarUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarUserInclude<ExtArgs> | null
    /**
     * The filter to search for the AvatarUser to update in case it exists.
     */
    where: AvatarUserWhereUniqueInput
    /**
     * In case the AvatarUser found by the `where` argument doesn't exist, create a new AvatarUser with this data.
     */
    create: XOR<AvatarUserCreateInput, AvatarUserUncheckedCreateInput>
    /**
     * In case the AvatarUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvatarUserUpdateInput, AvatarUserUncheckedUpdateInput>
  }

  /**
   * AvatarUser delete
   */
  export type AvatarUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarUser
     */
    select?: AvatarUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarUser
     */
    omit?: AvatarUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarUserInclude<ExtArgs> | null
    /**
     * Filter which AvatarUser to delete.
     */
    where: AvatarUserWhereUniqueInput
  }

  /**
   * AvatarUser deleteMany
   */
  export type AvatarUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvatarUsers to delete
     */
    where?: AvatarUserWhereInput
    /**
     * Limit how many AvatarUsers to delete.
     */
    limit?: number
  }

  /**
   * AvatarUser without action
   */
  export type AvatarUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarUser
     */
    select?: AvatarUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarUser
     */
    omit?: AvatarUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarUserInclude<ExtArgs> | null
  }


  /**
   * Model Addresses
   */

  export type AggregateAddresses = {
    _count: AddressesCountAggregateOutputType | null
    _avg: AddressesAvgAggregateOutputType | null
    _sum: AddressesSumAggregateOutputType | null
    _min: AddressesMinAggregateOutputType | null
    _max: AddressesMaxAggregateOutputType | null
  }

  export type AddressesAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AddressesSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AddressesMinAggregateOutputType = {
    id: number | null
    userId: number | null
    cep: string | null
    road: string | null
    number: string | null
    complement: string | null
    neighborhood: string | null
    city: string | null
    state: string | null
    country: string | null
    type: string | null
    reference: string | null
  }

  export type AddressesMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    cep: string | null
    road: string | null
    number: string | null
    complement: string | null
    neighborhood: string | null
    city: string | null
    state: string | null
    country: string | null
    type: string | null
    reference: string | null
  }

  export type AddressesCountAggregateOutputType = {
    id: number
    userId: number
    cep: number
    road: number
    number: number
    complement: number
    neighborhood: number
    city: number
    state: number
    country: number
    type: number
    reference: number
    _all: number
  }


  export type AddressesAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AddressesSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AddressesMinAggregateInputType = {
    id?: true
    userId?: true
    cep?: true
    road?: true
    number?: true
    complement?: true
    neighborhood?: true
    city?: true
    state?: true
    country?: true
    type?: true
    reference?: true
  }

  export type AddressesMaxAggregateInputType = {
    id?: true
    userId?: true
    cep?: true
    road?: true
    number?: true
    complement?: true
    neighborhood?: true
    city?: true
    state?: true
    country?: true
    type?: true
    reference?: true
  }

  export type AddressesCountAggregateInputType = {
    id?: true
    userId?: true
    cep?: true
    road?: true
    number?: true
    complement?: true
    neighborhood?: true
    city?: true
    state?: true
    country?: true
    type?: true
    reference?: true
    _all?: true
  }

  export type AddressesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to aggregate.
     */
    where?: AddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressesOrderByWithRelationInput | AddressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressesMaxAggregateInputType
  }

  export type GetAddressesAggregateType<T extends AddressesAggregateArgs> = {
        [P in keyof T & keyof AggregateAddresses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddresses[P]>
      : GetScalarType<T[P], AggregateAddresses[P]>
  }




  export type AddressesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressesWhereInput
    orderBy?: AddressesOrderByWithAggregationInput | AddressesOrderByWithAggregationInput[]
    by: AddressesScalarFieldEnum[] | AddressesScalarFieldEnum
    having?: AddressesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressesCountAggregateInputType | true
    _avg?: AddressesAvgAggregateInputType
    _sum?: AddressesSumAggregateInputType
    _min?: AddressesMinAggregateInputType
    _max?: AddressesMaxAggregateInputType
  }

  export type AddressesGroupByOutputType = {
    id: number
    userId: number
    cep: string
    road: string
    number: string
    complement: string | null
    neighborhood: string
    city: string
    state: string
    country: string
    type: string | null
    reference: string | null
    _count: AddressesCountAggregateOutputType | null
    _avg: AddressesAvgAggregateOutputType | null
    _sum: AddressesSumAggregateOutputType | null
    _min: AddressesMinAggregateOutputType | null
    _max: AddressesMaxAggregateOutputType | null
  }

  type GetAddressesGroupByPayload<T extends AddressesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressesGroupByOutputType[P]>
            : GetScalarType<T[P], AddressesGroupByOutputType[P]>
        }
      >
    >


  export type AddressesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cep?: boolean
    road?: boolean
    number?: boolean
    complement?: boolean
    neighborhood?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    type?: boolean
    reference?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    principalOf?: boolean | Addresses$principalOfArgs<ExtArgs>
    order?: boolean | Addresses$orderArgs<ExtArgs>
    _count?: boolean | AddressesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addresses"]>



  export type AddressesSelectScalar = {
    id?: boolean
    userId?: boolean
    cep?: boolean
    road?: boolean
    number?: boolean
    complement?: boolean
    neighborhood?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    type?: boolean
    reference?: boolean
  }

  export type AddressesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "cep" | "road" | "number" | "complement" | "neighborhood" | "city" | "state" | "country" | "type" | "reference", ExtArgs["result"]["addresses"]>
  export type AddressesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    principalOf?: boolean | Addresses$principalOfArgs<ExtArgs>
    order?: boolean | Addresses$orderArgs<ExtArgs>
    _count?: boolean | AddressesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AddressesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Addresses"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      principalOf: Prisma.$UserPayload<ExtArgs> | null
      order: Prisma.$OrdersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      cep: string
      road: string
      number: string
      complement: string | null
      neighborhood: string
      city: string
      state: string
      country: string
      type: string | null
      reference: string | null
    }, ExtArgs["result"]["addresses"]>
    composites: {}
  }

  type AddressesGetPayload<S extends boolean | null | undefined | AddressesDefaultArgs> = $Result.GetResult<Prisma.$AddressesPayload, S>

  type AddressesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressesCountAggregateInputType | true
    }

  export interface AddressesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Addresses'], meta: { name: 'Addresses' } }
    /**
     * Find zero or one Addresses that matches the filter.
     * @param {AddressesFindUniqueArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressesFindUniqueArgs>(args: SelectSubset<T, AddressesFindUniqueArgs<ExtArgs>>): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Addresses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressesFindUniqueOrThrowArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressesFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesFindFirstArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressesFindFirstArgs>(args?: SelectSubset<T, AddressesFindFirstArgs<ExtArgs>>): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Addresses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesFindFirstOrThrowArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressesFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.addresses.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.addresses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressesWithIdOnly = await prisma.addresses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressesFindManyArgs>(args?: SelectSubset<T, AddressesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Addresses.
     * @param {AddressesCreateArgs} args - Arguments to create a Addresses.
     * @example
     * // Create one Addresses
     * const Addresses = await prisma.addresses.create({
     *   data: {
     *     // ... data to create a Addresses
     *   }
     * })
     * 
     */
    create<T extends AddressesCreateArgs>(args: SelectSubset<T, AddressesCreateArgs<ExtArgs>>): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressesCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const addresses = await prisma.addresses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressesCreateManyArgs>(args?: SelectSubset<T, AddressesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Addresses.
     * @param {AddressesDeleteArgs} args - Arguments to delete one Addresses.
     * @example
     * // Delete one Addresses
     * const Addresses = await prisma.addresses.delete({
     *   where: {
     *     // ... filter to delete one Addresses
     *   }
     * })
     * 
     */
    delete<T extends AddressesDeleteArgs>(args: SelectSubset<T, AddressesDeleteArgs<ExtArgs>>): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Addresses.
     * @param {AddressesUpdateArgs} args - Arguments to update one Addresses.
     * @example
     * // Update one Addresses
     * const addresses = await prisma.addresses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressesUpdateArgs>(args: SelectSubset<T, AddressesUpdateArgs<ExtArgs>>): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressesDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.addresses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressesDeleteManyArgs>(args?: SelectSubset<T, AddressesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const addresses = await prisma.addresses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressesUpdateManyArgs>(args: SelectSubset<T, AddressesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Addresses.
     * @param {AddressesUpsertArgs} args - Arguments to update or create a Addresses.
     * @example
     * // Update or create a Addresses
     * const addresses = await prisma.addresses.upsert({
     *   create: {
     *     // ... data to create a Addresses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Addresses we want to update
     *   }
     * })
     */
    upsert<T extends AddressesUpsertArgs>(args: SelectSubset<T, AddressesUpsertArgs<ExtArgs>>): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.addresses.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressesCountArgs>(
      args?: Subset<T, AddressesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressesAggregateArgs>(args: Subset<T, AddressesAggregateArgs>): Prisma.PrismaPromise<GetAddressesAggregateType<T>>

    /**
     * Group by Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressesGroupByArgs['orderBy'] }
        : { orderBy?: AddressesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Addresses model
   */
  readonly fields: AddressesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Addresses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    principalOf<T extends Addresses$principalOfArgs<ExtArgs> = {}>(args?: Subset<T, Addresses$principalOfArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    order<T extends Addresses$orderArgs<ExtArgs> = {}>(args?: Subset<T, Addresses$orderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Addresses model
   */
  interface AddressesFieldRefs {
    readonly id: FieldRef<"Addresses", 'Int'>
    readonly userId: FieldRef<"Addresses", 'Int'>
    readonly cep: FieldRef<"Addresses", 'String'>
    readonly road: FieldRef<"Addresses", 'String'>
    readonly number: FieldRef<"Addresses", 'String'>
    readonly complement: FieldRef<"Addresses", 'String'>
    readonly neighborhood: FieldRef<"Addresses", 'String'>
    readonly city: FieldRef<"Addresses", 'String'>
    readonly state: FieldRef<"Addresses", 'String'>
    readonly country: FieldRef<"Addresses", 'String'>
    readonly type: FieldRef<"Addresses", 'String'>
    readonly reference: FieldRef<"Addresses", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Addresses findUnique
   */
  export type AddressesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addresses
     */
    omit?: AddressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where: AddressesWhereUniqueInput
  }

  /**
   * Addresses findUniqueOrThrow
   */
  export type AddressesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addresses
     */
    omit?: AddressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where: AddressesWhereUniqueInput
  }

  /**
   * Addresses findFirst
   */
  export type AddressesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addresses
     */
    omit?: AddressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressesOrderByWithRelationInput | AddressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[]
  }

  /**
   * Addresses findFirstOrThrow
   */
  export type AddressesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addresses
     */
    omit?: AddressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressesOrderByWithRelationInput | AddressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[]
  }

  /**
   * Addresses findMany
   */
  export type AddressesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addresses
     */
    omit?: AddressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressesOrderByWithRelationInput | AddressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[]
  }

  /**
   * Addresses create
   */
  export type AddressesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addresses
     */
    omit?: AddressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * The data needed to create a Addresses.
     */
    data: XOR<AddressesCreateInput, AddressesUncheckedCreateInput>
  }

  /**
   * Addresses createMany
   */
  export type AddressesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressesCreateManyInput | AddressesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Addresses update
   */
  export type AddressesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addresses
     */
    omit?: AddressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * The data needed to update a Addresses.
     */
    data: XOR<AddressesUpdateInput, AddressesUncheckedUpdateInput>
    /**
     * Choose, which Addresses to update.
     */
    where: AddressesWhereUniqueInput
  }

  /**
   * Addresses updateMany
   */
  export type AddressesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressesUpdateManyMutationInput, AddressesUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressesWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Addresses upsert
   */
  export type AddressesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addresses
     */
    omit?: AddressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * The filter to search for the Addresses to update in case it exists.
     */
    where: AddressesWhereUniqueInput
    /**
     * In case the Addresses found by the `where` argument doesn't exist, create a new Addresses with this data.
     */
    create: XOR<AddressesCreateInput, AddressesUncheckedCreateInput>
    /**
     * In case the Addresses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressesUpdateInput, AddressesUncheckedUpdateInput>
  }

  /**
   * Addresses delete
   */
  export type AddressesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addresses
     */
    omit?: AddressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * Filter which Addresses to delete.
     */
    where: AddressesWhereUniqueInput
  }

  /**
   * Addresses deleteMany
   */
  export type AddressesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressesWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Addresses.principalOf
   */
  export type Addresses$principalOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Addresses.order
   */
  export type Addresses$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    cursor?: OrdersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Addresses without action
   */
  export type AddressesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addresses
     */
    omit?: AddressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressesInclude<ExtArgs> | null
  }


  /**
   * Model UserUsedCoupons
   */

  export type AggregateUserUsedCoupons = {
    _count: UserUsedCouponsCountAggregateOutputType | null
    _avg: UserUsedCouponsAvgAggregateOutputType | null
    _sum: UserUsedCouponsSumAggregateOutputType | null
    _min: UserUsedCouponsMinAggregateOutputType | null
    _max: UserUsedCouponsMaxAggregateOutputType | null
  }

  export type UserUsedCouponsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    couponId: number | null
    orderId: number | null
  }

  export type UserUsedCouponsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    couponId: number | null
    orderId: number | null
  }

  export type UserUsedCouponsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    couponId: number | null
    usedAt: Date | null
    orderId: number | null
  }

  export type UserUsedCouponsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    couponId: number | null
    usedAt: Date | null
    orderId: number | null
  }

  export type UserUsedCouponsCountAggregateOutputType = {
    id: number
    userId: number
    couponId: number
    usedAt: number
    orderId: number
    _all: number
  }


  export type UserUsedCouponsAvgAggregateInputType = {
    id?: true
    userId?: true
    couponId?: true
    orderId?: true
  }

  export type UserUsedCouponsSumAggregateInputType = {
    id?: true
    userId?: true
    couponId?: true
    orderId?: true
  }

  export type UserUsedCouponsMinAggregateInputType = {
    id?: true
    userId?: true
    couponId?: true
    usedAt?: true
    orderId?: true
  }

  export type UserUsedCouponsMaxAggregateInputType = {
    id?: true
    userId?: true
    couponId?: true
    usedAt?: true
    orderId?: true
  }

  export type UserUsedCouponsCountAggregateInputType = {
    id?: true
    userId?: true
    couponId?: true
    usedAt?: true
    orderId?: true
    _all?: true
  }

  export type UserUsedCouponsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserUsedCoupons to aggregate.
     */
    where?: UserUsedCouponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserUsedCoupons to fetch.
     */
    orderBy?: UserUsedCouponsOrderByWithRelationInput | UserUsedCouponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserUsedCouponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserUsedCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserUsedCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserUsedCoupons
    **/
    _count?: true | UserUsedCouponsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserUsedCouponsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserUsedCouponsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserUsedCouponsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserUsedCouponsMaxAggregateInputType
  }

  export type GetUserUsedCouponsAggregateType<T extends UserUsedCouponsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserUsedCoupons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserUsedCoupons[P]>
      : GetScalarType<T[P], AggregateUserUsedCoupons[P]>
  }




  export type UserUsedCouponsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserUsedCouponsWhereInput
    orderBy?: UserUsedCouponsOrderByWithAggregationInput | UserUsedCouponsOrderByWithAggregationInput[]
    by: UserUsedCouponsScalarFieldEnum[] | UserUsedCouponsScalarFieldEnum
    having?: UserUsedCouponsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserUsedCouponsCountAggregateInputType | true
    _avg?: UserUsedCouponsAvgAggregateInputType
    _sum?: UserUsedCouponsSumAggregateInputType
    _min?: UserUsedCouponsMinAggregateInputType
    _max?: UserUsedCouponsMaxAggregateInputType
  }

  export type UserUsedCouponsGroupByOutputType = {
    id: number
    userId: number
    couponId: number
    usedAt: Date
    orderId: number | null
    _count: UserUsedCouponsCountAggregateOutputType | null
    _avg: UserUsedCouponsAvgAggregateOutputType | null
    _sum: UserUsedCouponsSumAggregateOutputType | null
    _min: UserUsedCouponsMinAggregateOutputType | null
    _max: UserUsedCouponsMaxAggregateOutputType | null
  }

  type GetUserUsedCouponsGroupByPayload<T extends UserUsedCouponsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserUsedCouponsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserUsedCouponsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserUsedCouponsGroupByOutputType[P]>
            : GetScalarType<T[P], UserUsedCouponsGroupByOutputType[P]>
        }
      >
    >


  export type UserUsedCouponsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    couponId?: boolean
    usedAt?: boolean
    orderId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | CouponsDefaultArgs<ExtArgs>
    order?: boolean | UserUsedCoupons$orderArgs<ExtArgs>
  }, ExtArgs["result"]["userUsedCoupons"]>



  export type UserUsedCouponsSelectScalar = {
    id?: boolean
    userId?: boolean
    couponId?: boolean
    usedAt?: boolean
    orderId?: boolean
  }

  export type UserUsedCouponsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "couponId" | "usedAt" | "orderId", ExtArgs["result"]["userUsedCoupons"]>
  export type UserUsedCouponsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | CouponsDefaultArgs<ExtArgs>
    order?: boolean | UserUsedCoupons$orderArgs<ExtArgs>
  }

  export type $UserUsedCouponsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserUsedCoupons"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      coupon: Prisma.$CouponsPayload<ExtArgs>
      order: Prisma.$OrdersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      couponId: number
      usedAt: Date
      orderId: number | null
    }, ExtArgs["result"]["userUsedCoupons"]>
    composites: {}
  }

  type UserUsedCouponsGetPayload<S extends boolean | null | undefined | UserUsedCouponsDefaultArgs> = $Result.GetResult<Prisma.$UserUsedCouponsPayload, S>

  type UserUsedCouponsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserUsedCouponsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserUsedCouponsCountAggregateInputType | true
    }

  export interface UserUsedCouponsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserUsedCoupons'], meta: { name: 'UserUsedCoupons' } }
    /**
     * Find zero or one UserUsedCoupons that matches the filter.
     * @param {UserUsedCouponsFindUniqueArgs} args - Arguments to find a UserUsedCoupons
     * @example
     * // Get one UserUsedCoupons
     * const userUsedCoupons = await prisma.userUsedCoupons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserUsedCouponsFindUniqueArgs>(args: SelectSubset<T, UserUsedCouponsFindUniqueArgs<ExtArgs>>): Prisma__UserUsedCouponsClient<$Result.GetResult<Prisma.$UserUsedCouponsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserUsedCoupons that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserUsedCouponsFindUniqueOrThrowArgs} args - Arguments to find a UserUsedCoupons
     * @example
     * // Get one UserUsedCoupons
     * const userUsedCoupons = await prisma.userUsedCoupons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserUsedCouponsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserUsedCouponsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserUsedCouponsClient<$Result.GetResult<Prisma.$UserUsedCouponsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserUsedCoupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUsedCouponsFindFirstArgs} args - Arguments to find a UserUsedCoupons
     * @example
     * // Get one UserUsedCoupons
     * const userUsedCoupons = await prisma.userUsedCoupons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserUsedCouponsFindFirstArgs>(args?: SelectSubset<T, UserUsedCouponsFindFirstArgs<ExtArgs>>): Prisma__UserUsedCouponsClient<$Result.GetResult<Prisma.$UserUsedCouponsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserUsedCoupons that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUsedCouponsFindFirstOrThrowArgs} args - Arguments to find a UserUsedCoupons
     * @example
     * // Get one UserUsedCoupons
     * const userUsedCoupons = await prisma.userUsedCoupons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserUsedCouponsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserUsedCouponsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserUsedCouponsClient<$Result.GetResult<Prisma.$UserUsedCouponsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserUsedCoupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUsedCouponsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserUsedCoupons
     * const userUsedCoupons = await prisma.userUsedCoupons.findMany()
     * 
     * // Get first 10 UserUsedCoupons
     * const userUsedCoupons = await prisma.userUsedCoupons.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userUsedCouponsWithIdOnly = await prisma.userUsedCoupons.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserUsedCouponsFindManyArgs>(args?: SelectSubset<T, UserUsedCouponsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserUsedCouponsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserUsedCoupons.
     * @param {UserUsedCouponsCreateArgs} args - Arguments to create a UserUsedCoupons.
     * @example
     * // Create one UserUsedCoupons
     * const UserUsedCoupons = await prisma.userUsedCoupons.create({
     *   data: {
     *     // ... data to create a UserUsedCoupons
     *   }
     * })
     * 
     */
    create<T extends UserUsedCouponsCreateArgs>(args: SelectSubset<T, UserUsedCouponsCreateArgs<ExtArgs>>): Prisma__UserUsedCouponsClient<$Result.GetResult<Prisma.$UserUsedCouponsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserUsedCoupons.
     * @param {UserUsedCouponsCreateManyArgs} args - Arguments to create many UserUsedCoupons.
     * @example
     * // Create many UserUsedCoupons
     * const userUsedCoupons = await prisma.userUsedCoupons.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserUsedCouponsCreateManyArgs>(args?: SelectSubset<T, UserUsedCouponsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserUsedCoupons.
     * @param {UserUsedCouponsDeleteArgs} args - Arguments to delete one UserUsedCoupons.
     * @example
     * // Delete one UserUsedCoupons
     * const UserUsedCoupons = await prisma.userUsedCoupons.delete({
     *   where: {
     *     // ... filter to delete one UserUsedCoupons
     *   }
     * })
     * 
     */
    delete<T extends UserUsedCouponsDeleteArgs>(args: SelectSubset<T, UserUsedCouponsDeleteArgs<ExtArgs>>): Prisma__UserUsedCouponsClient<$Result.GetResult<Prisma.$UserUsedCouponsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserUsedCoupons.
     * @param {UserUsedCouponsUpdateArgs} args - Arguments to update one UserUsedCoupons.
     * @example
     * // Update one UserUsedCoupons
     * const userUsedCoupons = await prisma.userUsedCoupons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUsedCouponsUpdateArgs>(args: SelectSubset<T, UserUsedCouponsUpdateArgs<ExtArgs>>): Prisma__UserUsedCouponsClient<$Result.GetResult<Prisma.$UserUsedCouponsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserUsedCoupons.
     * @param {UserUsedCouponsDeleteManyArgs} args - Arguments to filter UserUsedCoupons to delete.
     * @example
     * // Delete a few UserUsedCoupons
     * const { count } = await prisma.userUsedCoupons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserUsedCouponsDeleteManyArgs>(args?: SelectSubset<T, UserUsedCouponsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserUsedCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUsedCouponsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserUsedCoupons
     * const userUsedCoupons = await prisma.userUsedCoupons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUsedCouponsUpdateManyArgs>(args: SelectSubset<T, UserUsedCouponsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserUsedCoupons.
     * @param {UserUsedCouponsUpsertArgs} args - Arguments to update or create a UserUsedCoupons.
     * @example
     * // Update or create a UserUsedCoupons
     * const userUsedCoupons = await prisma.userUsedCoupons.upsert({
     *   create: {
     *     // ... data to create a UserUsedCoupons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserUsedCoupons we want to update
     *   }
     * })
     */
    upsert<T extends UserUsedCouponsUpsertArgs>(args: SelectSubset<T, UserUsedCouponsUpsertArgs<ExtArgs>>): Prisma__UserUsedCouponsClient<$Result.GetResult<Prisma.$UserUsedCouponsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserUsedCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUsedCouponsCountArgs} args - Arguments to filter UserUsedCoupons to count.
     * @example
     * // Count the number of UserUsedCoupons
     * const count = await prisma.userUsedCoupons.count({
     *   where: {
     *     // ... the filter for the UserUsedCoupons we want to count
     *   }
     * })
    **/
    count<T extends UserUsedCouponsCountArgs>(
      args?: Subset<T, UserUsedCouponsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserUsedCouponsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserUsedCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUsedCouponsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserUsedCouponsAggregateArgs>(args: Subset<T, UserUsedCouponsAggregateArgs>): Prisma.PrismaPromise<GetUserUsedCouponsAggregateType<T>>

    /**
     * Group by UserUsedCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUsedCouponsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserUsedCouponsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserUsedCouponsGroupByArgs['orderBy'] }
        : { orderBy?: UserUsedCouponsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserUsedCouponsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserUsedCouponsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserUsedCoupons model
   */
  readonly fields: UserUsedCouponsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserUsedCoupons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserUsedCouponsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    coupon<T extends CouponsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CouponsDefaultArgs<ExtArgs>>): Prisma__CouponsClient<$Result.GetResult<Prisma.$CouponsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends UserUsedCoupons$orderArgs<ExtArgs> = {}>(args?: Subset<T, UserUsedCoupons$orderArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserUsedCoupons model
   */
  interface UserUsedCouponsFieldRefs {
    readonly id: FieldRef<"UserUsedCoupons", 'Int'>
    readonly userId: FieldRef<"UserUsedCoupons", 'Int'>
    readonly couponId: FieldRef<"UserUsedCoupons", 'Int'>
    readonly usedAt: FieldRef<"UserUsedCoupons", 'DateTime'>
    readonly orderId: FieldRef<"UserUsedCoupons", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserUsedCoupons findUnique
   */
  export type UserUsedCouponsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUsedCoupons
     */
    select?: UserUsedCouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUsedCoupons
     */
    omit?: UserUsedCouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUsedCouponsInclude<ExtArgs> | null
    /**
     * Filter, which UserUsedCoupons to fetch.
     */
    where: UserUsedCouponsWhereUniqueInput
  }

  /**
   * UserUsedCoupons findUniqueOrThrow
   */
  export type UserUsedCouponsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUsedCoupons
     */
    select?: UserUsedCouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUsedCoupons
     */
    omit?: UserUsedCouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUsedCouponsInclude<ExtArgs> | null
    /**
     * Filter, which UserUsedCoupons to fetch.
     */
    where: UserUsedCouponsWhereUniqueInput
  }

  /**
   * UserUsedCoupons findFirst
   */
  export type UserUsedCouponsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUsedCoupons
     */
    select?: UserUsedCouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUsedCoupons
     */
    omit?: UserUsedCouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUsedCouponsInclude<ExtArgs> | null
    /**
     * Filter, which UserUsedCoupons to fetch.
     */
    where?: UserUsedCouponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserUsedCoupons to fetch.
     */
    orderBy?: UserUsedCouponsOrderByWithRelationInput | UserUsedCouponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserUsedCoupons.
     */
    cursor?: UserUsedCouponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserUsedCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserUsedCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserUsedCoupons.
     */
    distinct?: UserUsedCouponsScalarFieldEnum | UserUsedCouponsScalarFieldEnum[]
  }

  /**
   * UserUsedCoupons findFirstOrThrow
   */
  export type UserUsedCouponsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUsedCoupons
     */
    select?: UserUsedCouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUsedCoupons
     */
    omit?: UserUsedCouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUsedCouponsInclude<ExtArgs> | null
    /**
     * Filter, which UserUsedCoupons to fetch.
     */
    where?: UserUsedCouponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserUsedCoupons to fetch.
     */
    orderBy?: UserUsedCouponsOrderByWithRelationInput | UserUsedCouponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserUsedCoupons.
     */
    cursor?: UserUsedCouponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserUsedCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserUsedCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserUsedCoupons.
     */
    distinct?: UserUsedCouponsScalarFieldEnum | UserUsedCouponsScalarFieldEnum[]
  }

  /**
   * UserUsedCoupons findMany
   */
  export type UserUsedCouponsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUsedCoupons
     */
    select?: UserUsedCouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUsedCoupons
     */
    omit?: UserUsedCouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUsedCouponsInclude<ExtArgs> | null
    /**
     * Filter, which UserUsedCoupons to fetch.
     */
    where?: UserUsedCouponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserUsedCoupons to fetch.
     */
    orderBy?: UserUsedCouponsOrderByWithRelationInput | UserUsedCouponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserUsedCoupons.
     */
    cursor?: UserUsedCouponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserUsedCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserUsedCoupons.
     */
    skip?: number
    distinct?: UserUsedCouponsScalarFieldEnum | UserUsedCouponsScalarFieldEnum[]
  }

  /**
   * UserUsedCoupons create
   */
  export type UserUsedCouponsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUsedCoupons
     */
    select?: UserUsedCouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUsedCoupons
     */
    omit?: UserUsedCouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUsedCouponsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserUsedCoupons.
     */
    data: XOR<UserUsedCouponsCreateInput, UserUsedCouponsUncheckedCreateInput>
  }

  /**
   * UserUsedCoupons createMany
   */
  export type UserUsedCouponsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserUsedCoupons.
     */
    data: UserUsedCouponsCreateManyInput | UserUsedCouponsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserUsedCoupons update
   */
  export type UserUsedCouponsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUsedCoupons
     */
    select?: UserUsedCouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUsedCoupons
     */
    omit?: UserUsedCouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUsedCouponsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserUsedCoupons.
     */
    data: XOR<UserUsedCouponsUpdateInput, UserUsedCouponsUncheckedUpdateInput>
    /**
     * Choose, which UserUsedCoupons to update.
     */
    where: UserUsedCouponsWhereUniqueInput
  }

  /**
   * UserUsedCoupons updateMany
   */
  export type UserUsedCouponsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserUsedCoupons.
     */
    data: XOR<UserUsedCouponsUpdateManyMutationInput, UserUsedCouponsUncheckedUpdateManyInput>
    /**
     * Filter which UserUsedCoupons to update
     */
    where?: UserUsedCouponsWhereInput
    /**
     * Limit how many UserUsedCoupons to update.
     */
    limit?: number
  }

  /**
   * UserUsedCoupons upsert
   */
  export type UserUsedCouponsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUsedCoupons
     */
    select?: UserUsedCouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUsedCoupons
     */
    omit?: UserUsedCouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUsedCouponsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserUsedCoupons to update in case it exists.
     */
    where: UserUsedCouponsWhereUniqueInput
    /**
     * In case the UserUsedCoupons found by the `where` argument doesn't exist, create a new UserUsedCoupons with this data.
     */
    create: XOR<UserUsedCouponsCreateInput, UserUsedCouponsUncheckedCreateInput>
    /**
     * In case the UserUsedCoupons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUsedCouponsUpdateInput, UserUsedCouponsUncheckedUpdateInput>
  }

  /**
   * UserUsedCoupons delete
   */
  export type UserUsedCouponsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUsedCoupons
     */
    select?: UserUsedCouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUsedCoupons
     */
    omit?: UserUsedCouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUsedCouponsInclude<ExtArgs> | null
    /**
     * Filter which UserUsedCoupons to delete.
     */
    where: UserUsedCouponsWhereUniqueInput
  }

  /**
   * UserUsedCoupons deleteMany
   */
  export type UserUsedCouponsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserUsedCoupons to delete
     */
    where?: UserUsedCouponsWhereInput
    /**
     * Limit how many UserUsedCoupons to delete.
     */
    limit?: number
  }

  /**
   * UserUsedCoupons.order
   */
  export type UserUsedCoupons$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
  }

  /**
   * UserUsedCoupons without action
   */
  export type UserUsedCouponsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUsedCoupons
     */
    select?: UserUsedCouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUsedCoupons
     */
    omit?: UserUsedCouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUsedCouponsInclude<ExtArgs> | null
  }


  /**
   * Model Stores
   */

  export type AggregateStores = {
    _count: StoresCountAggregateOutputType | null
    _avg: StoresAvgAggregateOutputType | null
    _sum: StoresSumAggregateOutputType | null
    _min: StoresMinAggregateOutputType | null
    _max: StoresMaxAggregateOutputType | null
  }

  export type StoresAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    avatarId: number | null
  }

  export type StoresSumAggregateOutputType = {
    id: number | null
    userId: number | null
    avatarId: number | null
  }

  export type StoresMinAggregateOutputType = {
    id: number | null
    userId: number | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    cnpj: string | null
    avatarId: number | null
  }

  export type StoresMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    cnpj: string | null
    avatarId: number | null
  }

  export type StoresCountAggregateOutputType = {
    id: number
    userId: number
    created_at: number
    updated_at: number
    name: number
    cnpj: number
    avatarId: number
    _all: number
  }


  export type StoresAvgAggregateInputType = {
    id?: true
    userId?: true
    avatarId?: true
  }

  export type StoresSumAggregateInputType = {
    id?: true
    userId?: true
    avatarId?: true
  }

  export type StoresMinAggregateInputType = {
    id?: true
    userId?: true
    created_at?: true
    updated_at?: true
    name?: true
    cnpj?: true
    avatarId?: true
  }

  export type StoresMaxAggregateInputType = {
    id?: true
    userId?: true
    created_at?: true
    updated_at?: true
    name?: true
    cnpj?: true
    avatarId?: true
  }

  export type StoresCountAggregateInputType = {
    id?: true
    userId?: true
    created_at?: true
    updated_at?: true
    name?: true
    cnpj?: true
    avatarId?: true
    _all?: true
  }

  export type StoresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to aggregate.
     */
    where?: StoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoresOrderByWithRelationInput | StoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoresMaxAggregateInputType
  }

  export type GetStoresAggregateType<T extends StoresAggregateArgs> = {
        [P in keyof T & keyof AggregateStores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStores[P]>
      : GetScalarType<T[P], AggregateStores[P]>
  }




  export type StoresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoresWhereInput
    orderBy?: StoresOrderByWithAggregationInput | StoresOrderByWithAggregationInput[]
    by: StoresScalarFieldEnum[] | StoresScalarFieldEnum
    having?: StoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoresCountAggregateInputType | true
    _avg?: StoresAvgAggregateInputType
    _sum?: StoresSumAggregateInputType
    _min?: StoresMinAggregateInputType
    _max?: StoresMaxAggregateInputType
  }

  export type StoresGroupByOutputType = {
    id: number
    userId: number
    created_at: Date
    updated_at: Date
    name: string
    cnpj: string | null
    avatarId: number | null
    _count: StoresCountAggregateOutputType | null
    _avg: StoresAvgAggregateOutputType | null
    _sum: StoresSumAggregateOutputType | null
    _min: StoresMinAggregateOutputType | null
    _max: StoresMaxAggregateOutputType | null
  }

  type GetStoresGroupByPayload<T extends StoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoresGroupByOutputType[P]>
            : GetScalarType<T[P], StoresGroupByOutputType[P]>
        }
      >
    >


  export type StoresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    cnpj?: boolean
    avatarId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    avatar?: boolean | Stores$avatarArgs<ExtArgs>
    product?: boolean | Stores$productArgs<ExtArgs>
    avaliations?: boolean | Stores$avaliationsArgs<ExtArgs>
    coupons?: boolean | Stores$couponsArgs<ExtArgs>
    chat?: boolean | Stores$chatArgs<ExtArgs>
    sentMessages?: boolean | Stores$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | Stores$receivedMessagesArgs<ExtArgs>
    orderItems?: boolean | Stores$orderItemsArgs<ExtArgs>
    promotions?: boolean | Stores$promotionsArgs<ExtArgs>
    _count?: boolean | StoresCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stores"]>



  export type StoresSelectScalar = {
    id?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    cnpj?: boolean
    avatarId?: boolean
  }

  export type StoresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "created_at" | "updated_at" | "name" | "cnpj" | "avatarId", ExtArgs["result"]["stores"]>
  export type StoresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    avatar?: boolean | Stores$avatarArgs<ExtArgs>
    product?: boolean | Stores$productArgs<ExtArgs>
    avaliations?: boolean | Stores$avaliationsArgs<ExtArgs>
    coupons?: boolean | Stores$couponsArgs<ExtArgs>
    chat?: boolean | Stores$chatArgs<ExtArgs>
    sentMessages?: boolean | Stores$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | Stores$receivedMessagesArgs<ExtArgs>
    orderItems?: boolean | Stores$orderItemsArgs<ExtArgs>
    promotions?: boolean | Stores$promotionsArgs<ExtArgs>
    _count?: boolean | StoresCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StoresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stores"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      avatar: Prisma.$AvatarStorePayload<ExtArgs> | null
      product: Prisma.$ProductsPayload<ExtArgs>[]
      avaliations: Prisma.$StoreAvaliationsPayload<ExtArgs>[]
      coupons: Prisma.$CouponsPayload<ExtArgs>[]
      chat: Prisma.$ChatPayload<ExtArgs>[]
      sentMessages: Prisma.$chatMessagesPayload<ExtArgs>[]
      receivedMessages: Prisma.$chatMessagesPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemsPayload<ExtArgs>[]
      promotions: Prisma.$PromotionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      created_at: Date
      updated_at: Date
      name: string
      cnpj: string | null
      avatarId: number | null
    }, ExtArgs["result"]["stores"]>
    composites: {}
  }

  type StoresGetPayload<S extends boolean | null | undefined | StoresDefaultArgs> = $Result.GetResult<Prisma.$StoresPayload, S>

  type StoresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoresCountAggregateInputType | true
    }

  export interface StoresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stores'], meta: { name: 'Stores' } }
    /**
     * Find zero or one Stores that matches the filter.
     * @param {StoresFindUniqueArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoresFindUniqueArgs>(args: SelectSubset<T, StoresFindUniqueArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stores that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoresFindUniqueOrThrowArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoresFindUniqueOrThrowArgs>(args: SelectSubset<T, StoresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresFindFirstArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoresFindFirstArgs>(args?: SelectSubset<T, StoresFindFirstArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stores that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresFindFirstOrThrowArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoresFindFirstOrThrowArgs>(args?: SelectSubset<T, StoresFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.stores.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.stores.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storesWithIdOnly = await prisma.stores.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoresFindManyArgs>(args?: SelectSubset<T, StoresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stores.
     * @param {StoresCreateArgs} args - Arguments to create a Stores.
     * @example
     * // Create one Stores
     * const Stores = await prisma.stores.create({
     *   data: {
     *     // ... data to create a Stores
     *   }
     * })
     * 
     */
    create<T extends StoresCreateArgs>(args: SelectSubset<T, StoresCreateArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stores.
     * @param {StoresCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const stores = await prisma.stores.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoresCreateManyArgs>(args?: SelectSubset<T, StoresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stores.
     * @param {StoresDeleteArgs} args - Arguments to delete one Stores.
     * @example
     * // Delete one Stores
     * const Stores = await prisma.stores.delete({
     *   where: {
     *     // ... filter to delete one Stores
     *   }
     * })
     * 
     */
    delete<T extends StoresDeleteArgs>(args: SelectSubset<T, StoresDeleteArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stores.
     * @param {StoresUpdateArgs} args - Arguments to update one Stores.
     * @example
     * // Update one Stores
     * const stores = await prisma.stores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoresUpdateArgs>(args: SelectSubset<T, StoresUpdateArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stores.
     * @param {StoresDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.stores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoresDeleteManyArgs>(args?: SelectSubset<T, StoresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const stores = await prisma.stores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoresUpdateManyArgs>(args: SelectSubset<T, StoresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stores.
     * @param {StoresUpsertArgs} args - Arguments to update or create a Stores.
     * @example
     * // Update or create a Stores
     * const stores = await prisma.stores.upsert({
     *   create: {
     *     // ... data to create a Stores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stores we want to update
     *   }
     * })
     */
    upsert<T extends StoresUpsertArgs>(args: SelectSubset<T, StoresUpsertArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.stores.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoresCountArgs>(
      args?: Subset<T, StoresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoresAggregateArgs>(args: Subset<T, StoresAggregateArgs>): Prisma.PrismaPromise<GetStoresAggregateType<T>>

    /**
     * Group by Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoresGroupByArgs['orderBy'] }
        : { orderBy?: StoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stores model
   */
  readonly fields: StoresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    avatar<T extends Stores$avatarArgs<ExtArgs> = {}>(args?: Subset<T, Stores$avatarArgs<ExtArgs>>): Prisma__AvatarStoreClient<$Result.GetResult<Prisma.$AvatarStorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends Stores$productArgs<ExtArgs> = {}>(args?: Subset<T, Stores$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    avaliations<T extends Stores$avaliationsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$avaliationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreAvaliationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coupons<T extends Stores$couponsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$couponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chat<T extends Stores$chatArgs<ExtArgs> = {}>(args?: Subset<T, Stores$chatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends Stores$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Stores$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatMessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedMessages<T extends Stores$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Stores$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatMessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends Stores$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promotions<T extends Stores$promotionsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$promotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stores model
   */
  interface StoresFieldRefs {
    readonly id: FieldRef<"Stores", 'Int'>
    readonly userId: FieldRef<"Stores", 'Int'>
    readonly created_at: FieldRef<"Stores", 'DateTime'>
    readonly updated_at: FieldRef<"Stores", 'DateTime'>
    readonly name: FieldRef<"Stores", 'String'>
    readonly cnpj: FieldRef<"Stores", 'String'>
    readonly avatarId: FieldRef<"Stores", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Stores findUnique
   */
  export type StoresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where: StoresWhereUniqueInput
  }

  /**
   * Stores findUniqueOrThrow
   */
  export type StoresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where: StoresWhereUniqueInput
  }

  /**
   * Stores findFirst
   */
  export type StoresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoresOrderByWithRelationInput | StoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * Stores findFirstOrThrow
   */
  export type StoresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoresOrderByWithRelationInput | StoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * Stores findMany
   */
  export type StoresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoresOrderByWithRelationInput | StoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * Stores create
   */
  export type StoresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * The data needed to create a Stores.
     */
    data: XOR<StoresCreateInput, StoresUncheckedCreateInput>
  }

  /**
   * Stores createMany
   */
  export type StoresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stores.
     */
    data: StoresCreateManyInput | StoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stores update
   */
  export type StoresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * The data needed to update a Stores.
     */
    data: XOR<StoresUpdateInput, StoresUncheckedUpdateInput>
    /**
     * Choose, which Stores to update.
     */
    where: StoresWhereUniqueInput
  }

  /**
   * Stores updateMany
   */
  export type StoresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoresUpdateManyMutationInput, StoresUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoresWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
  }

  /**
   * Stores upsert
   */
  export type StoresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * The filter to search for the Stores to update in case it exists.
     */
    where: StoresWhereUniqueInput
    /**
     * In case the Stores found by the `where` argument doesn't exist, create a new Stores with this data.
     */
    create: XOR<StoresCreateInput, StoresUncheckedCreateInput>
    /**
     * In case the Stores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoresUpdateInput, StoresUncheckedUpdateInput>
  }

  /**
   * Stores delete
   */
  export type StoresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter which Stores to delete.
     */
    where: StoresWhereUniqueInput
  }

  /**
   * Stores deleteMany
   */
  export type StoresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to delete
     */
    where?: StoresWhereInput
    /**
     * Limit how many Stores to delete.
     */
    limit?: number
  }

  /**
   * Stores.avatar
   */
  export type Stores$avatarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarStore
     */
    select?: AvatarStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarStore
     */
    omit?: AvatarStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarStoreInclude<ExtArgs> | null
    where?: AvatarStoreWhereInput
  }

  /**
   * Stores.product
   */
  export type Stores$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    cursor?: ProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Stores.avaliations
   */
  export type Stores$avaliationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliations
     */
    select?: StoreAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliations
     */
    omit?: StoreAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationsInclude<ExtArgs> | null
    where?: StoreAvaliationsWhereInput
    orderBy?: StoreAvaliationsOrderByWithRelationInput | StoreAvaliationsOrderByWithRelationInput[]
    cursor?: StoreAvaliationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreAvaliationsScalarFieldEnum | StoreAvaliationsScalarFieldEnum[]
  }

  /**
   * Stores.coupons
   */
  export type Stores$couponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupons
     */
    select?: CouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupons
     */
    omit?: CouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponsInclude<ExtArgs> | null
    where?: CouponsWhereInput
    orderBy?: CouponsOrderByWithRelationInput | CouponsOrderByWithRelationInput[]
    cursor?: CouponsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponsScalarFieldEnum | CouponsScalarFieldEnum[]
  }

  /**
   * Stores.chat
   */
  export type Stores$chatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Stores.sentMessages
   */
  export type Stores$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatMessages
     */
    select?: chatMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatMessages
     */
    omit?: chatMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatMessagesInclude<ExtArgs> | null
    where?: chatMessagesWhereInput
    orderBy?: chatMessagesOrderByWithRelationInput | chatMessagesOrderByWithRelationInput[]
    cursor?: chatMessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessagesScalarFieldEnum | ChatMessagesScalarFieldEnum[]
  }

  /**
   * Stores.receivedMessages
   */
  export type Stores$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatMessages
     */
    select?: chatMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatMessages
     */
    omit?: chatMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatMessagesInclude<ExtArgs> | null
    where?: chatMessagesWhereInput
    orderBy?: chatMessagesOrderByWithRelationInput | chatMessagesOrderByWithRelationInput[]
    cursor?: chatMessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessagesScalarFieldEnum | ChatMessagesScalarFieldEnum[]
  }

  /**
   * Stores.orderItems
   */
  export type Stores$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    where?: OrderItemsWhereInput
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    cursor?: OrderItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemsScalarFieldEnum | OrderItemsScalarFieldEnum[]
  }

  /**
   * Stores.promotions
   */
  export type Stores$promotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    cursor?: PromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Stores without action
   */
  export type StoresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
  }


  /**
   * Model AvatarStore
   */

  export type AggregateAvatarStore = {
    _count: AvatarStoreCountAggregateOutputType | null
    _avg: AvatarStoreAvgAggregateOutputType | null
    _sum: AvatarStoreSumAggregateOutputType | null
    _min: AvatarStoreMinAggregateOutputType | null
    _max: AvatarStoreMaxAggregateOutputType | null
  }

  export type AvatarStoreAvgAggregateOutputType = {
    id: number | null
  }

  export type AvatarStoreSumAggregateOutputType = {
    id: number | null
  }

  export type AvatarStoreMinAggregateOutputType = {
    id: number | null
    url: string | null
    publicId: string | null
  }

  export type AvatarStoreMaxAggregateOutputType = {
    id: number | null
    url: string | null
    publicId: string | null
  }

  export type AvatarStoreCountAggregateOutputType = {
    id: number
    url: number
    publicId: number
    _all: number
  }


  export type AvatarStoreAvgAggregateInputType = {
    id?: true
  }

  export type AvatarStoreSumAggregateInputType = {
    id?: true
  }

  export type AvatarStoreMinAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
  }

  export type AvatarStoreMaxAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
  }

  export type AvatarStoreCountAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
    _all?: true
  }

  export type AvatarStoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvatarStore to aggregate.
     */
    where?: AvatarStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarStores to fetch.
     */
    orderBy?: AvatarStoreOrderByWithRelationInput | AvatarStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvatarStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AvatarStores
    **/
    _count?: true | AvatarStoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvatarStoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvatarStoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvatarStoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvatarStoreMaxAggregateInputType
  }

  export type GetAvatarStoreAggregateType<T extends AvatarStoreAggregateArgs> = {
        [P in keyof T & keyof AggregateAvatarStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvatarStore[P]>
      : GetScalarType<T[P], AggregateAvatarStore[P]>
  }




  export type AvatarStoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvatarStoreWhereInput
    orderBy?: AvatarStoreOrderByWithAggregationInput | AvatarStoreOrderByWithAggregationInput[]
    by: AvatarStoreScalarFieldEnum[] | AvatarStoreScalarFieldEnum
    having?: AvatarStoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvatarStoreCountAggregateInputType | true
    _avg?: AvatarStoreAvgAggregateInputType
    _sum?: AvatarStoreSumAggregateInputType
    _min?: AvatarStoreMinAggregateInputType
    _max?: AvatarStoreMaxAggregateInputType
  }

  export type AvatarStoreGroupByOutputType = {
    id: number
    url: string
    publicId: string
    _count: AvatarStoreCountAggregateOutputType | null
    _avg: AvatarStoreAvgAggregateOutputType | null
    _sum: AvatarStoreSumAggregateOutputType | null
    _min: AvatarStoreMinAggregateOutputType | null
    _max: AvatarStoreMaxAggregateOutputType | null
  }

  type GetAvatarStoreGroupByPayload<T extends AvatarStoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvatarStoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvatarStoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvatarStoreGroupByOutputType[P]>
            : GetScalarType<T[P], AvatarStoreGroupByOutputType[P]>
        }
      >
    >


  export type AvatarStoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    publicId?: boolean
    storeAvatar?: boolean | AvatarStore$storeAvatarArgs<ExtArgs>
  }, ExtArgs["result"]["avatarStore"]>



  export type AvatarStoreSelectScalar = {
    id?: boolean
    url?: boolean
    publicId?: boolean
  }

  export type AvatarStoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "publicId", ExtArgs["result"]["avatarStore"]>
  export type AvatarStoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    storeAvatar?: boolean | AvatarStore$storeAvatarArgs<ExtArgs>
  }

  export type $AvatarStorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AvatarStore"
    objects: {
      storeAvatar: Prisma.$StoresPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      publicId: string
    }, ExtArgs["result"]["avatarStore"]>
    composites: {}
  }

  type AvatarStoreGetPayload<S extends boolean | null | undefined | AvatarStoreDefaultArgs> = $Result.GetResult<Prisma.$AvatarStorePayload, S>

  type AvatarStoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvatarStoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvatarStoreCountAggregateInputType | true
    }

  export interface AvatarStoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AvatarStore'], meta: { name: 'AvatarStore' } }
    /**
     * Find zero or one AvatarStore that matches the filter.
     * @param {AvatarStoreFindUniqueArgs} args - Arguments to find a AvatarStore
     * @example
     * // Get one AvatarStore
     * const avatarStore = await prisma.avatarStore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvatarStoreFindUniqueArgs>(args: SelectSubset<T, AvatarStoreFindUniqueArgs<ExtArgs>>): Prisma__AvatarStoreClient<$Result.GetResult<Prisma.$AvatarStorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AvatarStore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvatarStoreFindUniqueOrThrowArgs} args - Arguments to find a AvatarStore
     * @example
     * // Get one AvatarStore
     * const avatarStore = await prisma.avatarStore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvatarStoreFindUniqueOrThrowArgs>(args: SelectSubset<T, AvatarStoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvatarStoreClient<$Result.GetResult<Prisma.$AvatarStorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvatarStore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarStoreFindFirstArgs} args - Arguments to find a AvatarStore
     * @example
     * // Get one AvatarStore
     * const avatarStore = await prisma.avatarStore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvatarStoreFindFirstArgs>(args?: SelectSubset<T, AvatarStoreFindFirstArgs<ExtArgs>>): Prisma__AvatarStoreClient<$Result.GetResult<Prisma.$AvatarStorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvatarStore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarStoreFindFirstOrThrowArgs} args - Arguments to find a AvatarStore
     * @example
     * // Get one AvatarStore
     * const avatarStore = await prisma.avatarStore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvatarStoreFindFirstOrThrowArgs>(args?: SelectSubset<T, AvatarStoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvatarStoreClient<$Result.GetResult<Prisma.$AvatarStorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AvatarStores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarStoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AvatarStores
     * const avatarStores = await prisma.avatarStore.findMany()
     * 
     * // Get first 10 AvatarStores
     * const avatarStores = await prisma.avatarStore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const avatarStoreWithIdOnly = await prisma.avatarStore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvatarStoreFindManyArgs>(args?: SelectSubset<T, AvatarStoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvatarStorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AvatarStore.
     * @param {AvatarStoreCreateArgs} args - Arguments to create a AvatarStore.
     * @example
     * // Create one AvatarStore
     * const AvatarStore = await prisma.avatarStore.create({
     *   data: {
     *     // ... data to create a AvatarStore
     *   }
     * })
     * 
     */
    create<T extends AvatarStoreCreateArgs>(args: SelectSubset<T, AvatarStoreCreateArgs<ExtArgs>>): Prisma__AvatarStoreClient<$Result.GetResult<Prisma.$AvatarStorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AvatarStores.
     * @param {AvatarStoreCreateManyArgs} args - Arguments to create many AvatarStores.
     * @example
     * // Create many AvatarStores
     * const avatarStore = await prisma.avatarStore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvatarStoreCreateManyArgs>(args?: SelectSubset<T, AvatarStoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AvatarStore.
     * @param {AvatarStoreDeleteArgs} args - Arguments to delete one AvatarStore.
     * @example
     * // Delete one AvatarStore
     * const AvatarStore = await prisma.avatarStore.delete({
     *   where: {
     *     // ... filter to delete one AvatarStore
     *   }
     * })
     * 
     */
    delete<T extends AvatarStoreDeleteArgs>(args: SelectSubset<T, AvatarStoreDeleteArgs<ExtArgs>>): Prisma__AvatarStoreClient<$Result.GetResult<Prisma.$AvatarStorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AvatarStore.
     * @param {AvatarStoreUpdateArgs} args - Arguments to update one AvatarStore.
     * @example
     * // Update one AvatarStore
     * const avatarStore = await prisma.avatarStore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvatarStoreUpdateArgs>(args: SelectSubset<T, AvatarStoreUpdateArgs<ExtArgs>>): Prisma__AvatarStoreClient<$Result.GetResult<Prisma.$AvatarStorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AvatarStores.
     * @param {AvatarStoreDeleteManyArgs} args - Arguments to filter AvatarStores to delete.
     * @example
     * // Delete a few AvatarStores
     * const { count } = await prisma.avatarStore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvatarStoreDeleteManyArgs>(args?: SelectSubset<T, AvatarStoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AvatarStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarStoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AvatarStores
     * const avatarStore = await prisma.avatarStore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvatarStoreUpdateManyArgs>(args: SelectSubset<T, AvatarStoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AvatarStore.
     * @param {AvatarStoreUpsertArgs} args - Arguments to update or create a AvatarStore.
     * @example
     * // Update or create a AvatarStore
     * const avatarStore = await prisma.avatarStore.upsert({
     *   create: {
     *     // ... data to create a AvatarStore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AvatarStore we want to update
     *   }
     * })
     */
    upsert<T extends AvatarStoreUpsertArgs>(args: SelectSubset<T, AvatarStoreUpsertArgs<ExtArgs>>): Prisma__AvatarStoreClient<$Result.GetResult<Prisma.$AvatarStorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AvatarStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarStoreCountArgs} args - Arguments to filter AvatarStores to count.
     * @example
     * // Count the number of AvatarStores
     * const count = await prisma.avatarStore.count({
     *   where: {
     *     // ... the filter for the AvatarStores we want to count
     *   }
     * })
    **/
    count<T extends AvatarStoreCountArgs>(
      args?: Subset<T, AvatarStoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvatarStoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AvatarStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarStoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvatarStoreAggregateArgs>(args: Subset<T, AvatarStoreAggregateArgs>): Prisma.PrismaPromise<GetAvatarStoreAggregateType<T>>

    /**
     * Group by AvatarStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarStoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvatarStoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvatarStoreGroupByArgs['orderBy'] }
        : { orderBy?: AvatarStoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvatarStoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvatarStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AvatarStore model
   */
  readonly fields: AvatarStoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AvatarStore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvatarStoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    storeAvatar<T extends AvatarStore$storeAvatarArgs<ExtArgs> = {}>(args?: Subset<T, AvatarStore$storeAvatarArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AvatarStore model
   */
  interface AvatarStoreFieldRefs {
    readonly id: FieldRef<"AvatarStore", 'Int'>
    readonly url: FieldRef<"AvatarStore", 'String'>
    readonly publicId: FieldRef<"AvatarStore", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AvatarStore findUnique
   */
  export type AvatarStoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarStore
     */
    select?: AvatarStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarStore
     */
    omit?: AvatarStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarStoreInclude<ExtArgs> | null
    /**
     * Filter, which AvatarStore to fetch.
     */
    where: AvatarStoreWhereUniqueInput
  }

  /**
   * AvatarStore findUniqueOrThrow
   */
  export type AvatarStoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarStore
     */
    select?: AvatarStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarStore
     */
    omit?: AvatarStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarStoreInclude<ExtArgs> | null
    /**
     * Filter, which AvatarStore to fetch.
     */
    where: AvatarStoreWhereUniqueInput
  }

  /**
   * AvatarStore findFirst
   */
  export type AvatarStoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarStore
     */
    select?: AvatarStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarStore
     */
    omit?: AvatarStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarStoreInclude<ExtArgs> | null
    /**
     * Filter, which AvatarStore to fetch.
     */
    where?: AvatarStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarStores to fetch.
     */
    orderBy?: AvatarStoreOrderByWithRelationInput | AvatarStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvatarStores.
     */
    cursor?: AvatarStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvatarStores.
     */
    distinct?: AvatarStoreScalarFieldEnum | AvatarStoreScalarFieldEnum[]
  }

  /**
   * AvatarStore findFirstOrThrow
   */
  export type AvatarStoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarStore
     */
    select?: AvatarStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarStore
     */
    omit?: AvatarStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarStoreInclude<ExtArgs> | null
    /**
     * Filter, which AvatarStore to fetch.
     */
    where?: AvatarStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarStores to fetch.
     */
    orderBy?: AvatarStoreOrderByWithRelationInput | AvatarStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvatarStores.
     */
    cursor?: AvatarStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvatarStores.
     */
    distinct?: AvatarStoreScalarFieldEnum | AvatarStoreScalarFieldEnum[]
  }

  /**
   * AvatarStore findMany
   */
  export type AvatarStoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarStore
     */
    select?: AvatarStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarStore
     */
    omit?: AvatarStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarStoreInclude<ExtArgs> | null
    /**
     * Filter, which AvatarStores to fetch.
     */
    where?: AvatarStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarStores to fetch.
     */
    orderBy?: AvatarStoreOrderByWithRelationInput | AvatarStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AvatarStores.
     */
    cursor?: AvatarStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarStores.
     */
    skip?: number
    distinct?: AvatarStoreScalarFieldEnum | AvatarStoreScalarFieldEnum[]
  }

  /**
   * AvatarStore create
   */
  export type AvatarStoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarStore
     */
    select?: AvatarStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarStore
     */
    omit?: AvatarStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarStoreInclude<ExtArgs> | null
    /**
     * The data needed to create a AvatarStore.
     */
    data: XOR<AvatarStoreCreateInput, AvatarStoreUncheckedCreateInput>
  }

  /**
   * AvatarStore createMany
   */
  export type AvatarStoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AvatarStores.
     */
    data: AvatarStoreCreateManyInput | AvatarStoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AvatarStore update
   */
  export type AvatarStoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarStore
     */
    select?: AvatarStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarStore
     */
    omit?: AvatarStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarStoreInclude<ExtArgs> | null
    /**
     * The data needed to update a AvatarStore.
     */
    data: XOR<AvatarStoreUpdateInput, AvatarStoreUncheckedUpdateInput>
    /**
     * Choose, which AvatarStore to update.
     */
    where: AvatarStoreWhereUniqueInput
  }

  /**
   * AvatarStore updateMany
   */
  export type AvatarStoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AvatarStores.
     */
    data: XOR<AvatarStoreUpdateManyMutationInput, AvatarStoreUncheckedUpdateManyInput>
    /**
     * Filter which AvatarStores to update
     */
    where?: AvatarStoreWhereInput
    /**
     * Limit how many AvatarStores to update.
     */
    limit?: number
  }

  /**
   * AvatarStore upsert
   */
  export type AvatarStoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarStore
     */
    select?: AvatarStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarStore
     */
    omit?: AvatarStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarStoreInclude<ExtArgs> | null
    /**
     * The filter to search for the AvatarStore to update in case it exists.
     */
    where: AvatarStoreWhereUniqueInput
    /**
     * In case the AvatarStore found by the `where` argument doesn't exist, create a new AvatarStore with this data.
     */
    create: XOR<AvatarStoreCreateInput, AvatarStoreUncheckedCreateInput>
    /**
     * In case the AvatarStore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvatarStoreUpdateInput, AvatarStoreUncheckedUpdateInput>
  }

  /**
   * AvatarStore delete
   */
  export type AvatarStoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarStore
     */
    select?: AvatarStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarStore
     */
    omit?: AvatarStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarStoreInclude<ExtArgs> | null
    /**
     * Filter which AvatarStore to delete.
     */
    where: AvatarStoreWhereUniqueInput
  }

  /**
   * AvatarStore deleteMany
   */
  export type AvatarStoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvatarStores to delete
     */
    where?: AvatarStoreWhereInput
    /**
     * Limit how many AvatarStores to delete.
     */
    limit?: number
  }

  /**
   * AvatarStore.storeAvatar
   */
  export type AvatarStore$storeAvatarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    where?: StoresWhereInput
  }

  /**
   * AvatarStore without action
   */
  export type AvatarStoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarStore
     */
    select?: AvatarStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarStore
     */
    omit?: AvatarStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarStoreInclude<ExtArgs> | null
  }


  /**
   * Model StoreAvaliations
   */

  export type AggregateStoreAvaliations = {
    _count: StoreAvaliationsCountAggregateOutputType | null
    _avg: StoreAvaliationsAvgAggregateOutputType | null
    _sum: StoreAvaliationsSumAggregateOutputType | null
    _min: StoreAvaliationsMinAggregateOutputType | null
    _max: StoreAvaliationsMaxAggregateOutputType | null
  }

  export type StoreAvaliationsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    storeId: number | null
    note: number | null
  }

  export type StoreAvaliationsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    storeId: number | null
    note: number | null
  }

  export type StoreAvaliationsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    storeId: number | null
    note: number | null
    avaliationDate: Date | null
    comment: string | null
  }

  export type StoreAvaliationsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    storeId: number | null
    note: number | null
    avaliationDate: Date | null
    comment: string | null
  }

  export type StoreAvaliationsCountAggregateOutputType = {
    id: number
    userId: number
    storeId: number
    note: number
    avaliationDate: number
    comment: number
    _all: number
  }


  export type StoreAvaliationsAvgAggregateInputType = {
    id?: true
    userId?: true
    storeId?: true
    note?: true
  }

  export type StoreAvaliationsSumAggregateInputType = {
    id?: true
    userId?: true
    storeId?: true
    note?: true
  }

  export type StoreAvaliationsMinAggregateInputType = {
    id?: true
    userId?: true
    storeId?: true
    note?: true
    avaliationDate?: true
    comment?: true
  }

  export type StoreAvaliationsMaxAggregateInputType = {
    id?: true
    userId?: true
    storeId?: true
    note?: true
    avaliationDate?: true
    comment?: true
  }

  export type StoreAvaliationsCountAggregateInputType = {
    id?: true
    userId?: true
    storeId?: true
    note?: true
    avaliationDate?: true
    comment?: true
    _all?: true
  }

  export type StoreAvaliationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreAvaliations to aggregate.
     */
    where?: StoreAvaliationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreAvaliations to fetch.
     */
    orderBy?: StoreAvaliationsOrderByWithRelationInput | StoreAvaliationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreAvaliationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreAvaliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreAvaliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreAvaliations
    **/
    _count?: true | StoreAvaliationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreAvaliationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreAvaliationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreAvaliationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreAvaliationsMaxAggregateInputType
  }

  export type GetStoreAvaliationsAggregateType<T extends StoreAvaliationsAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreAvaliations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreAvaliations[P]>
      : GetScalarType<T[P], AggregateStoreAvaliations[P]>
  }




  export type StoreAvaliationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreAvaliationsWhereInput
    orderBy?: StoreAvaliationsOrderByWithAggregationInput | StoreAvaliationsOrderByWithAggregationInput[]
    by: StoreAvaliationsScalarFieldEnum[] | StoreAvaliationsScalarFieldEnum
    having?: StoreAvaliationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreAvaliationsCountAggregateInputType | true
    _avg?: StoreAvaliationsAvgAggregateInputType
    _sum?: StoreAvaliationsSumAggregateInputType
    _min?: StoreAvaliationsMinAggregateInputType
    _max?: StoreAvaliationsMaxAggregateInputType
  }

  export type StoreAvaliationsGroupByOutputType = {
    id: number
    userId: number
    storeId: number
    note: number
    avaliationDate: Date
    comment: string | null
    _count: StoreAvaliationsCountAggregateOutputType | null
    _avg: StoreAvaliationsAvgAggregateOutputType | null
    _sum: StoreAvaliationsSumAggregateOutputType | null
    _min: StoreAvaliationsMinAggregateOutputType | null
    _max: StoreAvaliationsMaxAggregateOutputType | null
  }

  type GetStoreAvaliationsGroupByPayload<T extends StoreAvaliationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreAvaliationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreAvaliationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreAvaliationsGroupByOutputType[P]>
            : GetScalarType<T[P], StoreAvaliationsGroupByOutputType[P]>
        }
      >
    >


  export type StoreAvaliationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    storeId?: boolean
    note?: boolean
    avaliationDate?: boolean
    comment?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | StoresDefaultArgs<ExtArgs>
    images?: boolean | StoreAvaliations$imagesArgs<ExtArgs>
    _count?: boolean | StoreAvaliationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeAvaliations"]>



  export type StoreAvaliationsSelectScalar = {
    id?: boolean
    userId?: boolean
    storeId?: boolean
    note?: boolean
    avaliationDate?: boolean
    comment?: boolean
  }

  export type StoreAvaliationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "storeId" | "note" | "avaliationDate" | "comment", ExtArgs["result"]["storeAvaliations"]>
  export type StoreAvaliationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | StoresDefaultArgs<ExtArgs>
    images?: boolean | StoreAvaliations$imagesArgs<ExtArgs>
    _count?: boolean | StoreAvaliationsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StoreAvaliationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreAvaliations"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      store: Prisma.$StoresPayload<ExtArgs>
      images: Prisma.$StoreAvaliationImagesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      storeId: number
      note: number
      avaliationDate: Date
      comment: string | null
    }, ExtArgs["result"]["storeAvaliations"]>
    composites: {}
  }

  type StoreAvaliationsGetPayload<S extends boolean | null | undefined | StoreAvaliationsDefaultArgs> = $Result.GetResult<Prisma.$StoreAvaliationsPayload, S>

  type StoreAvaliationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoreAvaliationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoreAvaliationsCountAggregateInputType | true
    }

  export interface StoreAvaliationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreAvaliations'], meta: { name: 'StoreAvaliations' } }
    /**
     * Find zero or one StoreAvaliations that matches the filter.
     * @param {StoreAvaliationsFindUniqueArgs} args - Arguments to find a StoreAvaliations
     * @example
     * // Get one StoreAvaliations
     * const storeAvaliations = await prisma.storeAvaliations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreAvaliationsFindUniqueArgs>(args: SelectSubset<T, StoreAvaliationsFindUniqueArgs<ExtArgs>>): Prisma__StoreAvaliationsClient<$Result.GetResult<Prisma.$StoreAvaliationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StoreAvaliations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoreAvaliationsFindUniqueOrThrowArgs} args - Arguments to find a StoreAvaliations
     * @example
     * // Get one StoreAvaliations
     * const storeAvaliations = await prisma.storeAvaliations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreAvaliationsFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreAvaliationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreAvaliationsClient<$Result.GetResult<Prisma.$StoreAvaliationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoreAvaliations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAvaliationsFindFirstArgs} args - Arguments to find a StoreAvaliations
     * @example
     * // Get one StoreAvaliations
     * const storeAvaliations = await prisma.storeAvaliations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreAvaliationsFindFirstArgs>(args?: SelectSubset<T, StoreAvaliationsFindFirstArgs<ExtArgs>>): Prisma__StoreAvaliationsClient<$Result.GetResult<Prisma.$StoreAvaliationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoreAvaliations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAvaliationsFindFirstOrThrowArgs} args - Arguments to find a StoreAvaliations
     * @example
     * // Get one StoreAvaliations
     * const storeAvaliations = await prisma.storeAvaliations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreAvaliationsFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreAvaliationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreAvaliationsClient<$Result.GetResult<Prisma.$StoreAvaliationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StoreAvaliations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAvaliationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreAvaliations
     * const storeAvaliations = await prisma.storeAvaliations.findMany()
     * 
     * // Get first 10 StoreAvaliations
     * const storeAvaliations = await prisma.storeAvaliations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeAvaliationsWithIdOnly = await prisma.storeAvaliations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreAvaliationsFindManyArgs>(args?: SelectSubset<T, StoreAvaliationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreAvaliationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StoreAvaliations.
     * @param {StoreAvaliationsCreateArgs} args - Arguments to create a StoreAvaliations.
     * @example
     * // Create one StoreAvaliations
     * const StoreAvaliations = await prisma.storeAvaliations.create({
     *   data: {
     *     // ... data to create a StoreAvaliations
     *   }
     * })
     * 
     */
    create<T extends StoreAvaliationsCreateArgs>(args: SelectSubset<T, StoreAvaliationsCreateArgs<ExtArgs>>): Prisma__StoreAvaliationsClient<$Result.GetResult<Prisma.$StoreAvaliationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StoreAvaliations.
     * @param {StoreAvaliationsCreateManyArgs} args - Arguments to create many StoreAvaliations.
     * @example
     * // Create many StoreAvaliations
     * const storeAvaliations = await prisma.storeAvaliations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreAvaliationsCreateManyArgs>(args?: SelectSubset<T, StoreAvaliationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StoreAvaliations.
     * @param {StoreAvaliationsDeleteArgs} args - Arguments to delete one StoreAvaliations.
     * @example
     * // Delete one StoreAvaliations
     * const StoreAvaliations = await prisma.storeAvaliations.delete({
     *   where: {
     *     // ... filter to delete one StoreAvaliations
     *   }
     * })
     * 
     */
    delete<T extends StoreAvaliationsDeleteArgs>(args: SelectSubset<T, StoreAvaliationsDeleteArgs<ExtArgs>>): Prisma__StoreAvaliationsClient<$Result.GetResult<Prisma.$StoreAvaliationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StoreAvaliations.
     * @param {StoreAvaliationsUpdateArgs} args - Arguments to update one StoreAvaliations.
     * @example
     * // Update one StoreAvaliations
     * const storeAvaliations = await prisma.storeAvaliations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreAvaliationsUpdateArgs>(args: SelectSubset<T, StoreAvaliationsUpdateArgs<ExtArgs>>): Prisma__StoreAvaliationsClient<$Result.GetResult<Prisma.$StoreAvaliationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StoreAvaliations.
     * @param {StoreAvaliationsDeleteManyArgs} args - Arguments to filter StoreAvaliations to delete.
     * @example
     * // Delete a few StoreAvaliations
     * const { count } = await prisma.storeAvaliations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreAvaliationsDeleteManyArgs>(args?: SelectSubset<T, StoreAvaliationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreAvaliations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAvaliationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreAvaliations
     * const storeAvaliations = await prisma.storeAvaliations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreAvaliationsUpdateManyArgs>(args: SelectSubset<T, StoreAvaliationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreAvaliations.
     * @param {StoreAvaliationsUpsertArgs} args - Arguments to update or create a StoreAvaliations.
     * @example
     * // Update or create a StoreAvaliations
     * const storeAvaliations = await prisma.storeAvaliations.upsert({
     *   create: {
     *     // ... data to create a StoreAvaliations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreAvaliations we want to update
     *   }
     * })
     */
    upsert<T extends StoreAvaliationsUpsertArgs>(args: SelectSubset<T, StoreAvaliationsUpsertArgs<ExtArgs>>): Prisma__StoreAvaliationsClient<$Result.GetResult<Prisma.$StoreAvaliationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StoreAvaliations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAvaliationsCountArgs} args - Arguments to filter StoreAvaliations to count.
     * @example
     * // Count the number of StoreAvaliations
     * const count = await prisma.storeAvaliations.count({
     *   where: {
     *     // ... the filter for the StoreAvaliations we want to count
     *   }
     * })
    **/
    count<T extends StoreAvaliationsCountArgs>(
      args?: Subset<T, StoreAvaliationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreAvaliationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreAvaliations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAvaliationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAvaliationsAggregateArgs>(args: Subset<T, StoreAvaliationsAggregateArgs>): Prisma.PrismaPromise<GetStoreAvaliationsAggregateType<T>>

    /**
     * Group by StoreAvaliations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAvaliationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreAvaliationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreAvaliationsGroupByArgs['orderBy'] }
        : { orderBy?: StoreAvaliationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreAvaliationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreAvaliationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreAvaliations model
   */
  readonly fields: StoreAvaliationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreAvaliations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreAvaliationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    store<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    images<T extends StoreAvaliations$imagesArgs<ExtArgs> = {}>(args?: Subset<T, StoreAvaliations$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreAvaliationImagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreAvaliations model
   */
  interface StoreAvaliationsFieldRefs {
    readonly id: FieldRef<"StoreAvaliations", 'Int'>
    readonly userId: FieldRef<"StoreAvaliations", 'Int'>
    readonly storeId: FieldRef<"StoreAvaliations", 'Int'>
    readonly note: FieldRef<"StoreAvaliations", 'Int'>
    readonly avaliationDate: FieldRef<"StoreAvaliations", 'DateTime'>
    readonly comment: FieldRef<"StoreAvaliations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StoreAvaliations findUnique
   */
  export type StoreAvaliationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliations
     */
    select?: StoreAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliations
     */
    omit?: StoreAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationsInclude<ExtArgs> | null
    /**
     * Filter, which StoreAvaliations to fetch.
     */
    where: StoreAvaliationsWhereUniqueInput
  }

  /**
   * StoreAvaliations findUniqueOrThrow
   */
  export type StoreAvaliationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliations
     */
    select?: StoreAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliations
     */
    omit?: StoreAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationsInclude<ExtArgs> | null
    /**
     * Filter, which StoreAvaliations to fetch.
     */
    where: StoreAvaliationsWhereUniqueInput
  }

  /**
   * StoreAvaliations findFirst
   */
  export type StoreAvaliationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliations
     */
    select?: StoreAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliations
     */
    omit?: StoreAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationsInclude<ExtArgs> | null
    /**
     * Filter, which StoreAvaliations to fetch.
     */
    where?: StoreAvaliationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreAvaliations to fetch.
     */
    orderBy?: StoreAvaliationsOrderByWithRelationInput | StoreAvaliationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreAvaliations.
     */
    cursor?: StoreAvaliationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreAvaliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreAvaliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreAvaliations.
     */
    distinct?: StoreAvaliationsScalarFieldEnum | StoreAvaliationsScalarFieldEnum[]
  }

  /**
   * StoreAvaliations findFirstOrThrow
   */
  export type StoreAvaliationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliations
     */
    select?: StoreAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliations
     */
    omit?: StoreAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationsInclude<ExtArgs> | null
    /**
     * Filter, which StoreAvaliations to fetch.
     */
    where?: StoreAvaliationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreAvaliations to fetch.
     */
    orderBy?: StoreAvaliationsOrderByWithRelationInput | StoreAvaliationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreAvaliations.
     */
    cursor?: StoreAvaliationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreAvaliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreAvaliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreAvaliations.
     */
    distinct?: StoreAvaliationsScalarFieldEnum | StoreAvaliationsScalarFieldEnum[]
  }

  /**
   * StoreAvaliations findMany
   */
  export type StoreAvaliationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliations
     */
    select?: StoreAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliations
     */
    omit?: StoreAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationsInclude<ExtArgs> | null
    /**
     * Filter, which StoreAvaliations to fetch.
     */
    where?: StoreAvaliationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreAvaliations to fetch.
     */
    orderBy?: StoreAvaliationsOrderByWithRelationInput | StoreAvaliationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreAvaliations.
     */
    cursor?: StoreAvaliationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreAvaliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreAvaliations.
     */
    skip?: number
    distinct?: StoreAvaliationsScalarFieldEnum | StoreAvaliationsScalarFieldEnum[]
  }

  /**
   * StoreAvaliations create
   */
  export type StoreAvaliationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliations
     */
    select?: StoreAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliations
     */
    omit?: StoreAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationsInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreAvaliations.
     */
    data: XOR<StoreAvaliationsCreateInput, StoreAvaliationsUncheckedCreateInput>
  }

  /**
   * StoreAvaliations createMany
   */
  export type StoreAvaliationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreAvaliations.
     */
    data: StoreAvaliationsCreateManyInput | StoreAvaliationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreAvaliations update
   */
  export type StoreAvaliationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliations
     */
    select?: StoreAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliations
     */
    omit?: StoreAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationsInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreAvaliations.
     */
    data: XOR<StoreAvaliationsUpdateInput, StoreAvaliationsUncheckedUpdateInput>
    /**
     * Choose, which StoreAvaliations to update.
     */
    where: StoreAvaliationsWhereUniqueInput
  }

  /**
   * StoreAvaliations updateMany
   */
  export type StoreAvaliationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreAvaliations.
     */
    data: XOR<StoreAvaliationsUpdateManyMutationInput, StoreAvaliationsUncheckedUpdateManyInput>
    /**
     * Filter which StoreAvaliations to update
     */
    where?: StoreAvaliationsWhereInput
    /**
     * Limit how many StoreAvaliations to update.
     */
    limit?: number
  }

  /**
   * StoreAvaliations upsert
   */
  export type StoreAvaliationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliations
     */
    select?: StoreAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliations
     */
    omit?: StoreAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationsInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreAvaliations to update in case it exists.
     */
    where: StoreAvaliationsWhereUniqueInput
    /**
     * In case the StoreAvaliations found by the `where` argument doesn't exist, create a new StoreAvaliations with this data.
     */
    create: XOR<StoreAvaliationsCreateInput, StoreAvaliationsUncheckedCreateInput>
    /**
     * In case the StoreAvaliations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreAvaliationsUpdateInput, StoreAvaliationsUncheckedUpdateInput>
  }

  /**
   * StoreAvaliations delete
   */
  export type StoreAvaliationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliations
     */
    select?: StoreAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliations
     */
    omit?: StoreAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationsInclude<ExtArgs> | null
    /**
     * Filter which StoreAvaliations to delete.
     */
    where: StoreAvaliationsWhereUniqueInput
  }

  /**
   * StoreAvaliations deleteMany
   */
  export type StoreAvaliationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreAvaliations to delete
     */
    where?: StoreAvaliationsWhereInput
    /**
     * Limit how many StoreAvaliations to delete.
     */
    limit?: number
  }

  /**
   * StoreAvaliations.images
   */
  export type StoreAvaliations$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliationImages
     */
    select?: StoreAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliationImages
     */
    omit?: StoreAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationImagesInclude<ExtArgs> | null
    where?: StoreAvaliationImagesWhereInput
    orderBy?: StoreAvaliationImagesOrderByWithRelationInput | StoreAvaliationImagesOrderByWithRelationInput[]
    cursor?: StoreAvaliationImagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreAvaliationImagesScalarFieldEnum | StoreAvaliationImagesScalarFieldEnum[]
  }

  /**
   * StoreAvaliations without action
   */
  export type StoreAvaliationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliations
     */
    select?: StoreAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliations
     */
    omit?: StoreAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationsInclude<ExtArgs> | null
  }


  /**
   * Model StoreAvaliationImages
   */

  export type AggregateStoreAvaliationImages = {
    _count: StoreAvaliationImagesCountAggregateOutputType | null
    _avg: StoreAvaliationImagesAvgAggregateOutputType | null
    _sum: StoreAvaliationImagesSumAggregateOutputType | null
    _min: StoreAvaliationImagesMinAggregateOutputType | null
    _max: StoreAvaliationImagesMaxAggregateOutputType | null
  }

  export type StoreAvaliationImagesAvgAggregateOutputType = {
    id: number | null
    storeAvaliationId: number | null
  }

  export type StoreAvaliationImagesSumAggregateOutputType = {
    id: number | null
    storeAvaliationId: number | null
  }

  export type StoreAvaliationImagesMinAggregateOutputType = {
    id: number | null
    url: string | null
    publicId: string | null
    storeAvaliationId: number | null
  }

  export type StoreAvaliationImagesMaxAggregateOutputType = {
    id: number | null
    url: string | null
    publicId: string | null
    storeAvaliationId: number | null
  }

  export type StoreAvaliationImagesCountAggregateOutputType = {
    id: number
    url: number
    publicId: number
    storeAvaliationId: number
    _all: number
  }


  export type StoreAvaliationImagesAvgAggregateInputType = {
    id?: true
    storeAvaliationId?: true
  }

  export type StoreAvaliationImagesSumAggregateInputType = {
    id?: true
    storeAvaliationId?: true
  }

  export type StoreAvaliationImagesMinAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
    storeAvaliationId?: true
  }

  export type StoreAvaliationImagesMaxAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
    storeAvaliationId?: true
  }

  export type StoreAvaliationImagesCountAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
    storeAvaliationId?: true
    _all?: true
  }

  export type StoreAvaliationImagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreAvaliationImages to aggregate.
     */
    where?: StoreAvaliationImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreAvaliationImages to fetch.
     */
    orderBy?: StoreAvaliationImagesOrderByWithRelationInput | StoreAvaliationImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreAvaliationImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreAvaliationImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreAvaliationImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreAvaliationImages
    **/
    _count?: true | StoreAvaliationImagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreAvaliationImagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreAvaliationImagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreAvaliationImagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreAvaliationImagesMaxAggregateInputType
  }

  export type GetStoreAvaliationImagesAggregateType<T extends StoreAvaliationImagesAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreAvaliationImages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreAvaliationImages[P]>
      : GetScalarType<T[P], AggregateStoreAvaliationImages[P]>
  }




  export type StoreAvaliationImagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreAvaliationImagesWhereInput
    orderBy?: StoreAvaliationImagesOrderByWithAggregationInput | StoreAvaliationImagesOrderByWithAggregationInput[]
    by: StoreAvaliationImagesScalarFieldEnum[] | StoreAvaliationImagesScalarFieldEnum
    having?: StoreAvaliationImagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreAvaliationImagesCountAggregateInputType | true
    _avg?: StoreAvaliationImagesAvgAggregateInputType
    _sum?: StoreAvaliationImagesSumAggregateInputType
    _min?: StoreAvaliationImagesMinAggregateInputType
    _max?: StoreAvaliationImagesMaxAggregateInputType
  }

  export type StoreAvaliationImagesGroupByOutputType = {
    id: number
    url: string
    publicId: string
    storeAvaliationId: number | null
    _count: StoreAvaliationImagesCountAggregateOutputType | null
    _avg: StoreAvaliationImagesAvgAggregateOutputType | null
    _sum: StoreAvaliationImagesSumAggregateOutputType | null
    _min: StoreAvaliationImagesMinAggregateOutputType | null
    _max: StoreAvaliationImagesMaxAggregateOutputType | null
  }

  type GetStoreAvaliationImagesGroupByPayload<T extends StoreAvaliationImagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreAvaliationImagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreAvaliationImagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreAvaliationImagesGroupByOutputType[P]>
            : GetScalarType<T[P], StoreAvaliationImagesGroupByOutputType[P]>
        }
      >
    >


  export type StoreAvaliationImagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    publicId?: boolean
    storeAvaliationId?: boolean
    storeAvaliation?: boolean | StoreAvaliationImages$storeAvaliationArgs<ExtArgs>
  }, ExtArgs["result"]["storeAvaliationImages"]>



  export type StoreAvaliationImagesSelectScalar = {
    id?: boolean
    url?: boolean
    publicId?: boolean
    storeAvaliationId?: boolean
  }

  export type StoreAvaliationImagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "publicId" | "storeAvaliationId", ExtArgs["result"]["storeAvaliationImages"]>
  export type StoreAvaliationImagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    storeAvaliation?: boolean | StoreAvaliationImages$storeAvaliationArgs<ExtArgs>
  }

  export type $StoreAvaliationImagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreAvaliationImages"
    objects: {
      storeAvaliation: Prisma.$StoreAvaliationsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      publicId: string
      storeAvaliationId: number | null
    }, ExtArgs["result"]["storeAvaliationImages"]>
    composites: {}
  }

  type StoreAvaliationImagesGetPayload<S extends boolean | null | undefined | StoreAvaliationImagesDefaultArgs> = $Result.GetResult<Prisma.$StoreAvaliationImagesPayload, S>

  type StoreAvaliationImagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoreAvaliationImagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoreAvaliationImagesCountAggregateInputType | true
    }

  export interface StoreAvaliationImagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreAvaliationImages'], meta: { name: 'StoreAvaliationImages' } }
    /**
     * Find zero or one StoreAvaliationImages that matches the filter.
     * @param {StoreAvaliationImagesFindUniqueArgs} args - Arguments to find a StoreAvaliationImages
     * @example
     * // Get one StoreAvaliationImages
     * const storeAvaliationImages = await prisma.storeAvaliationImages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreAvaliationImagesFindUniqueArgs>(args: SelectSubset<T, StoreAvaliationImagesFindUniqueArgs<ExtArgs>>): Prisma__StoreAvaliationImagesClient<$Result.GetResult<Prisma.$StoreAvaliationImagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StoreAvaliationImages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoreAvaliationImagesFindUniqueOrThrowArgs} args - Arguments to find a StoreAvaliationImages
     * @example
     * // Get one StoreAvaliationImages
     * const storeAvaliationImages = await prisma.storeAvaliationImages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreAvaliationImagesFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreAvaliationImagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreAvaliationImagesClient<$Result.GetResult<Prisma.$StoreAvaliationImagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoreAvaliationImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAvaliationImagesFindFirstArgs} args - Arguments to find a StoreAvaliationImages
     * @example
     * // Get one StoreAvaliationImages
     * const storeAvaliationImages = await prisma.storeAvaliationImages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreAvaliationImagesFindFirstArgs>(args?: SelectSubset<T, StoreAvaliationImagesFindFirstArgs<ExtArgs>>): Prisma__StoreAvaliationImagesClient<$Result.GetResult<Prisma.$StoreAvaliationImagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoreAvaliationImages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAvaliationImagesFindFirstOrThrowArgs} args - Arguments to find a StoreAvaliationImages
     * @example
     * // Get one StoreAvaliationImages
     * const storeAvaliationImages = await prisma.storeAvaliationImages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreAvaliationImagesFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreAvaliationImagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreAvaliationImagesClient<$Result.GetResult<Prisma.$StoreAvaliationImagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StoreAvaliationImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAvaliationImagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreAvaliationImages
     * const storeAvaliationImages = await prisma.storeAvaliationImages.findMany()
     * 
     * // Get first 10 StoreAvaliationImages
     * const storeAvaliationImages = await prisma.storeAvaliationImages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeAvaliationImagesWithIdOnly = await prisma.storeAvaliationImages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreAvaliationImagesFindManyArgs>(args?: SelectSubset<T, StoreAvaliationImagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreAvaliationImagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StoreAvaliationImages.
     * @param {StoreAvaliationImagesCreateArgs} args - Arguments to create a StoreAvaliationImages.
     * @example
     * // Create one StoreAvaliationImages
     * const StoreAvaliationImages = await prisma.storeAvaliationImages.create({
     *   data: {
     *     // ... data to create a StoreAvaliationImages
     *   }
     * })
     * 
     */
    create<T extends StoreAvaliationImagesCreateArgs>(args: SelectSubset<T, StoreAvaliationImagesCreateArgs<ExtArgs>>): Prisma__StoreAvaliationImagesClient<$Result.GetResult<Prisma.$StoreAvaliationImagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StoreAvaliationImages.
     * @param {StoreAvaliationImagesCreateManyArgs} args - Arguments to create many StoreAvaliationImages.
     * @example
     * // Create many StoreAvaliationImages
     * const storeAvaliationImages = await prisma.storeAvaliationImages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreAvaliationImagesCreateManyArgs>(args?: SelectSubset<T, StoreAvaliationImagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StoreAvaliationImages.
     * @param {StoreAvaliationImagesDeleteArgs} args - Arguments to delete one StoreAvaliationImages.
     * @example
     * // Delete one StoreAvaliationImages
     * const StoreAvaliationImages = await prisma.storeAvaliationImages.delete({
     *   where: {
     *     // ... filter to delete one StoreAvaliationImages
     *   }
     * })
     * 
     */
    delete<T extends StoreAvaliationImagesDeleteArgs>(args: SelectSubset<T, StoreAvaliationImagesDeleteArgs<ExtArgs>>): Prisma__StoreAvaliationImagesClient<$Result.GetResult<Prisma.$StoreAvaliationImagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StoreAvaliationImages.
     * @param {StoreAvaliationImagesUpdateArgs} args - Arguments to update one StoreAvaliationImages.
     * @example
     * // Update one StoreAvaliationImages
     * const storeAvaliationImages = await prisma.storeAvaliationImages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreAvaliationImagesUpdateArgs>(args: SelectSubset<T, StoreAvaliationImagesUpdateArgs<ExtArgs>>): Prisma__StoreAvaliationImagesClient<$Result.GetResult<Prisma.$StoreAvaliationImagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StoreAvaliationImages.
     * @param {StoreAvaliationImagesDeleteManyArgs} args - Arguments to filter StoreAvaliationImages to delete.
     * @example
     * // Delete a few StoreAvaliationImages
     * const { count } = await prisma.storeAvaliationImages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreAvaliationImagesDeleteManyArgs>(args?: SelectSubset<T, StoreAvaliationImagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreAvaliationImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAvaliationImagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreAvaliationImages
     * const storeAvaliationImages = await prisma.storeAvaliationImages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreAvaliationImagesUpdateManyArgs>(args: SelectSubset<T, StoreAvaliationImagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreAvaliationImages.
     * @param {StoreAvaliationImagesUpsertArgs} args - Arguments to update or create a StoreAvaliationImages.
     * @example
     * // Update or create a StoreAvaliationImages
     * const storeAvaliationImages = await prisma.storeAvaliationImages.upsert({
     *   create: {
     *     // ... data to create a StoreAvaliationImages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreAvaliationImages we want to update
     *   }
     * })
     */
    upsert<T extends StoreAvaliationImagesUpsertArgs>(args: SelectSubset<T, StoreAvaliationImagesUpsertArgs<ExtArgs>>): Prisma__StoreAvaliationImagesClient<$Result.GetResult<Prisma.$StoreAvaliationImagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StoreAvaliationImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAvaliationImagesCountArgs} args - Arguments to filter StoreAvaliationImages to count.
     * @example
     * // Count the number of StoreAvaliationImages
     * const count = await prisma.storeAvaliationImages.count({
     *   where: {
     *     // ... the filter for the StoreAvaliationImages we want to count
     *   }
     * })
    **/
    count<T extends StoreAvaliationImagesCountArgs>(
      args?: Subset<T, StoreAvaliationImagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreAvaliationImagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreAvaliationImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAvaliationImagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAvaliationImagesAggregateArgs>(args: Subset<T, StoreAvaliationImagesAggregateArgs>): Prisma.PrismaPromise<GetStoreAvaliationImagesAggregateType<T>>

    /**
     * Group by StoreAvaliationImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAvaliationImagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreAvaliationImagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreAvaliationImagesGroupByArgs['orderBy'] }
        : { orderBy?: StoreAvaliationImagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreAvaliationImagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreAvaliationImagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreAvaliationImages model
   */
  readonly fields: StoreAvaliationImagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreAvaliationImages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreAvaliationImagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    storeAvaliation<T extends StoreAvaliationImages$storeAvaliationArgs<ExtArgs> = {}>(args?: Subset<T, StoreAvaliationImages$storeAvaliationArgs<ExtArgs>>): Prisma__StoreAvaliationsClient<$Result.GetResult<Prisma.$StoreAvaliationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreAvaliationImages model
   */
  interface StoreAvaliationImagesFieldRefs {
    readonly id: FieldRef<"StoreAvaliationImages", 'Int'>
    readonly url: FieldRef<"StoreAvaliationImages", 'String'>
    readonly publicId: FieldRef<"StoreAvaliationImages", 'String'>
    readonly storeAvaliationId: FieldRef<"StoreAvaliationImages", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StoreAvaliationImages findUnique
   */
  export type StoreAvaliationImagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliationImages
     */
    select?: StoreAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliationImages
     */
    omit?: StoreAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationImagesInclude<ExtArgs> | null
    /**
     * Filter, which StoreAvaliationImages to fetch.
     */
    where: StoreAvaliationImagesWhereUniqueInput
  }

  /**
   * StoreAvaliationImages findUniqueOrThrow
   */
  export type StoreAvaliationImagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliationImages
     */
    select?: StoreAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliationImages
     */
    omit?: StoreAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationImagesInclude<ExtArgs> | null
    /**
     * Filter, which StoreAvaliationImages to fetch.
     */
    where: StoreAvaliationImagesWhereUniqueInput
  }

  /**
   * StoreAvaliationImages findFirst
   */
  export type StoreAvaliationImagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliationImages
     */
    select?: StoreAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliationImages
     */
    omit?: StoreAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationImagesInclude<ExtArgs> | null
    /**
     * Filter, which StoreAvaliationImages to fetch.
     */
    where?: StoreAvaliationImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreAvaliationImages to fetch.
     */
    orderBy?: StoreAvaliationImagesOrderByWithRelationInput | StoreAvaliationImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreAvaliationImages.
     */
    cursor?: StoreAvaliationImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreAvaliationImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreAvaliationImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreAvaliationImages.
     */
    distinct?: StoreAvaliationImagesScalarFieldEnum | StoreAvaliationImagesScalarFieldEnum[]
  }

  /**
   * StoreAvaliationImages findFirstOrThrow
   */
  export type StoreAvaliationImagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliationImages
     */
    select?: StoreAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliationImages
     */
    omit?: StoreAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationImagesInclude<ExtArgs> | null
    /**
     * Filter, which StoreAvaliationImages to fetch.
     */
    where?: StoreAvaliationImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreAvaliationImages to fetch.
     */
    orderBy?: StoreAvaliationImagesOrderByWithRelationInput | StoreAvaliationImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreAvaliationImages.
     */
    cursor?: StoreAvaliationImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreAvaliationImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreAvaliationImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreAvaliationImages.
     */
    distinct?: StoreAvaliationImagesScalarFieldEnum | StoreAvaliationImagesScalarFieldEnum[]
  }

  /**
   * StoreAvaliationImages findMany
   */
  export type StoreAvaliationImagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliationImages
     */
    select?: StoreAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliationImages
     */
    omit?: StoreAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationImagesInclude<ExtArgs> | null
    /**
     * Filter, which StoreAvaliationImages to fetch.
     */
    where?: StoreAvaliationImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreAvaliationImages to fetch.
     */
    orderBy?: StoreAvaliationImagesOrderByWithRelationInput | StoreAvaliationImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreAvaliationImages.
     */
    cursor?: StoreAvaliationImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreAvaliationImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreAvaliationImages.
     */
    skip?: number
    distinct?: StoreAvaliationImagesScalarFieldEnum | StoreAvaliationImagesScalarFieldEnum[]
  }

  /**
   * StoreAvaliationImages create
   */
  export type StoreAvaliationImagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliationImages
     */
    select?: StoreAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliationImages
     */
    omit?: StoreAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationImagesInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreAvaliationImages.
     */
    data: XOR<StoreAvaliationImagesCreateInput, StoreAvaliationImagesUncheckedCreateInput>
  }

  /**
   * StoreAvaliationImages createMany
   */
  export type StoreAvaliationImagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreAvaliationImages.
     */
    data: StoreAvaliationImagesCreateManyInput | StoreAvaliationImagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreAvaliationImages update
   */
  export type StoreAvaliationImagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliationImages
     */
    select?: StoreAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliationImages
     */
    omit?: StoreAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationImagesInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreAvaliationImages.
     */
    data: XOR<StoreAvaliationImagesUpdateInput, StoreAvaliationImagesUncheckedUpdateInput>
    /**
     * Choose, which StoreAvaliationImages to update.
     */
    where: StoreAvaliationImagesWhereUniqueInput
  }

  /**
   * StoreAvaliationImages updateMany
   */
  export type StoreAvaliationImagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreAvaliationImages.
     */
    data: XOR<StoreAvaliationImagesUpdateManyMutationInput, StoreAvaliationImagesUncheckedUpdateManyInput>
    /**
     * Filter which StoreAvaliationImages to update
     */
    where?: StoreAvaliationImagesWhereInput
    /**
     * Limit how many StoreAvaliationImages to update.
     */
    limit?: number
  }

  /**
   * StoreAvaliationImages upsert
   */
  export type StoreAvaliationImagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliationImages
     */
    select?: StoreAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliationImages
     */
    omit?: StoreAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationImagesInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreAvaliationImages to update in case it exists.
     */
    where: StoreAvaliationImagesWhereUniqueInput
    /**
     * In case the StoreAvaliationImages found by the `where` argument doesn't exist, create a new StoreAvaliationImages with this data.
     */
    create: XOR<StoreAvaliationImagesCreateInput, StoreAvaliationImagesUncheckedCreateInput>
    /**
     * In case the StoreAvaliationImages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreAvaliationImagesUpdateInput, StoreAvaliationImagesUncheckedUpdateInput>
  }

  /**
   * StoreAvaliationImages delete
   */
  export type StoreAvaliationImagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliationImages
     */
    select?: StoreAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliationImages
     */
    omit?: StoreAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationImagesInclude<ExtArgs> | null
    /**
     * Filter which StoreAvaliationImages to delete.
     */
    where: StoreAvaliationImagesWhereUniqueInput
  }

  /**
   * StoreAvaliationImages deleteMany
   */
  export type StoreAvaliationImagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreAvaliationImages to delete
     */
    where?: StoreAvaliationImagesWhereInput
    /**
     * Limit how many StoreAvaliationImages to delete.
     */
    limit?: number
  }

  /**
   * StoreAvaliationImages.storeAvaliation
   */
  export type StoreAvaliationImages$storeAvaliationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliations
     */
    select?: StoreAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliations
     */
    omit?: StoreAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationsInclude<ExtArgs> | null
    where?: StoreAvaliationsWhereInput
  }

  /**
   * StoreAvaliationImages without action
   */
  export type StoreAvaliationImagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreAvaliationImages
     */
    select?: StoreAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreAvaliationImages
     */
    omit?: StoreAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreAvaliationImagesInclude<ExtArgs> | null
  }


  /**
   * Model Coupons
   */

  export type AggregateCoupons = {
    _count: CouponsCountAggregateOutputType | null
    _avg: CouponsAvgAggregateOutputType | null
    _sum: CouponsSumAggregateOutputType | null
    _min: CouponsMinAggregateOutputType | null
    _max: CouponsMaxAggregateOutputType | null
  }

  export type CouponsAvgAggregateOutputType = {
    id: number | null
    percentageDiscount: number | null
    discountValue: Decimal | null
    storeId: number | null
  }

  export type CouponsSumAggregateOutputType = {
    id: number | null
    percentageDiscount: number | null
    discountValue: Decimal | null
    storeId: number | null
  }

  export type CouponsMinAggregateOutputType = {
    id: number | null
    code: string | null
    expirationDate: Date | null
    percentageDiscount: number | null
    discountValue: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    storeId: number | null
  }

  export type CouponsMaxAggregateOutputType = {
    id: number | null
    code: string | null
    expirationDate: Date | null
    percentageDiscount: number | null
    discountValue: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    storeId: number | null
  }

  export type CouponsCountAggregateOutputType = {
    id: number
    code: number
    expirationDate: number
    percentageDiscount: number
    discountValue: number
    createdAt: number
    updatedAt: number
    storeId: number
    _all: number
  }


  export type CouponsAvgAggregateInputType = {
    id?: true
    percentageDiscount?: true
    discountValue?: true
    storeId?: true
  }

  export type CouponsSumAggregateInputType = {
    id?: true
    percentageDiscount?: true
    discountValue?: true
    storeId?: true
  }

  export type CouponsMinAggregateInputType = {
    id?: true
    code?: true
    expirationDate?: true
    percentageDiscount?: true
    discountValue?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
  }

  export type CouponsMaxAggregateInputType = {
    id?: true
    code?: true
    expirationDate?: true
    percentageDiscount?: true
    discountValue?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
  }

  export type CouponsCountAggregateInputType = {
    id?: true
    code?: true
    expirationDate?: true
    percentageDiscount?: true
    discountValue?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
    _all?: true
  }

  export type CouponsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupons to aggregate.
     */
    where?: CouponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponsOrderByWithRelationInput | CouponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coupons
    **/
    _count?: true | CouponsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponsMaxAggregateInputType
  }

  export type GetCouponsAggregateType<T extends CouponsAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupons[P]>
      : GetScalarType<T[P], AggregateCoupons[P]>
  }




  export type CouponsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponsWhereInput
    orderBy?: CouponsOrderByWithAggregationInput | CouponsOrderByWithAggregationInput[]
    by: CouponsScalarFieldEnum[] | CouponsScalarFieldEnum
    having?: CouponsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponsCountAggregateInputType | true
    _avg?: CouponsAvgAggregateInputType
    _sum?: CouponsSumAggregateInputType
    _min?: CouponsMinAggregateInputType
    _max?: CouponsMaxAggregateInputType
  }

  export type CouponsGroupByOutputType = {
    id: number
    code: string
    expirationDate: Date
    percentageDiscount: number
    discountValue: Decimal
    createdAt: Date
    updatedAt: Date
    storeId: number
    _count: CouponsCountAggregateOutputType | null
    _avg: CouponsAvgAggregateOutputType | null
    _sum: CouponsSumAggregateOutputType | null
    _min: CouponsMinAggregateOutputType | null
    _max: CouponsMaxAggregateOutputType | null
  }

  type GetCouponsGroupByPayload<T extends CouponsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponsGroupByOutputType[P]>
            : GetScalarType<T[P], CouponsGroupByOutputType[P]>
        }
      >
    >


  export type CouponsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    expirationDate?: boolean
    percentageDiscount?: boolean
    discountValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
    store?: boolean | StoresDefaultArgs<ExtArgs>
    usedCoupons?: boolean | Coupons$usedCouponsArgs<ExtArgs>
    _count?: boolean | CouponsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupons"]>



  export type CouponsSelectScalar = {
    id?: boolean
    code?: boolean
    expirationDate?: boolean
    percentageDiscount?: boolean
    discountValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
  }

  export type CouponsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "expirationDate" | "percentageDiscount" | "discountValue" | "createdAt" | "updatedAt" | "storeId", ExtArgs["result"]["coupons"]>
  export type CouponsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoresDefaultArgs<ExtArgs>
    usedCoupons?: boolean | Coupons$usedCouponsArgs<ExtArgs>
    _count?: boolean | CouponsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CouponsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coupons"
    objects: {
      store: Prisma.$StoresPayload<ExtArgs>
      usedCoupons: Prisma.$UserUsedCouponsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      expirationDate: Date
      percentageDiscount: number
      discountValue: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
      storeId: number
    }, ExtArgs["result"]["coupons"]>
    composites: {}
  }

  type CouponsGetPayload<S extends boolean | null | undefined | CouponsDefaultArgs> = $Result.GetResult<Prisma.$CouponsPayload, S>

  type CouponsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CouponsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CouponsCountAggregateInputType | true
    }

  export interface CouponsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coupons'], meta: { name: 'Coupons' } }
    /**
     * Find zero or one Coupons that matches the filter.
     * @param {CouponsFindUniqueArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponsFindUniqueArgs>(args: SelectSubset<T, CouponsFindUniqueArgs<ExtArgs>>): Prisma__CouponsClient<$Result.GetResult<Prisma.$CouponsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coupons that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CouponsFindUniqueOrThrowArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponsFindUniqueOrThrowArgs>(args: SelectSubset<T, CouponsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouponsClient<$Result.GetResult<Prisma.$CouponsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsFindFirstArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponsFindFirstArgs>(args?: SelectSubset<T, CouponsFindFirstArgs<ExtArgs>>): Prisma__CouponsClient<$Result.GetResult<Prisma.$CouponsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupons that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsFindFirstOrThrowArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponsFindFirstOrThrowArgs>(args?: SelectSubset<T, CouponsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouponsClient<$Result.GetResult<Prisma.$CouponsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupons.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupons.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponsWithIdOnly = await prisma.coupons.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouponsFindManyArgs>(args?: SelectSubset<T, CouponsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coupons.
     * @param {CouponsCreateArgs} args - Arguments to create a Coupons.
     * @example
     * // Create one Coupons
     * const Coupons = await prisma.coupons.create({
     *   data: {
     *     // ... data to create a Coupons
     *   }
     * })
     * 
     */
    create<T extends CouponsCreateArgs>(args: SelectSubset<T, CouponsCreateArgs<ExtArgs>>): Prisma__CouponsClient<$Result.GetResult<Prisma.$CouponsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coupons.
     * @param {CouponsCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupons = await prisma.coupons.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouponsCreateManyArgs>(args?: SelectSubset<T, CouponsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Coupons.
     * @param {CouponsDeleteArgs} args - Arguments to delete one Coupons.
     * @example
     * // Delete one Coupons
     * const Coupons = await prisma.coupons.delete({
     *   where: {
     *     // ... filter to delete one Coupons
     *   }
     * })
     * 
     */
    delete<T extends CouponsDeleteArgs>(args: SelectSubset<T, CouponsDeleteArgs<ExtArgs>>): Prisma__CouponsClient<$Result.GetResult<Prisma.$CouponsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coupons.
     * @param {CouponsUpdateArgs} args - Arguments to update one Coupons.
     * @example
     * // Update one Coupons
     * const coupons = await prisma.coupons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouponsUpdateArgs>(args: SelectSubset<T, CouponsUpdateArgs<ExtArgs>>): Prisma__CouponsClient<$Result.GetResult<Prisma.$CouponsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coupons.
     * @param {CouponsDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouponsDeleteManyArgs>(args?: SelectSubset<T, CouponsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupons = await prisma.coupons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouponsUpdateManyArgs>(args: SelectSubset<T, CouponsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Coupons.
     * @param {CouponsUpsertArgs} args - Arguments to update or create a Coupons.
     * @example
     * // Update or create a Coupons
     * const coupons = await prisma.coupons.upsert({
     *   create: {
     *     // ... data to create a Coupons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupons we want to update
     *   }
     * })
     */
    upsert<T extends CouponsUpsertArgs>(args: SelectSubset<T, CouponsUpsertArgs<ExtArgs>>): Prisma__CouponsClient<$Result.GetResult<Prisma.$CouponsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupons.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends CouponsCountArgs>(
      args?: Subset<T, CouponsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponsAggregateArgs>(args: Subset<T, CouponsAggregateArgs>): Prisma.PrismaPromise<GetCouponsAggregateType<T>>

    /**
     * Group by Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponsGroupByArgs['orderBy'] }
        : { orderBy?: CouponsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coupons model
   */
  readonly fields: CouponsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usedCoupons<T extends Coupons$usedCouponsArgs<ExtArgs> = {}>(args?: Subset<T, Coupons$usedCouponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserUsedCouponsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coupons model
   */
  interface CouponsFieldRefs {
    readonly id: FieldRef<"Coupons", 'Int'>
    readonly code: FieldRef<"Coupons", 'String'>
    readonly expirationDate: FieldRef<"Coupons", 'DateTime'>
    readonly percentageDiscount: FieldRef<"Coupons", 'Int'>
    readonly discountValue: FieldRef<"Coupons", 'Decimal'>
    readonly createdAt: FieldRef<"Coupons", 'DateTime'>
    readonly updatedAt: FieldRef<"Coupons", 'DateTime'>
    readonly storeId: FieldRef<"Coupons", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Coupons findUnique
   */
  export type CouponsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupons
     */
    select?: CouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupons
     */
    omit?: CouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponsInclude<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where: CouponsWhereUniqueInput
  }

  /**
   * Coupons findUniqueOrThrow
   */
  export type CouponsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupons
     */
    select?: CouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupons
     */
    omit?: CouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponsInclude<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where: CouponsWhereUniqueInput
  }

  /**
   * Coupons findFirst
   */
  export type CouponsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupons
     */
    select?: CouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupons
     */
    omit?: CouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponsInclude<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponsOrderByWithRelationInput | CouponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponsScalarFieldEnum | CouponsScalarFieldEnum[]
  }

  /**
   * Coupons findFirstOrThrow
   */
  export type CouponsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupons
     */
    select?: CouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupons
     */
    omit?: CouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponsInclude<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponsOrderByWithRelationInput | CouponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponsScalarFieldEnum | CouponsScalarFieldEnum[]
  }

  /**
   * Coupons findMany
   */
  export type CouponsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupons
     */
    select?: CouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupons
     */
    omit?: CouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponsInclude<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponsOrderByWithRelationInput | CouponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coupons.
     */
    cursor?: CouponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    distinct?: CouponsScalarFieldEnum | CouponsScalarFieldEnum[]
  }

  /**
   * Coupons create
   */
  export type CouponsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupons
     */
    select?: CouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupons
     */
    omit?: CouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponsInclude<ExtArgs> | null
    /**
     * The data needed to create a Coupons.
     */
    data: XOR<CouponsCreateInput, CouponsUncheckedCreateInput>
  }

  /**
   * Coupons createMany
   */
  export type CouponsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coupons.
     */
    data: CouponsCreateManyInput | CouponsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupons update
   */
  export type CouponsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupons
     */
    select?: CouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupons
     */
    omit?: CouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponsInclude<ExtArgs> | null
    /**
     * The data needed to update a Coupons.
     */
    data: XOR<CouponsUpdateInput, CouponsUncheckedUpdateInput>
    /**
     * Choose, which Coupons to update.
     */
    where: CouponsWhereUniqueInput
  }

  /**
   * Coupons updateMany
   */
  export type CouponsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponsUpdateManyMutationInput, CouponsUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponsWhereInput
    /**
     * Limit how many Coupons to update.
     */
    limit?: number
  }

  /**
   * Coupons upsert
   */
  export type CouponsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupons
     */
    select?: CouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupons
     */
    omit?: CouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponsInclude<ExtArgs> | null
    /**
     * The filter to search for the Coupons to update in case it exists.
     */
    where: CouponsWhereUniqueInput
    /**
     * In case the Coupons found by the `where` argument doesn't exist, create a new Coupons with this data.
     */
    create: XOR<CouponsCreateInput, CouponsUncheckedCreateInput>
    /**
     * In case the Coupons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponsUpdateInput, CouponsUncheckedUpdateInput>
  }

  /**
   * Coupons delete
   */
  export type CouponsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupons
     */
    select?: CouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupons
     */
    omit?: CouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponsInclude<ExtArgs> | null
    /**
     * Filter which Coupons to delete.
     */
    where: CouponsWhereUniqueInput
  }

  /**
   * Coupons deleteMany
   */
  export type CouponsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupons to delete
     */
    where?: CouponsWhereInput
    /**
     * Limit how many Coupons to delete.
     */
    limit?: number
  }

  /**
   * Coupons.usedCoupons
   */
  export type Coupons$usedCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUsedCoupons
     */
    select?: UserUsedCouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUsedCoupons
     */
    omit?: UserUsedCouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUsedCouponsInclude<ExtArgs> | null
    where?: UserUsedCouponsWhereInput
    orderBy?: UserUsedCouponsOrderByWithRelationInput | UserUsedCouponsOrderByWithRelationInput[]
    cursor?: UserUsedCouponsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserUsedCouponsScalarFieldEnum | UserUsedCouponsScalarFieldEnum[]
  }

  /**
   * Coupons without action
   */
  export type CouponsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupons
     */
    select?: CouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupons
     */
    omit?: CouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponsInclude<ExtArgs> | null
  }


  /**
   * Model Products
   */

  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsAvgAggregateOutputType = {
    id: number | null
    storeId: number | null
    price: Decimal | null
  }

  export type ProductsSumAggregateOutputType = {
    id: number | null
    storeId: number | null
    price: Decimal | null
  }

  export type ProductsMinAggregateOutputType = {
    id: number | null
    storeId: number | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    price: Decimal | null
  }

  export type ProductsMaxAggregateOutputType = {
    id: number | null
    storeId: number | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    price: Decimal | null
  }

  export type ProductsCountAggregateOutputType = {
    id: number
    storeId: number
    created_at: number
    updated_at: number
    name: number
    price: number
    _all: number
  }


  export type ProductsAvgAggregateInputType = {
    id?: true
    storeId?: true
    price?: true
  }

  export type ProductsSumAggregateInputType = {
    id?: true
    storeId?: true
    price?: true
  }

  export type ProductsMinAggregateInputType = {
    id?: true
    storeId?: true
    created_at?: true
    updated_at?: true
    name?: true
    price?: true
  }

  export type ProductsMaxAggregateInputType = {
    id?: true
    storeId?: true
    created_at?: true
    updated_at?: true
    name?: true
    price?: true
  }

  export type ProductsCountAggregateInputType = {
    id?: true
    storeId?: true
    created_at?: true
    updated_at?: true
    name?: true
    price?: true
    _all?: true
  }

  export type ProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to aggregate.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }




  export type ProductsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductsWhereInput
    orderBy?: ProductsOrderByWithAggregationInput | ProductsOrderByWithAggregationInput[]
    by: ProductsScalarFieldEnum[] | ProductsScalarFieldEnum
    having?: ProductsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsCountAggregateInputType | true
    _avg?: ProductsAvgAggregateInputType
    _sum?: ProductsSumAggregateInputType
    _min?: ProductsMinAggregateInputType
    _max?: ProductsMaxAggregateInputType
  }

  export type ProductsGroupByOutputType = {
    id: number
    storeId: number
    created_at: Date
    updated_at: Date
    name: string
    price: Decimal
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  type GetProductsGroupByPayload<T extends ProductsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
        }
      >
    >


  export type ProductsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    price?: boolean
    store?: boolean | StoresDefaultArgs<ExtArgs>
    inventory?: boolean | Products$inventoryArgs<ExtArgs>
    images?: boolean | Products$imagesArgs<ExtArgs>
    category?: boolean | Products$categoryArgs<ExtArgs>
    avaliations?: boolean | Products$avaliationsArgs<ExtArgs>
    promotions?: boolean | Products$promotionsArgs<ExtArgs>
    cartItem?: boolean | Products$cartItemArgs<ExtArgs>
    orderItems?: boolean | Products$orderItemsArgs<ExtArgs>
    wishlists?: boolean | Products$wishlistsArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>



  export type ProductsSelectScalar = {
    id?: boolean
    storeId?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    price?: boolean
  }

  export type ProductsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storeId" | "created_at" | "updated_at" | "name" | "price", ExtArgs["result"]["products"]>
  export type ProductsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoresDefaultArgs<ExtArgs>
    inventory?: boolean | Products$inventoryArgs<ExtArgs>
    images?: boolean | Products$imagesArgs<ExtArgs>
    category?: boolean | Products$categoryArgs<ExtArgs>
    avaliations?: boolean | Products$avaliationsArgs<ExtArgs>
    promotions?: boolean | Products$promotionsArgs<ExtArgs>
    cartItem?: boolean | Products$cartItemArgs<ExtArgs>
    orderItems?: boolean | Products$orderItemsArgs<ExtArgs>
    wishlists?: boolean | Products$wishlistsArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Products"
    objects: {
      store: Prisma.$StoresPayload<ExtArgs>
      inventory: Prisma.$InventoryPayload<ExtArgs> | null
      images: Prisma.$ProductImagesPayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs>[]
      avaliations: Prisma.$ProductAvaliationsPayload<ExtArgs>[]
      promotions: Prisma.$PromotionPayload<ExtArgs>[]
      cartItem: Prisma.$CartItemsPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemsPayload<ExtArgs>[]
      wishlists: Prisma.$WishlistPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      storeId: number
      created_at: Date
      updated_at: Date
      name: string
      price: Prisma.Decimal
    }, ExtArgs["result"]["products"]>
    composites: {}
  }

  type ProductsGetPayload<S extends boolean | null | undefined | ProductsDefaultArgs> = $Result.GetResult<Prisma.$ProductsPayload, S>

  type ProductsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductsCountAggregateInputType | true
    }

  export interface ProductsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Products'], meta: { name: 'Products' } }
    /**
     * Find zero or one Products that matches the filter.
     * @param {ProductsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductsFindUniqueArgs>(args: SelectSubset<T, ProductsFindUniqueArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Products that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductsFindFirstArgs>(args?: SelectSubset<T, ProductsFindFirstArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsWithIdOnly = await prisma.products.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductsFindManyArgs>(args?: SelectSubset<T, ProductsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Products.
     * @param {ProductsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
     */
    create<T extends ProductsCreateArgs>(args: SelectSubset<T, ProductsCreateArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductsCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductsCreateManyArgs>(args?: SelectSubset<T, ProductsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Products.
     * @param {ProductsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
     */
    delete<T extends ProductsDeleteArgs>(args: SelectSubset<T, ProductsDeleteArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Products.
     * @param {ProductsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductsUpdateArgs>(args: SelectSubset<T, ProductsUpdateArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductsDeleteManyArgs>(args?: SelectSubset<T, ProductsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductsUpdateManyArgs>(args: SelectSubset<T, ProductsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Products.
     * @param {ProductsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
     */
    upsert<T extends ProductsUpsertArgs>(args: SelectSubset<T, ProductsUpsertArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductsCountArgs>(
      args?: Subset<T, ProductsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): Prisma.PrismaPromise<GetProductsAggregateType<T>>

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductsGroupByArgs['orderBy'] }
        : { orderBy?: ProductsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Products model
   */
  readonly fields: ProductsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inventory<T extends Products$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Products$inventoryArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    images<T extends Products$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Products$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends Products$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Products$categoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    avaliations<T extends Products$avaliationsArgs<ExtArgs> = {}>(args?: Subset<T, Products$avaliationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductAvaliationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promotions<T extends Products$promotionsArgs<ExtArgs> = {}>(args?: Subset<T, Products$promotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cartItem<T extends Products$cartItemArgs<ExtArgs> = {}>(args?: Subset<T, Products$cartItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends Products$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Products$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wishlists<T extends Products$wishlistsArgs<ExtArgs> = {}>(args?: Subset<T, Products$wishlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Products model
   */
  interface ProductsFieldRefs {
    readonly id: FieldRef<"Products", 'Int'>
    readonly storeId: FieldRef<"Products", 'Int'>
    readonly created_at: FieldRef<"Products", 'DateTime'>
    readonly updated_at: FieldRef<"Products", 'DateTime'>
    readonly name: FieldRef<"Products", 'String'>
    readonly price: FieldRef<"Products", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Products findUnique
   */
  export type ProductsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products findUniqueOrThrow
   */
  export type ProductsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products findFirst
   */
  export type ProductsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products findFirstOrThrow
   */
  export type ProductsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products findMany
   */
  export type ProductsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products create
   */
  export type ProductsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The data needed to create a Products.
     */
    data: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
  }

  /**
   * Products createMany
   */
  export type ProductsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductsCreateManyInput | ProductsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Products update
   */
  export type ProductsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The data needed to update a Products.
     */
    data: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
    /**
     * Choose, which Products to update.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products updateMany
   */
  export type ProductsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductsWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Products upsert
   */
  export type ProductsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The filter to search for the Products to update in case it exists.
     */
    where: ProductsWhereUniqueInput
    /**
     * In case the Products found by the `where` argument doesn't exist, create a new Products with this data.
     */
    create: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
    /**
     * In case the Products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
  }

  /**
   * Products delete
   */
  export type ProductsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter which Products to delete.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products deleteMany
   */
  export type ProductsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductsWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Products.inventory
   */
  export type Products$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
  }

  /**
   * Products.images
   */
  export type Products$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImages
     */
    omit?: ProductImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImagesInclude<ExtArgs> | null
    where?: ProductImagesWhereInput
    orderBy?: ProductImagesOrderByWithRelationInput | ProductImagesOrderByWithRelationInput[]
    cursor?: ProductImagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductImagesScalarFieldEnum | ProductImagesScalarFieldEnum[]
  }

  /**
   * Products.category
   */
  export type Products$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Products.avaliations
   */
  export type Products$avaliationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliations
     */
    select?: ProductAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliations
     */
    omit?: ProductAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationsInclude<ExtArgs> | null
    where?: ProductAvaliationsWhereInput
    orderBy?: ProductAvaliationsOrderByWithRelationInput | ProductAvaliationsOrderByWithRelationInput[]
    cursor?: ProductAvaliationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductAvaliationsScalarFieldEnum | ProductAvaliationsScalarFieldEnum[]
  }

  /**
   * Products.promotions
   */
  export type Products$promotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    cursor?: PromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Products.cartItem
   */
  export type Products$cartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItems
     */
    select?: CartItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItems
     */
    omit?: CartItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemsInclude<ExtArgs> | null
    where?: CartItemsWhereInput
    orderBy?: CartItemsOrderByWithRelationInput | CartItemsOrderByWithRelationInput[]
    cursor?: CartItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemsScalarFieldEnum | CartItemsScalarFieldEnum[]
  }

  /**
   * Products.orderItems
   */
  export type Products$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    where?: OrderItemsWhereInput
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    cursor?: OrderItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemsScalarFieldEnum | OrderItemsScalarFieldEnum[]
  }

  /**
   * Products.wishlists
   */
  export type Products$wishlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    where?: WishlistWhereInput
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    cursor?: WishlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * Products without action
   */
  export type ProductsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
  }


  /**
   * Model ProductImages
   */

  export type AggregateProductImages = {
    _count: ProductImagesCountAggregateOutputType | null
    _avg: ProductImagesAvgAggregateOutputType | null
    _sum: ProductImagesSumAggregateOutputType | null
    _min: ProductImagesMinAggregateOutputType | null
    _max: ProductImagesMaxAggregateOutputType | null
  }

  export type ProductImagesAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductImagesSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductImagesMinAggregateOutputType = {
    id: number | null
    url: string | null
    publicId: string | null
    productId: number | null
  }

  export type ProductImagesMaxAggregateOutputType = {
    id: number | null
    url: string | null
    publicId: string | null
    productId: number | null
  }

  export type ProductImagesCountAggregateOutputType = {
    id: number
    url: number
    publicId: number
    productId: number
    _all: number
  }


  export type ProductImagesAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductImagesSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductImagesMinAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
    productId?: true
  }

  export type ProductImagesMaxAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
    productId?: true
  }

  export type ProductImagesCountAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
    productId?: true
    _all?: true
  }

  export type ProductImagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImages to aggregate.
     */
    where?: ProductImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImagesOrderByWithRelationInput | ProductImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductImages
    **/
    _count?: true | ProductImagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductImagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductImagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductImagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductImagesMaxAggregateInputType
  }

  export type GetProductImagesAggregateType<T extends ProductImagesAggregateArgs> = {
        [P in keyof T & keyof AggregateProductImages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductImages[P]>
      : GetScalarType<T[P], AggregateProductImages[P]>
  }




  export type ProductImagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImagesWhereInput
    orderBy?: ProductImagesOrderByWithAggregationInput | ProductImagesOrderByWithAggregationInput[]
    by: ProductImagesScalarFieldEnum[] | ProductImagesScalarFieldEnum
    having?: ProductImagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductImagesCountAggregateInputType | true
    _avg?: ProductImagesAvgAggregateInputType
    _sum?: ProductImagesSumAggregateInputType
    _min?: ProductImagesMinAggregateInputType
    _max?: ProductImagesMaxAggregateInputType
  }

  export type ProductImagesGroupByOutputType = {
    id: number
    url: string
    publicId: string
    productId: number | null
    _count: ProductImagesCountAggregateOutputType | null
    _avg: ProductImagesAvgAggregateOutputType | null
    _sum: ProductImagesSumAggregateOutputType | null
    _min: ProductImagesMinAggregateOutputType | null
    _max: ProductImagesMaxAggregateOutputType | null
  }

  type GetProductImagesGroupByPayload<T extends ProductImagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductImagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductImagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductImagesGroupByOutputType[P]>
            : GetScalarType<T[P], ProductImagesGroupByOutputType[P]>
        }
      >
    >


  export type ProductImagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    publicId?: boolean
    productId?: boolean
    product?: boolean | ProductImages$productArgs<ExtArgs>
  }, ExtArgs["result"]["productImages"]>



  export type ProductImagesSelectScalar = {
    id?: boolean
    url?: boolean
    publicId?: boolean
    productId?: boolean
  }

  export type ProductImagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "publicId" | "productId", ExtArgs["result"]["productImages"]>
  export type ProductImagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductImages$productArgs<ExtArgs>
  }

  export type $ProductImagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductImages"
    objects: {
      product: Prisma.$ProductsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      publicId: string
      productId: number | null
    }, ExtArgs["result"]["productImages"]>
    composites: {}
  }

  type ProductImagesGetPayload<S extends boolean | null | undefined | ProductImagesDefaultArgs> = $Result.GetResult<Prisma.$ProductImagesPayload, S>

  type ProductImagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductImagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductImagesCountAggregateInputType | true
    }

  export interface ProductImagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductImages'], meta: { name: 'ProductImages' } }
    /**
     * Find zero or one ProductImages that matches the filter.
     * @param {ProductImagesFindUniqueArgs} args - Arguments to find a ProductImages
     * @example
     * // Get one ProductImages
     * const productImages = await prisma.productImages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductImagesFindUniqueArgs>(args: SelectSubset<T, ProductImagesFindUniqueArgs<ExtArgs>>): Prisma__ProductImagesClient<$Result.GetResult<Prisma.$ProductImagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductImages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductImagesFindUniqueOrThrowArgs} args - Arguments to find a ProductImages
     * @example
     * // Get one ProductImages
     * const productImages = await prisma.productImages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductImagesFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductImagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductImagesClient<$Result.GetResult<Prisma.$ProductImagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImagesFindFirstArgs} args - Arguments to find a ProductImages
     * @example
     * // Get one ProductImages
     * const productImages = await prisma.productImages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductImagesFindFirstArgs>(args?: SelectSubset<T, ProductImagesFindFirstArgs<ExtArgs>>): Prisma__ProductImagesClient<$Result.GetResult<Prisma.$ProductImagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductImages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImagesFindFirstOrThrowArgs} args - Arguments to find a ProductImages
     * @example
     * // Get one ProductImages
     * const productImages = await prisma.productImages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductImagesFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductImagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductImagesClient<$Result.GetResult<Prisma.$ProductImagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductImages
     * const productImages = await prisma.productImages.findMany()
     * 
     * // Get first 10 ProductImages
     * const productImages = await prisma.productImages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productImagesWithIdOnly = await prisma.productImages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductImagesFindManyArgs>(args?: SelectSubset<T, ProductImagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductImages.
     * @param {ProductImagesCreateArgs} args - Arguments to create a ProductImages.
     * @example
     * // Create one ProductImages
     * const ProductImages = await prisma.productImages.create({
     *   data: {
     *     // ... data to create a ProductImages
     *   }
     * })
     * 
     */
    create<T extends ProductImagesCreateArgs>(args: SelectSubset<T, ProductImagesCreateArgs<ExtArgs>>): Prisma__ProductImagesClient<$Result.GetResult<Prisma.$ProductImagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductImages.
     * @param {ProductImagesCreateManyArgs} args - Arguments to create many ProductImages.
     * @example
     * // Create many ProductImages
     * const productImages = await prisma.productImages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductImagesCreateManyArgs>(args?: SelectSubset<T, ProductImagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductImages.
     * @param {ProductImagesDeleteArgs} args - Arguments to delete one ProductImages.
     * @example
     * // Delete one ProductImages
     * const ProductImages = await prisma.productImages.delete({
     *   where: {
     *     // ... filter to delete one ProductImages
     *   }
     * })
     * 
     */
    delete<T extends ProductImagesDeleteArgs>(args: SelectSubset<T, ProductImagesDeleteArgs<ExtArgs>>): Prisma__ProductImagesClient<$Result.GetResult<Prisma.$ProductImagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductImages.
     * @param {ProductImagesUpdateArgs} args - Arguments to update one ProductImages.
     * @example
     * // Update one ProductImages
     * const productImages = await prisma.productImages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductImagesUpdateArgs>(args: SelectSubset<T, ProductImagesUpdateArgs<ExtArgs>>): Prisma__ProductImagesClient<$Result.GetResult<Prisma.$ProductImagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductImages.
     * @param {ProductImagesDeleteManyArgs} args - Arguments to filter ProductImages to delete.
     * @example
     * // Delete a few ProductImages
     * const { count } = await prisma.productImages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductImagesDeleteManyArgs>(args?: SelectSubset<T, ProductImagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductImages
     * const productImages = await prisma.productImages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductImagesUpdateManyArgs>(args: SelectSubset<T, ProductImagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductImages.
     * @param {ProductImagesUpsertArgs} args - Arguments to update or create a ProductImages.
     * @example
     * // Update or create a ProductImages
     * const productImages = await prisma.productImages.upsert({
     *   create: {
     *     // ... data to create a ProductImages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductImages we want to update
     *   }
     * })
     */
    upsert<T extends ProductImagesUpsertArgs>(args: SelectSubset<T, ProductImagesUpsertArgs<ExtArgs>>): Prisma__ProductImagesClient<$Result.GetResult<Prisma.$ProductImagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImagesCountArgs} args - Arguments to filter ProductImages to count.
     * @example
     * // Count the number of ProductImages
     * const count = await prisma.productImages.count({
     *   where: {
     *     // ... the filter for the ProductImages we want to count
     *   }
     * })
    **/
    count<T extends ProductImagesCountArgs>(
      args?: Subset<T, ProductImagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductImagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductImagesAggregateArgs>(args: Subset<T, ProductImagesAggregateArgs>): Prisma.PrismaPromise<GetProductImagesAggregateType<T>>

    /**
     * Group by ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductImagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductImagesGroupByArgs['orderBy'] }
        : { orderBy?: ProductImagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductImagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductImagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductImages model
   */
  readonly fields: ProductImagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductImages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductImagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductImages$productArgs<ExtArgs> = {}>(args?: Subset<T, ProductImages$productArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductImages model
   */
  interface ProductImagesFieldRefs {
    readonly id: FieldRef<"ProductImages", 'Int'>
    readonly url: FieldRef<"ProductImages", 'String'>
    readonly publicId: FieldRef<"ProductImages", 'String'>
    readonly productId: FieldRef<"ProductImages", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductImages findUnique
   */
  export type ProductImagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImages
     */
    omit?: ProductImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where: ProductImagesWhereUniqueInput
  }

  /**
   * ProductImages findUniqueOrThrow
   */
  export type ProductImagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImages
     */
    omit?: ProductImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where: ProductImagesWhereUniqueInput
  }

  /**
   * ProductImages findFirst
   */
  export type ProductImagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImages
     */
    omit?: ProductImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where?: ProductImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImagesOrderByWithRelationInput | ProductImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImagesScalarFieldEnum | ProductImagesScalarFieldEnum[]
  }

  /**
   * ProductImages findFirstOrThrow
   */
  export type ProductImagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImages
     */
    omit?: ProductImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where?: ProductImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImagesOrderByWithRelationInput | ProductImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImagesScalarFieldEnum | ProductImagesScalarFieldEnum[]
  }

  /**
   * ProductImages findMany
   */
  export type ProductImagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImages
     */
    omit?: ProductImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where?: ProductImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImagesOrderByWithRelationInput | ProductImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductImages.
     */
    cursor?: ProductImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    distinct?: ProductImagesScalarFieldEnum | ProductImagesScalarFieldEnum[]
  }

  /**
   * ProductImages create
   */
  export type ProductImagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImages
     */
    omit?: ProductImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductImages.
     */
    data: XOR<ProductImagesCreateInput, ProductImagesUncheckedCreateInput>
  }

  /**
   * ProductImages createMany
   */
  export type ProductImagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductImages.
     */
    data: ProductImagesCreateManyInput | ProductImagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductImages update
   */
  export type ProductImagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImages
     */
    omit?: ProductImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductImages.
     */
    data: XOR<ProductImagesUpdateInput, ProductImagesUncheckedUpdateInput>
    /**
     * Choose, which ProductImages to update.
     */
    where: ProductImagesWhereUniqueInput
  }

  /**
   * ProductImages updateMany
   */
  export type ProductImagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductImages.
     */
    data: XOR<ProductImagesUpdateManyMutationInput, ProductImagesUncheckedUpdateManyInput>
    /**
     * Filter which ProductImages to update
     */
    where?: ProductImagesWhereInput
    /**
     * Limit how many ProductImages to update.
     */
    limit?: number
  }

  /**
   * ProductImages upsert
   */
  export type ProductImagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImages
     */
    omit?: ProductImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductImages to update in case it exists.
     */
    where: ProductImagesWhereUniqueInput
    /**
     * In case the ProductImages found by the `where` argument doesn't exist, create a new ProductImages with this data.
     */
    create: XOR<ProductImagesCreateInput, ProductImagesUncheckedCreateInput>
    /**
     * In case the ProductImages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductImagesUpdateInput, ProductImagesUncheckedUpdateInput>
  }

  /**
   * ProductImages delete
   */
  export type ProductImagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImages
     */
    omit?: ProductImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * Filter which ProductImages to delete.
     */
    where: ProductImagesWhereUniqueInput
  }

  /**
   * ProductImages deleteMany
   */
  export type ProductImagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImages to delete
     */
    where?: ProductImagesWhereInput
    /**
     * Limit how many ProductImages to delete.
     */
    limit?: number
  }

  /**
   * ProductImages.product
   */
  export type ProductImages$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
  }

  /**
   * ProductImages without action
   */
  export type ProductImagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImages
     */
    omit?: ProductImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImagesInclude<ExtArgs> | null
  }


  /**
   * Model Wishlist
   */

  export type AggregateWishlist = {
    _count: WishlistCountAggregateOutputType | null
    _avg: WishlistAvgAggregateOutputType | null
    _sum: WishlistSumAggregateOutputType | null
    _min: WishlistMinAggregateOutputType | null
    _max: WishlistMaxAggregateOutputType | null
  }

  export type WishlistAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type WishlistSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type WishlistMinAggregateOutputType = {
    id: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WishlistMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WishlistCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WishlistAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type WishlistSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type WishlistMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WishlistMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WishlistCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WishlistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wishlist to aggregate.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wishlists
    **/
    _count?: true | WishlistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WishlistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WishlistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WishlistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WishlistMaxAggregateInputType
  }

  export type GetWishlistAggregateType<T extends WishlistAggregateArgs> = {
        [P in keyof T & keyof AggregateWishlist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlist[P]>
      : GetScalarType<T[P], AggregateWishlist[P]>
  }




  export type WishlistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistWhereInput
    orderBy?: WishlistOrderByWithAggregationInput | WishlistOrderByWithAggregationInput[]
    by: WishlistScalarFieldEnum[] | WishlistScalarFieldEnum
    having?: WishlistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WishlistCountAggregateInputType | true
    _avg?: WishlistAvgAggregateInputType
    _sum?: WishlistSumAggregateInputType
    _min?: WishlistMinAggregateInputType
    _max?: WishlistMaxAggregateInputType
  }

  export type WishlistGroupByOutputType = {
    id: number
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: WishlistCountAggregateOutputType | null
    _avg: WishlistAvgAggregateOutputType | null
    _sum: WishlistSumAggregateOutputType | null
    _min: WishlistMinAggregateOutputType | null
    _max: WishlistMaxAggregateOutputType | null
  }

  type GetWishlistGroupByPayload<T extends WishlistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WishlistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WishlistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishlistGroupByOutputType[P]>
            : GetScalarType<T[P], WishlistGroupByOutputType[P]>
        }
      >
    >


  export type WishlistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    products?: boolean | Wishlist$productsArgs<ExtArgs>
    _count?: boolean | WishlistCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlist"]>



  export type WishlistSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WishlistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["wishlist"]>
  export type WishlistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    products?: boolean | Wishlist$productsArgs<ExtArgs>
    _count?: boolean | WishlistCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WishlistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wishlist"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      products: Prisma.$ProductsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wishlist"]>
    composites: {}
  }

  type WishlistGetPayload<S extends boolean | null | undefined | WishlistDefaultArgs> = $Result.GetResult<Prisma.$WishlistPayload, S>

  type WishlistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WishlistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WishlistCountAggregateInputType | true
    }

  export interface WishlistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wishlist'], meta: { name: 'Wishlist' } }
    /**
     * Find zero or one Wishlist that matches the filter.
     * @param {WishlistFindUniqueArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WishlistFindUniqueArgs>(args: SelectSubset<T, WishlistFindUniqueArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wishlist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WishlistFindUniqueOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WishlistFindUniqueOrThrowArgs>(args: SelectSubset<T, WishlistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wishlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindFirstArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WishlistFindFirstArgs>(args?: SelectSubset<T, WishlistFindFirstArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wishlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindFirstOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WishlistFindFirstOrThrowArgs>(args?: SelectSubset<T, WishlistFindFirstOrThrowArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wishlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wishlists
     * const wishlists = await prisma.wishlist.findMany()
     * 
     * // Get first 10 Wishlists
     * const wishlists = await prisma.wishlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wishlistWithIdOnly = await prisma.wishlist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WishlistFindManyArgs>(args?: SelectSubset<T, WishlistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wishlist.
     * @param {WishlistCreateArgs} args - Arguments to create a Wishlist.
     * @example
     * // Create one Wishlist
     * const Wishlist = await prisma.wishlist.create({
     *   data: {
     *     // ... data to create a Wishlist
     *   }
     * })
     * 
     */
    create<T extends WishlistCreateArgs>(args: SelectSubset<T, WishlistCreateArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wishlists.
     * @param {WishlistCreateManyArgs} args - Arguments to create many Wishlists.
     * @example
     * // Create many Wishlists
     * const wishlist = await prisma.wishlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WishlistCreateManyArgs>(args?: SelectSubset<T, WishlistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wishlist.
     * @param {WishlistDeleteArgs} args - Arguments to delete one Wishlist.
     * @example
     * // Delete one Wishlist
     * const Wishlist = await prisma.wishlist.delete({
     *   where: {
     *     // ... filter to delete one Wishlist
     *   }
     * })
     * 
     */
    delete<T extends WishlistDeleteArgs>(args: SelectSubset<T, WishlistDeleteArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wishlist.
     * @param {WishlistUpdateArgs} args - Arguments to update one Wishlist.
     * @example
     * // Update one Wishlist
     * const wishlist = await prisma.wishlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WishlistUpdateArgs>(args: SelectSubset<T, WishlistUpdateArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wishlists.
     * @param {WishlistDeleteManyArgs} args - Arguments to filter Wishlists to delete.
     * @example
     * // Delete a few Wishlists
     * const { count } = await prisma.wishlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WishlistDeleteManyArgs>(args?: SelectSubset<T, WishlistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wishlists
     * const wishlist = await prisma.wishlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WishlistUpdateManyArgs>(args: SelectSubset<T, WishlistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wishlist.
     * @param {WishlistUpsertArgs} args - Arguments to update or create a Wishlist.
     * @example
     * // Update or create a Wishlist
     * const wishlist = await prisma.wishlist.upsert({
     *   create: {
     *     // ... data to create a Wishlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wishlist we want to update
     *   }
     * })
     */
    upsert<T extends WishlistUpsertArgs>(args: SelectSubset<T, WishlistUpsertArgs<ExtArgs>>): Prisma__WishlistClient<$Result.GetResult<Prisma.$WishlistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistCountArgs} args - Arguments to filter Wishlists to count.
     * @example
     * // Count the number of Wishlists
     * const count = await prisma.wishlist.count({
     *   where: {
     *     // ... the filter for the Wishlists we want to count
     *   }
     * })
    **/
    count<T extends WishlistCountArgs>(
      args?: Subset<T, WishlistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishlistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WishlistAggregateArgs>(args: Subset<T, WishlistAggregateArgs>): Prisma.PrismaPromise<GetWishlistAggregateType<T>>

    /**
     * Group by Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WishlistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistGroupByArgs['orderBy'] }
        : { orderBy?: WishlistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WishlistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWishlistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wishlist model
   */
  readonly fields: WishlistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wishlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WishlistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    products<T extends Wishlist$productsArgs<ExtArgs> = {}>(args?: Subset<T, Wishlist$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wishlist model
   */
  interface WishlistFieldRefs {
    readonly id: FieldRef<"Wishlist", 'Int'>
    readonly userId: FieldRef<"Wishlist", 'Int'>
    readonly createdAt: FieldRef<"Wishlist", 'DateTime'>
    readonly updatedAt: FieldRef<"Wishlist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wishlist findUnique
   */
  export type WishlistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where: WishlistWhereUniqueInput
  }

  /**
   * Wishlist findUniqueOrThrow
   */
  export type WishlistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where: WishlistWhereUniqueInput
  }

  /**
   * Wishlist findFirst
   */
  export type WishlistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wishlists.
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wishlists.
     */
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * Wishlist findFirstOrThrow
   */
  export type WishlistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wishlists.
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wishlists.
     */
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * Wishlist findMany
   */
  export type WishlistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlists to fetch.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: WishlistOrderByWithRelationInput | WishlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wishlists.
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    distinct?: WishlistScalarFieldEnum | WishlistScalarFieldEnum[]
  }

  /**
   * Wishlist create
   */
  export type WishlistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * The data needed to create a Wishlist.
     */
    data: XOR<WishlistCreateInput, WishlistUncheckedCreateInput>
  }

  /**
   * Wishlist createMany
   */
  export type WishlistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wishlists.
     */
    data: WishlistCreateManyInput | WishlistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wishlist update
   */
  export type WishlistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * The data needed to update a Wishlist.
     */
    data: XOR<WishlistUpdateInput, WishlistUncheckedUpdateInput>
    /**
     * Choose, which Wishlist to update.
     */
    where: WishlistWhereUniqueInput
  }

  /**
   * Wishlist updateMany
   */
  export type WishlistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wishlists.
     */
    data: XOR<WishlistUpdateManyMutationInput, WishlistUncheckedUpdateManyInput>
    /**
     * Filter which Wishlists to update
     */
    where?: WishlistWhereInput
    /**
     * Limit how many Wishlists to update.
     */
    limit?: number
  }

  /**
   * Wishlist upsert
   */
  export type WishlistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * The filter to search for the Wishlist to update in case it exists.
     */
    where: WishlistWhereUniqueInput
    /**
     * In case the Wishlist found by the `where` argument doesn't exist, create a new Wishlist with this data.
     */
    create: XOR<WishlistCreateInput, WishlistUncheckedCreateInput>
    /**
     * In case the Wishlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WishlistUpdateInput, WishlistUncheckedUpdateInput>
  }

  /**
   * Wishlist delete
   */
  export type WishlistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter which Wishlist to delete.
     */
    where: WishlistWhereUniqueInput
  }

  /**
   * Wishlist deleteMany
   */
  export type WishlistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wishlists to delete
     */
    where?: WishlistWhereInput
    /**
     * Limit how many Wishlists to delete.
     */
    limit?: number
  }

  /**
   * Wishlist.products
   */
  export type Wishlist$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    cursor?: ProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Wishlist without action
   */
  export type WishlistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wishlist
     */
    omit?: WishlistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistInclude<ExtArgs> | null
  }


  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
  }

  export type InventorySumAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    productId: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
  }

  export type InventorySumAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: number
    productId: number
    quantity: number
    createdAt: Date
    updatedAt: Date
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>



  export type InventorySelectScalar = {
    id?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "quantity" | "createdAt" | "updatedAt", ExtArgs["result"]["inventory"]>
  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductsDefaultArgs<ExtArgs>
  }

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      product: Prisma.$ProductsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      quantity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductsDefaultArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'Int'>
    readonly productId: FieldRef<"Inventory", 'Int'>
    readonly quantity: FieldRef<"Inventory", 'Int'>
    readonly createdAt: FieldRef<"Inventory", 'DateTime'>
    readonly updatedAt: FieldRef<"Inventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to delete.
     */
    limit?: number
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Model Promotion
   */

  export type AggregatePromotion = {
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  export type PromotionAvgAggregateOutputType = {
    id: number | null
    discountValue: Decimal | null
    storeId: number | null
  }

  export type PromotionSumAggregateOutputType = {
    id: number | null
    discountValue: Decimal | null
    storeId: number | null
  }

  export type PromotionMinAggregateOutputType = {
    id: number | null
    code: string | null
    description: string | null
    discountType: string | null
    discountValue: Decimal | null
    startDate: Date | null
    endDate: Date | null
    storeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionMaxAggregateOutputType = {
    id: number | null
    code: string | null
    description: string | null
    discountType: string | null
    discountValue: Decimal | null
    startDate: Date | null
    endDate: Date | null
    storeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionCountAggregateOutputType = {
    id: number
    code: number
    description: number
    discountType: number
    discountValue: number
    startDate: number
    endDate: number
    storeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromotionAvgAggregateInputType = {
    id?: true
    discountValue?: true
    storeId?: true
  }

  export type PromotionSumAggregateInputType = {
    id?: true
    discountValue?: true
    storeId?: true
  }

  export type PromotionMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    startDate?: true
    endDate?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    startDate?: true
    endDate?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    startDate?: true
    endDate?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotion to aggregate.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promotions
    **/
    _count?: true | PromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionMaxAggregateInputType
  }

  export type GetPromotionAggregateType<T extends PromotionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotion[P]>
      : GetScalarType<T[P], AggregatePromotion[P]>
  }




  export type PromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithAggregationInput | PromotionOrderByWithAggregationInput[]
    by: PromotionScalarFieldEnum[] | PromotionScalarFieldEnum
    having?: PromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionCountAggregateInputType | true
    _avg?: PromotionAvgAggregateInputType
    _sum?: PromotionSumAggregateInputType
    _min?: PromotionMinAggregateInputType
    _max?: PromotionMaxAggregateInputType
  }

  export type PromotionGroupByOutputType = {
    id: number
    code: string
    description: string
    discountType: string
    discountValue: Decimal
    startDate: Date
    endDate: Date
    storeId: number
    createdAt: Date
    updatedAt: Date
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  type GetPromotionGroupByPayload<T extends PromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    startDate?: boolean
    endDate?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoresDefaultArgs<ExtArgs>
    products?: boolean | Promotion$productsArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotion"]>



  export type PromotionSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    startDate?: boolean
    endDate?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromotionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "discountType" | "discountValue" | "startDate" | "endDate" | "storeId" | "createdAt" | "updatedAt", ExtArgs["result"]["promotion"]>
  export type PromotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoresDefaultArgs<ExtArgs>
    products?: boolean | Promotion$productsArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Promotion"
    objects: {
      store: Prisma.$StoresPayload<ExtArgs>
      products: Prisma.$ProductsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      description: string
      discountType: string
      discountValue: Prisma.Decimal
      startDate: Date
      endDate: Date
      storeId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["promotion"]>
    composites: {}
  }

  type PromotionGetPayload<S extends boolean | null | undefined | PromotionDefaultArgs> = $Result.GetResult<Prisma.$PromotionPayload, S>

  type PromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromotionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromotionCountAggregateInputType | true
    }

  export interface PromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promotion'], meta: { name: 'Promotion' } }
    /**
     * Find zero or one Promotion that matches the filter.
     * @param {PromotionFindUniqueArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionFindUniqueArgs>(args: SelectSubset<T, PromotionFindUniqueArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Promotion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromotionFindUniqueOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionFindFirstArgs>(args?: SelectSubset<T, PromotionFindFirstArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotions
     * const promotions = await prisma.promotion.findMany()
     * 
     * // Get first 10 Promotions
     * const promotions = await prisma.promotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionWithIdOnly = await prisma.promotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionFindManyArgs>(args?: SelectSubset<T, PromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Promotion.
     * @param {PromotionCreateArgs} args - Arguments to create a Promotion.
     * @example
     * // Create one Promotion
     * const Promotion = await prisma.promotion.create({
     *   data: {
     *     // ... data to create a Promotion
     *   }
     * })
     * 
     */
    create<T extends PromotionCreateArgs>(args: SelectSubset<T, PromotionCreateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Promotions.
     * @param {PromotionCreateManyArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionCreateManyArgs>(args?: SelectSubset<T, PromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Promotion.
     * @param {PromotionDeleteArgs} args - Arguments to delete one Promotion.
     * @example
     * // Delete one Promotion
     * const Promotion = await prisma.promotion.delete({
     *   where: {
     *     // ... filter to delete one Promotion
     *   }
     * })
     * 
     */
    delete<T extends PromotionDeleteArgs>(args: SelectSubset<T, PromotionDeleteArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Promotion.
     * @param {PromotionUpdateArgs} args - Arguments to update one Promotion.
     * @example
     * // Update one Promotion
     * const promotion = await prisma.promotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionUpdateArgs>(args: SelectSubset<T, PromotionUpdateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Promotions.
     * @param {PromotionDeleteManyArgs} args - Arguments to filter Promotions to delete.
     * @example
     * // Delete a few Promotions
     * const { count } = await prisma.promotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionDeleteManyArgs>(args?: SelectSubset<T, PromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionUpdateManyArgs>(args: SelectSubset<T, PromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Promotion.
     * @param {PromotionUpsertArgs} args - Arguments to update or create a Promotion.
     * @example
     * // Update or create a Promotion
     * const promotion = await prisma.promotion.upsert({
     *   create: {
     *     // ... data to create a Promotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotion we want to update
     *   }
     * })
     */
    upsert<T extends PromotionUpsertArgs>(args: SelectSubset<T, PromotionUpsertArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCountArgs} args - Arguments to filter Promotions to count.
     * @example
     * // Count the number of Promotions
     * const count = await prisma.promotion.count({
     *   where: {
     *     // ... the filter for the Promotions we want to count
     *   }
     * })
    **/
    count<T extends PromotionCountArgs>(
      args?: Subset<T, PromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionAggregateArgs>(args: Subset<T, PromotionAggregateArgs>): Prisma.PrismaPromise<GetPromotionAggregateType<T>>

    /**
     * Group by Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promotion model
   */
  readonly fields: PromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    products<T extends Promotion$productsArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Promotion model
   */
  interface PromotionFieldRefs {
    readonly id: FieldRef<"Promotion", 'Int'>
    readonly code: FieldRef<"Promotion", 'String'>
    readonly description: FieldRef<"Promotion", 'String'>
    readonly discountType: FieldRef<"Promotion", 'String'>
    readonly discountValue: FieldRef<"Promotion", 'Decimal'>
    readonly startDate: FieldRef<"Promotion", 'DateTime'>
    readonly endDate: FieldRef<"Promotion", 'DateTime'>
    readonly storeId: FieldRef<"Promotion", 'Int'>
    readonly createdAt: FieldRef<"Promotion", 'DateTime'>
    readonly updatedAt: FieldRef<"Promotion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Promotion findUnique
   */
  export type PromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findUniqueOrThrow
   */
  export type PromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findFirst
   */
  export type PromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findFirstOrThrow
   */
  export type PromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findMany
   */
  export type PromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotions to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion create
   */
  export type PromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to create a Promotion.
     */
    data: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
  }

  /**
   * Promotion createMany
   */
  export type PromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion update
   */
  export type PromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to update a Promotion.
     */
    data: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
    /**
     * Choose, which Promotion to update.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion updateMany
   */
  export type PromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
  }

  /**
   * Promotion upsert
   */
  export type PromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The filter to search for the Promotion to update in case it exists.
     */
    where: PromotionWhereUniqueInput
    /**
     * In case the Promotion found by the `where` argument doesn't exist, create a new Promotion with this data.
     */
    create: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
    /**
     * In case the Promotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
  }

  /**
   * Promotion delete
   */
  export type PromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter which Promotion to delete.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion deleteMany
   */
  export type PromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotions to delete
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to delete.
     */
    limit?: number
  }

  /**
   * Promotion.products
   */
  export type Promotion$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    cursor?: ProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Promotion without action
   */
  export type PromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    product?: boolean | Category$productArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>



  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | Category$productArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      product: Prisma.$ProductsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends Category$productArgs<ExtArgs> = {}>(args?: Subset<T, Category$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly name: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.product
   */
  export type Category$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    cursor?: ProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model ProductAvaliations
   */

  export type AggregateProductAvaliations = {
    _count: ProductAvaliationsCountAggregateOutputType | null
    _avg: ProductAvaliationsAvgAggregateOutputType | null
    _sum: ProductAvaliationsSumAggregateOutputType | null
    _min: ProductAvaliationsMinAggregateOutputType | null
    _max: ProductAvaliationsMaxAggregateOutputType | null
  }

  export type ProductAvaliationsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    note: number | null
  }

  export type ProductAvaliationsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    note: number | null
  }

  export type ProductAvaliationsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    note: number | null
    avaliationDate: Date | null
    comment: string | null
  }

  export type ProductAvaliationsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    note: number | null
    avaliationDate: Date | null
    comment: string | null
  }

  export type ProductAvaliationsCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    note: number
    avaliationDate: number
    comment: number
    _all: number
  }


  export type ProductAvaliationsAvgAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    note?: true
  }

  export type ProductAvaliationsSumAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    note?: true
  }

  export type ProductAvaliationsMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    note?: true
    avaliationDate?: true
    comment?: true
  }

  export type ProductAvaliationsMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    note?: true
    avaliationDate?: true
    comment?: true
  }

  export type ProductAvaliationsCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    note?: true
    avaliationDate?: true
    comment?: true
    _all?: true
  }

  export type ProductAvaliationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductAvaliations to aggregate.
     */
    where?: ProductAvaliationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAvaliations to fetch.
     */
    orderBy?: ProductAvaliationsOrderByWithRelationInput | ProductAvaliationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductAvaliationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAvaliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAvaliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductAvaliations
    **/
    _count?: true | ProductAvaliationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvaliationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductAvaliationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductAvaliationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductAvaliationsMaxAggregateInputType
  }

  export type GetProductAvaliationsAggregateType<T extends ProductAvaliationsAggregateArgs> = {
        [P in keyof T & keyof AggregateProductAvaliations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductAvaliations[P]>
      : GetScalarType<T[P], AggregateProductAvaliations[P]>
  }




  export type ProductAvaliationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductAvaliationsWhereInput
    orderBy?: ProductAvaliationsOrderByWithAggregationInput | ProductAvaliationsOrderByWithAggregationInput[]
    by: ProductAvaliationsScalarFieldEnum[] | ProductAvaliationsScalarFieldEnum
    having?: ProductAvaliationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductAvaliationsCountAggregateInputType | true
    _avg?: ProductAvaliationsAvgAggregateInputType
    _sum?: ProductAvaliationsSumAggregateInputType
    _min?: ProductAvaliationsMinAggregateInputType
    _max?: ProductAvaliationsMaxAggregateInputType
  }

  export type ProductAvaliationsGroupByOutputType = {
    id: number
    userId: number
    productId: number
    note: number
    avaliationDate: Date
    comment: string | null
    _count: ProductAvaliationsCountAggregateOutputType | null
    _avg: ProductAvaliationsAvgAggregateOutputType | null
    _sum: ProductAvaliationsSumAggregateOutputType | null
    _min: ProductAvaliationsMinAggregateOutputType | null
    _max: ProductAvaliationsMaxAggregateOutputType | null
  }

  type GetProductAvaliationsGroupByPayload<T extends ProductAvaliationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductAvaliationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductAvaliationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductAvaliationsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductAvaliationsGroupByOutputType[P]>
        }
      >
    >


  export type ProductAvaliationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    note?: boolean
    avaliationDate?: boolean
    comment?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductsDefaultArgs<ExtArgs>
    images?: boolean | ProductAvaliations$imagesArgs<ExtArgs>
    _count?: boolean | ProductAvaliationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productAvaliations"]>



  export type ProductAvaliationsSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    note?: boolean
    avaliationDate?: boolean
    comment?: boolean
  }

  export type ProductAvaliationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "productId" | "note" | "avaliationDate" | "comment", ExtArgs["result"]["productAvaliations"]>
  export type ProductAvaliationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductsDefaultArgs<ExtArgs>
    images?: boolean | ProductAvaliations$imagesArgs<ExtArgs>
    _count?: boolean | ProductAvaliationsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductAvaliationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductAvaliations"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      product: Prisma.$ProductsPayload<ExtArgs>
      images: Prisma.$ProductAvaliationImagesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      productId: number
      note: number
      avaliationDate: Date
      comment: string | null
    }, ExtArgs["result"]["productAvaliations"]>
    composites: {}
  }

  type ProductAvaliationsGetPayload<S extends boolean | null | undefined | ProductAvaliationsDefaultArgs> = $Result.GetResult<Prisma.$ProductAvaliationsPayload, S>

  type ProductAvaliationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductAvaliationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductAvaliationsCountAggregateInputType | true
    }

  export interface ProductAvaliationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductAvaliations'], meta: { name: 'ProductAvaliations' } }
    /**
     * Find zero or one ProductAvaliations that matches the filter.
     * @param {ProductAvaliationsFindUniqueArgs} args - Arguments to find a ProductAvaliations
     * @example
     * // Get one ProductAvaliations
     * const productAvaliations = await prisma.productAvaliations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductAvaliationsFindUniqueArgs>(args: SelectSubset<T, ProductAvaliationsFindUniqueArgs<ExtArgs>>): Prisma__ProductAvaliationsClient<$Result.GetResult<Prisma.$ProductAvaliationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductAvaliations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductAvaliationsFindUniqueOrThrowArgs} args - Arguments to find a ProductAvaliations
     * @example
     * // Get one ProductAvaliations
     * const productAvaliations = await prisma.productAvaliations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductAvaliationsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductAvaliationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductAvaliationsClient<$Result.GetResult<Prisma.$ProductAvaliationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductAvaliations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAvaliationsFindFirstArgs} args - Arguments to find a ProductAvaliations
     * @example
     * // Get one ProductAvaliations
     * const productAvaliations = await prisma.productAvaliations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductAvaliationsFindFirstArgs>(args?: SelectSubset<T, ProductAvaliationsFindFirstArgs<ExtArgs>>): Prisma__ProductAvaliationsClient<$Result.GetResult<Prisma.$ProductAvaliationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductAvaliations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAvaliationsFindFirstOrThrowArgs} args - Arguments to find a ProductAvaliations
     * @example
     * // Get one ProductAvaliations
     * const productAvaliations = await prisma.productAvaliations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductAvaliationsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductAvaliationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductAvaliationsClient<$Result.GetResult<Prisma.$ProductAvaliationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductAvaliations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAvaliationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductAvaliations
     * const productAvaliations = await prisma.productAvaliations.findMany()
     * 
     * // Get first 10 ProductAvaliations
     * const productAvaliations = await prisma.productAvaliations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productAvaliationsWithIdOnly = await prisma.productAvaliations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductAvaliationsFindManyArgs>(args?: SelectSubset<T, ProductAvaliationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductAvaliationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductAvaliations.
     * @param {ProductAvaliationsCreateArgs} args - Arguments to create a ProductAvaliations.
     * @example
     * // Create one ProductAvaliations
     * const ProductAvaliations = await prisma.productAvaliations.create({
     *   data: {
     *     // ... data to create a ProductAvaliations
     *   }
     * })
     * 
     */
    create<T extends ProductAvaliationsCreateArgs>(args: SelectSubset<T, ProductAvaliationsCreateArgs<ExtArgs>>): Prisma__ProductAvaliationsClient<$Result.GetResult<Prisma.$ProductAvaliationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductAvaliations.
     * @param {ProductAvaliationsCreateManyArgs} args - Arguments to create many ProductAvaliations.
     * @example
     * // Create many ProductAvaliations
     * const productAvaliations = await prisma.productAvaliations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductAvaliationsCreateManyArgs>(args?: SelectSubset<T, ProductAvaliationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductAvaliations.
     * @param {ProductAvaliationsDeleteArgs} args - Arguments to delete one ProductAvaliations.
     * @example
     * // Delete one ProductAvaliations
     * const ProductAvaliations = await prisma.productAvaliations.delete({
     *   where: {
     *     // ... filter to delete one ProductAvaliations
     *   }
     * })
     * 
     */
    delete<T extends ProductAvaliationsDeleteArgs>(args: SelectSubset<T, ProductAvaliationsDeleteArgs<ExtArgs>>): Prisma__ProductAvaliationsClient<$Result.GetResult<Prisma.$ProductAvaliationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductAvaliations.
     * @param {ProductAvaliationsUpdateArgs} args - Arguments to update one ProductAvaliations.
     * @example
     * // Update one ProductAvaliations
     * const productAvaliations = await prisma.productAvaliations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductAvaliationsUpdateArgs>(args: SelectSubset<T, ProductAvaliationsUpdateArgs<ExtArgs>>): Prisma__ProductAvaliationsClient<$Result.GetResult<Prisma.$ProductAvaliationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductAvaliations.
     * @param {ProductAvaliationsDeleteManyArgs} args - Arguments to filter ProductAvaliations to delete.
     * @example
     * // Delete a few ProductAvaliations
     * const { count } = await prisma.productAvaliations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductAvaliationsDeleteManyArgs>(args?: SelectSubset<T, ProductAvaliationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductAvaliations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAvaliationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductAvaliations
     * const productAvaliations = await prisma.productAvaliations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductAvaliationsUpdateManyArgs>(args: SelectSubset<T, ProductAvaliationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductAvaliations.
     * @param {ProductAvaliationsUpsertArgs} args - Arguments to update or create a ProductAvaliations.
     * @example
     * // Update or create a ProductAvaliations
     * const productAvaliations = await prisma.productAvaliations.upsert({
     *   create: {
     *     // ... data to create a ProductAvaliations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductAvaliations we want to update
     *   }
     * })
     */
    upsert<T extends ProductAvaliationsUpsertArgs>(args: SelectSubset<T, ProductAvaliationsUpsertArgs<ExtArgs>>): Prisma__ProductAvaliationsClient<$Result.GetResult<Prisma.$ProductAvaliationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductAvaliations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAvaliationsCountArgs} args - Arguments to filter ProductAvaliations to count.
     * @example
     * // Count the number of ProductAvaliations
     * const count = await prisma.productAvaliations.count({
     *   where: {
     *     // ... the filter for the ProductAvaliations we want to count
     *   }
     * })
    **/
    count<T extends ProductAvaliationsCountArgs>(
      args?: Subset<T, ProductAvaliationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductAvaliationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductAvaliations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAvaliationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAvaliationsAggregateArgs>(args: Subset<T, ProductAvaliationsAggregateArgs>): Prisma.PrismaPromise<GetProductAvaliationsAggregateType<T>>

    /**
     * Group by ProductAvaliations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAvaliationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductAvaliationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductAvaliationsGroupByArgs['orderBy'] }
        : { orderBy?: ProductAvaliationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductAvaliationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductAvaliationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductAvaliations model
   */
  readonly fields: ProductAvaliationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductAvaliations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductAvaliationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductsDefaultArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    images<T extends ProductAvaliations$imagesArgs<ExtArgs> = {}>(args?: Subset<T, ProductAvaliations$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductAvaliationImagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductAvaliations model
   */
  interface ProductAvaliationsFieldRefs {
    readonly id: FieldRef<"ProductAvaliations", 'Int'>
    readonly userId: FieldRef<"ProductAvaliations", 'Int'>
    readonly productId: FieldRef<"ProductAvaliations", 'Int'>
    readonly note: FieldRef<"ProductAvaliations", 'Int'>
    readonly avaliationDate: FieldRef<"ProductAvaliations", 'DateTime'>
    readonly comment: FieldRef<"ProductAvaliations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductAvaliations findUnique
   */
  export type ProductAvaliationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliations
     */
    select?: ProductAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliations
     */
    omit?: ProductAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationsInclude<ExtArgs> | null
    /**
     * Filter, which ProductAvaliations to fetch.
     */
    where: ProductAvaliationsWhereUniqueInput
  }

  /**
   * ProductAvaliations findUniqueOrThrow
   */
  export type ProductAvaliationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliations
     */
    select?: ProductAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliations
     */
    omit?: ProductAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationsInclude<ExtArgs> | null
    /**
     * Filter, which ProductAvaliations to fetch.
     */
    where: ProductAvaliationsWhereUniqueInput
  }

  /**
   * ProductAvaliations findFirst
   */
  export type ProductAvaliationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliations
     */
    select?: ProductAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliations
     */
    omit?: ProductAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationsInclude<ExtArgs> | null
    /**
     * Filter, which ProductAvaliations to fetch.
     */
    where?: ProductAvaliationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAvaliations to fetch.
     */
    orderBy?: ProductAvaliationsOrderByWithRelationInput | ProductAvaliationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductAvaliations.
     */
    cursor?: ProductAvaliationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAvaliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAvaliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductAvaliations.
     */
    distinct?: ProductAvaliationsScalarFieldEnum | ProductAvaliationsScalarFieldEnum[]
  }

  /**
   * ProductAvaliations findFirstOrThrow
   */
  export type ProductAvaliationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliations
     */
    select?: ProductAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliations
     */
    omit?: ProductAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationsInclude<ExtArgs> | null
    /**
     * Filter, which ProductAvaliations to fetch.
     */
    where?: ProductAvaliationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAvaliations to fetch.
     */
    orderBy?: ProductAvaliationsOrderByWithRelationInput | ProductAvaliationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductAvaliations.
     */
    cursor?: ProductAvaliationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAvaliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAvaliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductAvaliations.
     */
    distinct?: ProductAvaliationsScalarFieldEnum | ProductAvaliationsScalarFieldEnum[]
  }

  /**
   * ProductAvaliations findMany
   */
  export type ProductAvaliationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliations
     */
    select?: ProductAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliations
     */
    omit?: ProductAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationsInclude<ExtArgs> | null
    /**
     * Filter, which ProductAvaliations to fetch.
     */
    where?: ProductAvaliationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAvaliations to fetch.
     */
    orderBy?: ProductAvaliationsOrderByWithRelationInput | ProductAvaliationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductAvaliations.
     */
    cursor?: ProductAvaliationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAvaliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAvaliations.
     */
    skip?: number
    distinct?: ProductAvaliationsScalarFieldEnum | ProductAvaliationsScalarFieldEnum[]
  }

  /**
   * ProductAvaliations create
   */
  export type ProductAvaliationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliations
     */
    select?: ProductAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliations
     */
    omit?: ProductAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationsInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductAvaliations.
     */
    data: XOR<ProductAvaliationsCreateInput, ProductAvaliationsUncheckedCreateInput>
  }

  /**
   * ProductAvaliations createMany
   */
  export type ProductAvaliationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductAvaliations.
     */
    data: ProductAvaliationsCreateManyInput | ProductAvaliationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductAvaliations update
   */
  export type ProductAvaliationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliations
     */
    select?: ProductAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliations
     */
    omit?: ProductAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationsInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductAvaliations.
     */
    data: XOR<ProductAvaliationsUpdateInput, ProductAvaliationsUncheckedUpdateInput>
    /**
     * Choose, which ProductAvaliations to update.
     */
    where: ProductAvaliationsWhereUniqueInput
  }

  /**
   * ProductAvaliations updateMany
   */
  export type ProductAvaliationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductAvaliations.
     */
    data: XOR<ProductAvaliationsUpdateManyMutationInput, ProductAvaliationsUncheckedUpdateManyInput>
    /**
     * Filter which ProductAvaliations to update
     */
    where?: ProductAvaliationsWhereInput
    /**
     * Limit how many ProductAvaliations to update.
     */
    limit?: number
  }

  /**
   * ProductAvaliations upsert
   */
  export type ProductAvaliationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliations
     */
    select?: ProductAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliations
     */
    omit?: ProductAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationsInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductAvaliations to update in case it exists.
     */
    where: ProductAvaliationsWhereUniqueInput
    /**
     * In case the ProductAvaliations found by the `where` argument doesn't exist, create a new ProductAvaliations with this data.
     */
    create: XOR<ProductAvaliationsCreateInput, ProductAvaliationsUncheckedCreateInput>
    /**
     * In case the ProductAvaliations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductAvaliationsUpdateInput, ProductAvaliationsUncheckedUpdateInput>
  }

  /**
   * ProductAvaliations delete
   */
  export type ProductAvaliationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliations
     */
    select?: ProductAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliations
     */
    omit?: ProductAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationsInclude<ExtArgs> | null
    /**
     * Filter which ProductAvaliations to delete.
     */
    where: ProductAvaliationsWhereUniqueInput
  }

  /**
   * ProductAvaliations deleteMany
   */
  export type ProductAvaliationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductAvaliations to delete
     */
    where?: ProductAvaliationsWhereInput
    /**
     * Limit how many ProductAvaliations to delete.
     */
    limit?: number
  }

  /**
   * ProductAvaliations.images
   */
  export type ProductAvaliations$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliationImages
     */
    select?: ProductAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliationImages
     */
    omit?: ProductAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationImagesInclude<ExtArgs> | null
    where?: ProductAvaliationImagesWhereInput
    orderBy?: ProductAvaliationImagesOrderByWithRelationInput | ProductAvaliationImagesOrderByWithRelationInput[]
    cursor?: ProductAvaliationImagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductAvaliationImagesScalarFieldEnum | ProductAvaliationImagesScalarFieldEnum[]
  }

  /**
   * ProductAvaliations without action
   */
  export type ProductAvaliationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliations
     */
    select?: ProductAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliations
     */
    omit?: ProductAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationsInclude<ExtArgs> | null
  }


  /**
   * Model ProductAvaliationImages
   */

  export type AggregateProductAvaliationImages = {
    _count: ProductAvaliationImagesCountAggregateOutputType | null
    _avg: ProductAvaliationImagesAvgAggregateOutputType | null
    _sum: ProductAvaliationImagesSumAggregateOutputType | null
    _min: ProductAvaliationImagesMinAggregateOutputType | null
    _max: ProductAvaliationImagesMaxAggregateOutputType | null
  }

  export type ProductAvaliationImagesAvgAggregateOutputType = {
    id: number | null
    productAvaliationId: number | null
  }

  export type ProductAvaliationImagesSumAggregateOutputType = {
    id: number | null
    productAvaliationId: number | null
  }

  export type ProductAvaliationImagesMinAggregateOutputType = {
    id: number | null
    url: string | null
    publicId: string | null
    productAvaliationId: number | null
  }

  export type ProductAvaliationImagesMaxAggregateOutputType = {
    id: number | null
    url: string | null
    publicId: string | null
    productAvaliationId: number | null
  }

  export type ProductAvaliationImagesCountAggregateOutputType = {
    id: number
    url: number
    publicId: number
    productAvaliationId: number
    _all: number
  }


  export type ProductAvaliationImagesAvgAggregateInputType = {
    id?: true
    productAvaliationId?: true
  }

  export type ProductAvaliationImagesSumAggregateInputType = {
    id?: true
    productAvaliationId?: true
  }

  export type ProductAvaliationImagesMinAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
    productAvaliationId?: true
  }

  export type ProductAvaliationImagesMaxAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
    productAvaliationId?: true
  }

  export type ProductAvaliationImagesCountAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
    productAvaliationId?: true
    _all?: true
  }

  export type ProductAvaliationImagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductAvaliationImages to aggregate.
     */
    where?: ProductAvaliationImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAvaliationImages to fetch.
     */
    orderBy?: ProductAvaliationImagesOrderByWithRelationInput | ProductAvaliationImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductAvaliationImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAvaliationImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAvaliationImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductAvaliationImages
    **/
    _count?: true | ProductAvaliationImagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvaliationImagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductAvaliationImagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductAvaliationImagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductAvaliationImagesMaxAggregateInputType
  }

  export type GetProductAvaliationImagesAggregateType<T extends ProductAvaliationImagesAggregateArgs> = {
        [P in keyof T & keyof AggregateProductAvaliationImages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductAvaliationImages[P]>
      : GetScalarType<T[P], AggregateProductAvaliationImages[P]>
  }




  export type ProductAvaliationImagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductAvaliationImagesWhereInput
    orderBy?: ProductAvaliationImagesOrderByWithAggregationInput | ProductAvaliationImagesOrderByWithAggregationInput[]
    by: ProductAvaliationImagesScalarFieldEnum[] | ProductAvaliationImagesScalarFieldEnum
    having?: ProductAvaliationImagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductAvaliationImagesCountAggregateInputType | true
    _avg?: ProductAvaliationImagesAvgAggregateInputType
    _sum?: ProductAvaliationImagesSumAggregateInputType
    _min?: ProductAvaliationImagesMinAggregateInputType
    _max?: ProductAvaliationImagesMaxAggregateInputType
  }

  export type ProductAvaliationImagesGroupByOutputType = {
    id: number
    url: string
    publicId: string
    productAvaliationId: number | null
    _count: ProductAvaliationImagesCountAggregateOutputType | null
    _avg: ProductAvaliationImagesAvgAggregateOutputType | null
    _sum: ProductAvaliationImagesSumAggregateOutputType | null
    _min: ProductAvaliationImagesMinAggregateOutputType | null
    _max: ProductAvaliationImagesMaxAggregateOutputType | null
  }

  type GetProductAvaliationImagesGroupByPayload<T extends ProductAvaliationImagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductAvaliationImagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductAvaliationImagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductAvaliationImagesGroupByOutputType[P]>
            : GetScalarType<T[P], ProductAvaliationImagesGroupByOutputType[P]>
        }
      >
    >


  export type ProductAvaliationImagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    publicId?: boolean
    productAvaliationId?: boolean
    productAvaliation?: boolean | ProductAvaliationImages$productAvaliationArgs<ExtArgs>
  }, ExtArgs["result"]["productAvaliationImages"]>



  export type ProductAvaliationImagesSelectScalar = {
    id?: boolean
    url?: boolean
    publicId?: boolean
    productAvaliationId?: boolean
  }

  export type ProductAvaliationImagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "publicId" | "productAvaliationId", ExtArgs["result"]["productAvaliationImages"]>
  export type ProductAvaliationImagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productAvaliation?: boolean | ProductAvaliationImages$productAvaliationArgs<ExtArgs>
  }

  export type $ProductAvaliationImagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductAvaliationImages"
    objects: {
      productAvaliation: Prisma.$ProductAvaliationsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      publicId: string
      productAvaliationId: number | null
    }, ExtArgs["result"]["productAvaliationImages"]>
    composites: {}
  }

  type ProductAvaliationImagesGetPayload<S extends boolean | null | undefined | ProductAvaliationImagesDefaultArgs> = $Result.GetResult<Prisma.$ProductAvaliationImagesPayload, S>

  type ProductAvaliationImagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductAvaliationImagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductAvaliationImagesCountAggregateInputType | true
    }

  export interface ProductAvaliationImagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductAvaliationImages'], meta: { name: 'ProductAvaliationImages' } }
    /**
     * Find zero or one ProductAvaliationImages that matches the filter.
     * @param {ProductAvaliationImagesFindUniqueArgs} args - Arguments to find a ProductAvaliationImages
     * @example
     * // Get one ProductAvaliationImages
     * const productAvaliationImages = await prisma.productAvaliationImages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductAvaliationImagesFindUniqueArgs>(args: SelectSubset<T, ProductAvaliationImagesFindUniqueArgs<ExtArgs>>): Prisma__ProductAvaliationImagesClient<$Result.GetResult<Prisma.$ProductAvaliationImagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductAvaliationImages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductAvaliationImagesFindUniqueOrThrowArgs} args - Arguments to find a ProductAvaliationImages
     * @example
     * // Get one ProductAvaliationImages
     * const productAvaliationImages = await prisma.productAvaliationImages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductAvaliationImagesFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductAvaliationImagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductAvaliationImagesClient<$Result.GetResult<Prisma.$ProductAvaliationImagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductAvaliationImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAvaliationImagesFindFirstArgs} args - Arguments to find a ProductAvaliationImages
     * @example
     * // Get one ProductAvaliationImages
     * const productAvaliationImages = await prisma.productAvaliationImages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductAvaliationImagesFindFirstArgs>(args?: SelectSubset<T, ProductAvaliationImagesFindFirstArgs<ExtArgs>>): Prisma__ProductAvaliationImagesClient<$Result.GetResult<Prisma.$ProductAvaliationImagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductAvaliationImages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAvaliationImagesFindFirstOrThrowArgs} args - Arguments to find a ProductAvaliationImages
     * @example
     * // Get one ProductAvaliationImages
     * const productAvaliationImages = await prisma.productAvaliationImages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductAvaliationImagesFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductAvaliationImagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductAvaliationImagesClient<$Result.GetResult<Prisma.$ProductAvaliationImagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductAvaliationImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAvaliationImagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductAvaliationImages
     * const productAvaliationImages = await prisma.productAvaliationImages.findMany()
     * 
     * // Get first 10 ProductAvaliationImages
     * const productAvaliationImages = await prisma.productAvaliationImages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productAvaliationImagesWithIdOnly = await prisma.productAvaliationImages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductAvaliationImagesFindManyArgs>(args?: SelectSubset<T, ProductAvaliationImagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductAvaliationImagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductAvaliationImages.
     * @param {ProductAvaliationImagesCreateArgs} args - Arguments to create a ProductAvaliationImages.
     * @example
     * // Create one ProductAvaliationImages
     * const ProductAvaliationImages = await prisma.productAvaliationImages.create({
     *   data: {
     *     // ... data to create a ProductAvaliationImages
     *   }
     * })
     * 
     */
    create<T extends ProductAvaliationImagesCreateArgs>(args: SelectSubset<T, ProductAvaliationImagesCreateArgs<ExtArgs>>): Prisma__ProductAvaliationImagesClient<$Result.GetResult<Prisma.$ProductAvaliationImagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductAvaliationImages.
     * @param {ProductAvaliationImagesCreateManyArgs} args - Arguments to create many ProductAvaliationImages.
     * @example
     * // Create many ProductAvaliationImages
     * const productAvaliationImages = await prisma.productAvaliationImages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductAvaliationImagesCreateManyArgs>(args?: SelectSubset<T, ProductAvaliationImagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductAvaliationImages.
     * @param {ProductAvaliationImagesDeleteArgs} args - Arguments to delete one ProductAvaliationImages.
     * @example
     * // Delete one ProductAvaliationImages
     * const ProductAvaliationImages = await prisma.productAvaliationImages.delete({
     *   where: {
     *     // ... filter to delete one ProductAvaliationImages
     *   }
     * })
     * 
     */
    delete<T extends ProductAvaliationImagesDeleteArgs>(args: SelectSubset<T, ProductAvaliationImagesDeleteArgs<ExtArgs>>): Prisma__ProductAvaliationImagesClient<$Result.GetResult<Prisma.$ProductAvaliationImagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductAvaliationImages.
     * @param {ProductAvaliationImagesUpdateArgs} args - Arguments to update one ProductAvaliationImages.
     * @example
     * // Update one ProductAvaliationImages
     * const productAvaliationImages = await prisma.productAvaliationImages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductAvaliationImagesUpdateArgs>(args: SelectSubset<T, ProductAvaliationImagesUpdateArgs<ExtArgs>>): Prisma__ProductAvaliationImagesClient<$Result.GetResult<Prisma.$ProductAvaliationImagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductAvaliationImages.
     * @param {ProductAvaliationImagesDeleteManyArgs} args - Arguments to filter ProductAvaliationImages to delete.
     * @example
     * // Delete a few ProductAvaliationImages
     * const { count } = await prisma.productAvaliationImages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductAvaliationImagesDeleteManyArgs>(args?: SelectSubset<T, ProductAvaliationImagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductAvaliationImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAvaliationImagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductAvaliationImages
     * const productAvaliationImages = await prisma.productAvaliationImages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductAvaliationImagesUpdateManyArgs>(args: SelectSubset<T, ProductAvaliationImagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductAvaliationImages.
     * @param {ProductAvaliationImagesUpsertArgs} args - Arguments to update or create a ProductAvaliationImages.
     * @example
     * // Update or create a ProductAvaliationImages
     * const productAvaliationImages = await prisma.productAvaliationImages.upsert({
     *   create: {
     *     // ... data to create a ProductAvaliationImages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductAvaliationImages we want to update
     *   }
     * })
     */
    upsert<T extends ProductAvaliationImagesUpsertArgs>(args: SelectSubset<T, ProductAvaliationImagesUpsertArgs<ExtArgs>>): Prisma__ProductAvaliationImagesClient<$Result.GetResult<Prisma.$ProductAvaliationImagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductAvaliationImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAvaliationImagesCountArgs} args - Arguments to filter ProductAvaliationImages to count.
     * @example
     * // Count the number of ProductAvaliationImages
     * const count = await prisma.productAvaliationImages.count({
     *   where: {
     *     // ... the filter for the ProductAvaliationImages we want to count
     *   }
     * })
    **/
    count<T extends ProductAvaliationImagesCountArgs>(
      args?: Subset<T, ProductAvaliationImagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductAvaliationImagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductAvaliationImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAvaliationImagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAvaliationImagesAggregateArgs>(args: Subset<T, ProductAvaliationImagesAggregateArgs>): Prisma.PrismaPromise<GetProductAvaliationImagesAggregateType<T>>

    /**
     * Group by ProductAvaliationImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAvaliationImagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductAvaliationImagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductAvaliationImagesGroupByArgs['orderBy'] }
        : { orderBy?: ProductAvaliationImagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductAvaliationImagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductAvaliationImagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductAvaliationImages model
   */
  readonly fields: ProductAvaliationImagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductAvaliationImages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductAvaliationImagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productAvaliation<T extends ProductAvaliationImages$productAvaliationArgs<ExtArgs> = {}>(args?: Subset<T, ProductAvaliationImages$productAvaliationArgs<ExtArgs>>): Prisma__ProductAvaliationsClient<$Result.GetResult<Prisma.$ProductAvaliationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductAvaliationImages model
   */
  interface ProductAvaliationImagesFieldRefs {
    readonly id: FieldRef<"ProductAvaliationImages", 'Int'>
    readonly url: FieldRef<"ProductAvaliationImages", 'String'>
    readonly publicId: FieldRef<"ProductAvaliationImages", 'String'>
    readonly productAvaliationId: FieldRef<"ProductAvaliationImages", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductAvaliationImages findUnique
   */
  export type ProductAvaliationImagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliationImages
     */
    select?: ProductAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliationImages
     */
    omit?: ProductAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProductAvaliationImages to fetch.
     */
    where: ProductAvaliationImagesWhereUniqueInput
  }

  /**
   * ProductAvaliationImages findUniqueOrThrow
   */
  export type ProductAvaliationImagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliationImages
     */
    select?: ProductAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliationImages
     */
    omit?: ProductAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProductAvaliationImages to fetch.
     */
    where: ProductAvaliationImagesWhereUniqueInput
  }

  /**
   * ProductAvaliationImages findFirst
   */
  export type ProductAvaliationImagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliationImages
     */
    select?: ProductAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliationImages
     */
    omit?: ProductAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProductAvaliationImages to fetch.
     */
    where?: ProductAvaliationImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAvaliationImages to fetch.
     */
    orderBy?: ProductAvaliationImagesOrderByWithRelationInput | ProductAvaliationImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductAvaliationImages.
     */
    cursor?: ProductAvaliationImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAvaliationImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAvaliationImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductAvaliationImages.
     */
    distinct?: ProductAvaliationImagesScalarFieldEnum | ProductAvaliationImagesScalarFieldEnum[]
  }

  /**
   * ProductAvaliationImages findFirstOrThrow
   */
  export type ProductAvaliationImagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliationImages
     */
    select?: ProductAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliationImages
     */
    omit?: ProductAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProductAvaliationImages to fetch.
     */
    where?: ProductAvaliationImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAvaliationImages to fetch.
     */
    orderBy?: ProductAvaliationImagesOrderByWithRelationInput | ProductAvaliationImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductAvaliationImages.
     */
    cursor?: ProductAvaliationImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAvaliationImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAvaliationImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductAvaliationImages.
     */
    distinct?: ProductAvaliationImagesScalarFieldEnum | ProductAvaliationImagesScalarFieldEnum[]
  }

  /**
   * ProductAvaliationImages findMany
   */
  export type ProductAvaliationImagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliationImages
     */
    select?: ProductAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliationImages
     */
    omit?: ProductAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProductAvaliationImages to fetch.
     */
    where?: ProductAvaliationImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAvaliationImages to fetch.
     */
    orderBy?: ProductAvaliationImagesOrderByWithRelationInput | ProductAvaliationImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductAvaliationImages.
     */
    cursor?: ProductAvaliationImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAvaliationImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAvaliationImages.
     */
    skip?: number
    distinct?: ProductAvaliationImagesScalarFieldEnum | ProductAvaliationImagesScalarFieldEnum[]
  }

  /**
   * ProductAvaliationImages create
   */
  export type ProductAvaliationImagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliationImages
     */
    select?: ProductAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliationImages
     */
    omit?: ProductAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationImagesInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductAvaliationImages.
     */
    data: XOR<ProductAvaliationImagesCreateInput, ProductAvaliationImagesUncheckedCreateInput>
  }

  /**
   * ProductAvaliationImages createMany
   */
  export type ProductAvaliationImagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductAvaliationImages.
     */
    data: ProductAvaliationImagesCreateManyInput | ProductAvaliationImagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductAvaliationImages update
   */
  export type ProductAvaliationImagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliationImages
     */
    select?: ProductAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliationImages
     */
    omit?: ProductAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationImagesInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductAvaliationImages.
     */
    data: XOR<ProductAvaliationImagesUpdateInput, ProductAvaliationImagesUncheckedUpdateInput>
    /**
     * Choose, which ProductAvaliationImages to update.
     */
    where: ProductAvaliationImagesWhereUniqueInput
  }

  /**
   * ProductAvaliationImages updateMany
   */
  export type ProductAvaliationImagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductAvaliationImages.
     */
    data: XOR<ProductAvaliationImagesUpdateManyMutationInput, ProductAvaliationImagesUncheckedUpdateManyInput>
    /**
     * Filter which ProductAvaliationImages to update
     */
    where?: ProductAvaliationImagesWhereInput
    /**
     * Limit how many ProductAvaliationImages to update.
     */
    limit?: number
  }

  /**
   * ProductAvaliationImages upsert
   */
  export type ProductAvaliationImagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliationImages
     */
    select?: ProductAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliationImages
     */
    omit?: ProductAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationImagesInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductAvaliationImages to update in case it exists.
     */
    where: ProductAvaliationImagesWhereUniqueInput
    /**
     * In case the ProductAvaliationImages found by the `where` argument doesn't exist, create a new ProductAvaliationImages with this data.
     */
    create: XOR<ProductAvaliationImagesCreateInput, ProductAvaliationImagesUncheckedCreateInput>
    /**
     * In case the ProductAvaliationImages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductAvaliationImagesUpdateInput, ProductAvaliationImagesUncheckedUpdateInput>
  }

  /**
   * ProductAvaliationImages delete
   */
  export type ProductAvaliationImagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliationImages
     */
    select?: ProductAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliationImages
     */
    omit?: ProductAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationImagesInclude<ExtArgs> | null
    /**
     * Filter which ProductAvaliationImages to delete.
     */
    where: ProductAvaliationImagesWhereUniqueInput
  }

  /**
   * ProductAvaliationImages deleteMany
   */
  export type ProductAvaliationImagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductAvaliationImages to delete
     */
    where?: ProductAvaliationImagesWhereInput
    /**
     * Limit how many ProductAvaliationImages to delete.
     */
    limit?: number
  }

  /**
   * ProductAvaliationImages.productAvaliation
   */
  export type ProductAvaliationImages$productAvaliationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliations
     */
    select?: ProductAvaliationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliations
     */
    omit?: ProductAvaliationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationsInclude<ExtArgs> | null
    where?: ProductAvaliationsWhereInput
  }

  /**
   * ProductAvaliationImages without action
   */
  export type ProductAvaliationImagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAvaliationImages
     */
    select?: ProductAvaliationImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAvaliationImages
     */
    omit?: ProductAvaliationImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAvaliationImagesInclude<ExtArgs> | null
  }


  /**
   * Model Cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  export type CartAvgAggregateOutputType = {
    id: number | null
  }

  export type CartSumAggregateOutputType = {
    id: number | null
  }

  export type CartMinAggregateOutputType = {
    id: number | null
  }

  export type CartMaxAggregateOutputType = {
    id: number | null
  }

  export type CartCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type CartAvgAggregateInputType = {
    id?: true
  }

  export type CartSumAggregateInputType = {
    id?: true
  }

  export type CartMinAggregateInputType = {
    id?: true
  }

  export type CartMaxAggregateInputType = {
    id?: true
  }

  export type CartCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cart to aggregate.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carts
    **/
    _count?: true | CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartMaxAggregateInputType
  }

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
        [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>
  }




  export type CartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
    orderBy?: CartOrderByWithAggregationInput | CartOrderByWithAggregationInput[]
    by: CartScalarFieldEnum[] | CartScalarFieldEnum
    having?: CartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartCountAggregateInputType | true
    _avg?: CartAvgAggregateInputType
    _sum?: CartSumAggregateInputType
    _min?: CartMinAggregateInputType
    _max?: CartMaxAggregateInputType
  }

  export type CartGroupByOutputType = {
    id: number
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  type GetCartGroupByPayload<T extends CartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartGroupByOutputType[P]>
            : GetScalarType<T[P], CartGroupByOutputType[P]>
        }
      >
    >


  export type CartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userCart?: boolean | Cart$userCartArgs<ExtArgs>
    cartItems?: boolean | Cart$cartItemsArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>



  export type CartSelectScalar = {
    id?: boolean
  }

  export type CartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["cart"]>
  export type CartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userCart?: boolean | Cart$userCartArgs<ExtArgs>
    cartItems?: boolean | Cart$cartItemsArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cart"
    objects: {
      userCart: Prisma.$UserPayload<ExtArgs> | null
      cartItems: Prisma.$CartItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
    }, ExtArgs["result"]["cart"]>
    composites: {}
  }

  type CartGetPayload<S extends boolean | null | undefined | CartDefaultArgs> = $Result.GetResult<Prisma.$CartPayload, S>

  type CartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartCountAggregateInputType | true
    }

  export interface CartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cart'], meta: { name: 'Cart' } }
    /**
     * Find zero or one Cart that matches the filter.
     * @param {CartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartFindUniqueArgs>(args: SelectSubset<T, CartFindUniqueArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartFindUniqueOrThrowArgs>(args: SelectSubset<T, CartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartFindFirstArgs>(args?: SelectSubset<T, CartFindFirstArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartFindFirstOrThrowArgs>(args?: SelectSubset<T, CartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartFindManyArgs>(args?: SelectSubset<T, CartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cart.
     * @param {CartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     * 
     */
    create<T extends CartCreateArgs>(args: SelectSubset<T, CartCreateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carts.
     * @param {CartCreateManyArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartCreateManyArgs>(args?: SelectSubset<T, CartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cart.
     * @param {CartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     * 
     */
    delete<T extends CartDeleteArgs>(args: SelectSubset<T, CartDeleteArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cart.
     * @param {CartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartUpdateArgs>(args: SelectSubset<T, CartUpdateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carts.
     * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartDeleteManyArgs>(args?: SelectSubset<T, CartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartUpdateManyArgs>(args: SelectSubset<T, CartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cart.
     * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
     */
    upsert<T extends CartUpsertArgs>(args: SelectSubset<T, CartUpsertArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends CartCountArgs>(
      args?: Subset<T, CartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartGroupByArgs['orderBy'] }
        : { orderBy?: CartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cart model
   */
  readonly fields: CartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userCart<T extends Cart$userCartArgs<ExtArgs> = {}>(args?: Subset<T, Cart$userCartArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cartItems<T extends Cart$cartItemsArgs<ExtArgs> = {}>(args?: Subset<T, Cart$cartItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cart model
   */
  interface CartFieldRefs {
    readonly id: FieldRef<"Cart", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Cart findUnique
   */
  export type CartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findUniqueOrThrow
   */
  export type CartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findFirst
   */
  export type CartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findFirstOrThrow
   */
  export type CartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findMany
   */
  export type CartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart create
   */
  export type CartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to create a Cart.
     */
    data?: XOR<CartCreateInput, CartUncheckedCreateInput>
  }

  /**
   * Cart createMany
   */
  export type CartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cart update
   */
  export type CartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to update a Cart.
     */
    data: XOR<CartUpdateInput, CartUncheckedUpdateInput>
    /**
     * Choose, which Cart to update.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart updateMany
   */
  export type CartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
  }

  /**
   * Cart upsert
   */
  export type CartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The filter to search for the Cart to update in case it exists.
     */
    where: CartWhereUniqueInput
    /**
     * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
     */
    create: XOR<CartCreateInput, CartUncheckedCreateInput>
    /**
     * In case the Cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartUpdateInput, CartUncheckedUpdateInput>
  }

  /**
   * Cart delete
   */
  export type CartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter which Cart to delete.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart deleteMany
   */
  export type CartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carts to delete
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to delete.
     */
    limit?: number
  }

  /**
   * Cart.userCart
   */
  export type Cart$userCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Cart.cartItems
   */
  export type Cart$cartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItems
     */
    select?: CartItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItems
     */
    omit?: CartItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemsInclude<ExtArgs> | null
    where?: CartItemsWhereInput
    orderBy?: CartItemsOrderByWithRelationInput | CartItemsOrderByWithRelationInput[]
    cursor?: CartItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemsScalarFieldEnum | CartItemsScalarFieldEnum[]
  }

  /**
   * Cart without action
   */
  export type CartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
  }


  /**
   * Model CartItems
   */

  export type AggregateCartItems = {
    _count: CartItemsCountAggregateOutputType | null
    _avg: CartItemsAvgAggregateOutputType | null
    _sum: CartItemsSumAggregateOutputType | null
    _min: CartItemsMinAggregateOutputType | null
    _max: CartItemsMaxAggregateOutputType | null
  }

  export type CartItemsAvgAggregateOutputType = {
    id: number | null
    cartId: number | null
    productId: number | null
    quantidade: number | null
    abandonedCartId: number | null
  }

  export type CartItemsSumAggregateOutputType = {
    id: number | null
    cartId: number | null
    productId: number | null
    quantidade: number | null
    abandonedCartId: number | null
  }

  export type CartItemsMinAggregateOutputType = {
    id: number | null
    cartId: number | null
    productId: number | null
    quantidade: number | null
    abandonedCartId: number | null
  }

  export type CartItemsMaxAggregateOutputType = {
    id: number | null
    cartId: number | null
    productId: number | null
    quantidade: number | null
    abandonedCartId: number | null
  }

  export type CartItemsCountAggregateOutputType = {
    id: number
    cartId: number
    productId: number
    quantidade: number
    abandonedCartId: number
    _all: number
  }


  export type CartItemsAvgAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantidade?: true
    abandonedCartId?: true
  }

  export type CartItemsSumAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantidade?: true
    abandonedCartId?: true
  }

  export type CartItemsMinAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantidade?: true
    abandonedCartId?: true
  }

  export type CartItemsMaxAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantidade?: true
    abandonedCartId?: true
  }

  export type CartItemsCountAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantidade?: true
    abandonedCartId?: true
    _all?: true
  }

  export type CartItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItems to aggregate.
     */
    where?: CartItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemsOrderByWithRelationInput | CartItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CartItems
    **/
    _count?: true | CartItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartItemsMaxAggregateInputType
  }

  export type GetCartItemsAggregateType<T extends CartItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateCartItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartItems[P]>
      : GetScalarType<T[P], AggregateCartItems[P]>
  }




  export type CartItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemsWhereInput
    orderBy?: CartItemsOrderByWithAggregationInput | CartItemsOrderByWithAggregationInput[]
    by: CartItemsScalarFieldEnum[] | CartItemsScalarFieldEnum
    having?: CartItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartItemsCountAggregateInputType | true
    _avg?: CartItemsAvgAggregateInputType
    _sum?: CartItemsSumAggregateInputType
    _min?: CartItemsMinAggregateInputType
    _max?: CartItemsMaxAggregateInputType
  }

  export type CartItemsGroupByOutputType = {
    id: number
    cartId: number
    productId: number
    quantidade: number
    abandonedCartId: number | null
    _count: CartItemsCountAggregateOutputType | null
    _avg: CartItemsAvgAggregateOutputType | null
    _sum: CartItemsSumAggregateOutputType | null
    _min: CartItemsMinAggregateOutputType | null
    _max: CartItemsMaxAggregateOutputType | null
  }

  type GetCartItemsGroupByPayload<T extends CartItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartItemsGroupByOutputType[P]>
            : GetScalarType<T[P], CartItemsGroupByOutputType[P]>
        }
      >
    >


  export type CartItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantidade?: boolean
    abandonedCartId?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductsDefaultArgs<ExtArgs>
    AbandonedCart?: boolean | CartItems$AbandonedCartArgs<ExtArgs>
  }, ExtArgs["result"]["cartItems"]>



  export type CartItemsSelectScalar = {
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantidade?: boolean
    abandonedCartId?: boolean
  }

  export type CartItemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cartId" | "productId" | "quantidade" | "abandonedCartId", ExtArgs["result"]["cartItems"]>
  export type CartItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductsDefaultArgs<ExtArgs>
    AbandonedCart?: boolean | CartItems$AbandonedCartArgs<ExtArgs>
  }

  export type $CartItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CartItems"
    objects: {
      cart: Prisma.$CartPayload<ExtArgs>
      product: Prisma.$ProductsPayload<ExtArgs>
      AbandonedCart: Prisma.$AbandonedCartPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cartId: number
      productId: number
      quantidade: number
      abandonedCartId: number | null
    }, ExtArgs["result"]["cartItems"]>
    composites: {}
  }

  type CartItemsGetPayload<S extends boolean | null | undefined | CartItemsDefaultArgs> = $Result.GetResult<Prisma.$CartItemsPayload, S>

  type CartItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartItemsCountAggregateInputType | true
    }

  export interface CartItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CartItems'], meta: { name: 'CartItems' } }
    /**
     * Find zero or one CartItems that matches the filter.
     * @param {CartItemsFindUniqueArgs} args - Arguments to find a CartItems
     * @example
     * // Get one CartItems
     * const cartItems = await prisma.cartItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartItemsFindUniqueArgs>(args: SelectSubset<T, CartItemsFindUniqueArgs<ExtArgs>>): Prisma__CartItemsClient<$Result.GetResult<Prisma.$CartItemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CartItems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartItemsFindUniqueOrThrowArgs} args - Arguments to find a CartItems
     * @example
     * // Get one CartItems
     * const cartItems = await prisma.cartItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, CartItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartItemsClient<$Result.GetResult<Prisma.$CartItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemsFindFirstArgs} args - Arguments to find a CartItems
     * @example
     * // Get one CartItems
     * const cartItems = await prisma.cartItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartItemsFindFirstArgs>(args?: SelectSubset<T, CartItemsFindFirstArgs<ExtArgs>>): Prisma__CartItemsClient<$Result.GetResult<Prisma.$CartItemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemsFindFirstOrThrowArgs} args - Arguments to find a CartItems
     * @example
     * // Get one CartItems
     * const cartItems = await prisma.cartItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, CartItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartItemsClient<$Result.GetResult<Prisma.$CartItemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CartItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartItems
     * const cartItems = await prisma.cartItems.findMany()
     * 
     * // Get first 10 CartItems
     * const cartItems = await prisma.cartItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartItemsWithIdOnly = await prisma.cartItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartItemsFindManyArgs>(args?: SelectSubset<T, CartItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CartItems.
     * @param {CartItemsCreateArgs} args - Arguments to create a CartItems.
     * @example
     * // Create one CartItems
     * const CartItems = await prisma.cartItems.create({
     *   data: {
     *     // ... data to create a CartItems
     *   }
     * })
     * 
     */
    create<T extends CartItemsCreateArgs>(args: SelectSubset<T, CartItemsCreateArgs<ExtArgs>>): Prisma__CartItemsClient<$Result.GetResult<Prisma.$CartItemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CartItems.
     * @param {CartItemsCreateManyArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItems = await prisma.cartItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartItemsCreateManyArgs>(args?: SelectSubset<T, CartItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CartItems.
     * @param {CartItemsDeleteArgs} args - Arguments to delete one CartItems.
     * @example
     * // Delete one CartItems
     * const CartItems = await prisma.cartItems.delete({
     *   where: {
     *     // ... filter to delete one CartItems
     *   }
     * })
     * 
     */
    delete<T extends CartItemsDeleteArgs>(args: SelectSubset<T, CartItemsDeleteArgs<ExtArgs>>): Prisma__CartItemsClient<$Result.GetResult<Prisma.$CartItemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CartItems.
     * @param {CartItemsUpdateArgs} args - Arguments to update one CartItems.
     * @example
     * // Update one CartItems
     * const cartItems = await prisma.cartItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartItemsUpdateArgs>(args: SelectSubset<T, CartItemsUpdateArgs<ExtArgs>>): Prisma__CartItemsClient<$Result.GetResult<Prisma.$CartItemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CartItems.
     * @param {CartItemsDeleteManyArgs} args - Arguments to filter CartItems to delete.
     * @example
     * // Delete a few CartItems
     * const { count } = await prisma.cartItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartItemsDeleteManyArgs>(args?: SelectSubset<T, CartItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartItems
     * const cartItems = await prisma.cartItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartItemsUpdateManyArgs>(args: SelectSubset<T, CartItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CartItems.
     * @param {CartItemsUpsertArgs} args - Arguments to update or create a CartItems.
     * @example
     * // Update or create a CartItems
     * const cartItems = await prisma.cartItems.upsert({
     *   create: {
     *     // ... data to create a CartItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartItems we want to update
     *   }
     * })
     */
    upsert<T extends CartItemsUpsertArgs>(args: SelectSubset<T, CartItemsUpsertArgs<ExtArgs>>): Prisma__CartItemsClient<$Result.GetResult<Prisma.$CartItemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemsCountArgs} args - Arguments to filter CartItems to count.
     * @example
     * // Count the number of CartItems
     * const count = await prisma.cartItems.count({
     *   where: {
     *     // ... the filter for the CartItems we want to count
     *   }
     * })
    **/
    count<T extends CartItemsCountArgs>(
      args?: Subset<T, CartItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartItemsAggregateArgs>(args: Subset<T, CartItemsAggregateArgs>): Prisma.PrismaPromise<GetCartItemsAggregateType<T>>

    /**
     * Group by CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartItemsGroupByArgs['orderBy'] }
        : { orderBy?: CartItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CartItems model
   */
  readonly fields: CartItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cart<T extends CartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CartDefaultArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductsDefaultArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    AbandonedCart<T extends CartItems$AbandonedCartArgs<ExtArgs> = {}>(args?: Subset<T, CartItems$AbandonedCartArgs<ExtArgs>>): Prisma__AbandonedCartClient<$Result.GetResult<Prisma.$AbandonedCartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CartItems model
   */
  interface CartItemsFieldRefs {
    readonly id: FieldRef<"CartItems", 'Int'>
    readonly cartId: FieldRef<"CartItems", 'Int'>
    readonly productId: FieldRef<"CartItems", 'Int'>
    readonly quantidade: FieldRef<"CartItems", 'Int'>
    readonly abandonedCartId: FieldRef<"CartItems", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CartItems findUnique
   */
  export type CartItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItems
     */
    select?: CartItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItems
     */
    omit?: CartItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemsInclude<ExtArgs> | null
    /**
     * Filter, which CartItems to fetch.
     */
    where: CartItemsWhereUniqueInput
  }

  /**
   * CartItems findUniqueOrThrow
   */
  export type CartItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItems
     */
    select?: CartItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItems
     */
    omit?: CartItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemsInclude<ExtArgs> | null
    /**
     * Filter, which CartItems to fetch.
     */
    where: CartItemsWhereUniqueInput
  }

  /**
   * CartItems findFirst
   */
  export type CartItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItems
     */
    select?: CartItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItems
     */
    omit?: CartItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemsInclude<ExtArgs> | null
    /**
     * Filter, which CartItems to fetch.
     */
    where?: CartItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemsOrderByWithRelationInput | CartItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemsScalarFieldEnum | CartItemsScalarFieldEnum[]
  }

  /**
   * CartItems findFirstOrThrow
   */
  export type CartItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItems
     */
    select?: CartItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItems
     */
    omit?: CartItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemsInclude<ExtArgs> | null
    /**
     * Filter, which CartItems to fetch.
     */
    where?: CartItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemsOrderByWithRelationInput | CartItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemsScalarFieldEnum | CartItemsScalarFieldEnum[]
  }

  /**
   * CartItems findMany
   */
  export type CartItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItems
     */
    select?: CartItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItems
     */
    omit?: CartItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemsInclude<ExtArgs> | null
    /**
     * Filter, which CartItems to fetch.
     */
    where?: CartItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemsOrderByWithRelationInput | CartItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CartItems.
     */
    cursor?: CartItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    distinct?: CartItemsScalarFieldEnum | CartItemsScalarFieldEnum[]
  }

  /**
   * CartItems create
   */
  export type CartItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItems
     */
    select?: CartItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItems
     */
    omit?: CartItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a CartItems.
     */
    data: XOR<CartItemsCreateInput, CartItemsUncheckedCreateInput>
  }

  /**
   * CartItems createMany
   */
  export type CartItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CartItems.
     */
    data: CartItemsCreateManyInput | CartItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CartItems update
   */
  export type CartItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItems
     */
    select?: CartItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItems
     */
    omit?: CartItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a CartItems.
     */
    data: XOR<CartItemsUpdateInput, CartItemsUncheckedUpdateInput>
    /**
     * Choose, which CartItems to update.
     */
    where: CartItemsWhereUniqueInput
  }

  /**
   * CartItems updateMany
   */
  export type CartItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemsUpdateManyMutationInput, CartItemsUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemsWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
  }

  /**
   * CartItems upsert
   */
  export type CartItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItems
     */
    select?: CartItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItems
     */
    omit?: CartItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the CartItems to update in case it exists.
     */
    where: CartItemsWhereUniqueInput
    /**
     * In case the CartItems found by the `where` argument doesn't exist, create a new CartItems with this data.
     */
    create: XOR<CartItemsCreateInput, CartItemsUncheckedCreateInput>
    /**
     * In case the CartItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartItemsUpdateInput, CartItemsUncheckedUpdateInput>
  }

  /**
   * CartItems delete
   */
  export type CartItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItems
     */
    select?: CartItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItems
     */
    omit?: CartItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemsInclude<ExtArgs> | null
    /**
     * Filter which CartItems to delete.
     */
    where: CartItemsWhereUniqueInput
  }

  /**
   * CartItems deleteMany
   */
  export type CartItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItems to delete
     */
    where?: CartItemsWhereInput
    /**
     * Limit how many CartItems to delete.
     */
    limit?: number
  }

  /**
   * CartItems.AbandonedCart
   */
  export type CartItems$AbandonedCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbandonedCart
     */
    select?: AbandonedCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbandonedCart
     */
    omit?: AbandonedCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbandonedCartInclude<ExtArgs> | null
    where?: AbandonedCartWhereInput
  }

  /**
   * CartItems without action
   */
  export type CartItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItems
     */
    select?: CartItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItems
     */
    omit?: CartItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemsInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodAvgAggregateOutputType = {
    id: number | null
  }

  export type PaymentMethodSumAggregateOutputType = {
    id: number | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: number | null
    method: $Enums.PaymentMethodType | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: number | null
    method: $Enums.PaymentMethodType | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    method: number
    _all: number
  }


  export type PaymentMethodAvgAggregateInputType = {
    id?: true
  }

  export type PaymentMethodSumAggregateInputType = {
    id?: true
  }

  export type PaymentMethodMinAggregateInputType = {
    id?: true
    method?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    method?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    method?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _avg?: PaymentMethodAvgAggregateInputType
    _sum?: PaymentMethodSumAggregateInputType
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: number
    method: $Enums.PaymentMethodType
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    method?: boolean
    payments?: boolean | PaymentMethod$paymentsArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>



  export type PaymentMethodSelectScalar = {
    id?: boolean
    method?: boolean
  }

  export type PaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "method", ExtArgs["result"]["paymentMethod"]>
  export type PaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | PaymentMethod$paymentsArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      method: $Enums.PaymentMethodType
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends PaymentMethod$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethod$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'Int'>
    readonly method: FieldRef<"PaymentMethod", 'PaymentMethodType'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * PaymentMethod.payments
   */
  export type PaymentMethod$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    valor: Decimal | null
    paymentMethodId: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    valor: Decimal | null
    paymentMethodId: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    valor: Decimal | null
    paymentDate: Date | null
    paymentMethodId: number | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    valor: Decimal | null
    paymentDate: Date | null
    paymentMethodId: number | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    valor: number
    paymentDate: number
    paymentMethodId: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    valor?: true
    paymentMethodId?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    valor?: true
    paymentMethodId?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    valor?: true
    paymentDate?: true
    paymentMethodId?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    valor?: true
    paymentDate?: true
    paymentMethodId?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    valor?: true
    paymentDate?: true
    paymentMethodId?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    valor: Decimal
    paymentDate: Date
    paymentMethodId: number
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    paymentDate?: boolean
    paymentMethodId?: boolean
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>



  export type PaymentSelectScalar = {
    id?: boolean
    valor?: boolean
    paymentDate?: boolean
    paymentMethodId?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "valor" | "paymentDate" | "paymentMethodId", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      paymentMethod: Prisma.$PaymentMethodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      valor: Prisma.Decimal
      paymentDate: Date
      paymentMethodId: number
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paymentMethod<T extends PaymentMethodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethodDefaultArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly valor: FieldRef<"Payment", 'Decimal'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly paymentMethodId: FieldRef<"Payment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model OrderStatus
   */

  export type AggregateOrderStatus = {
    _count: OrderStatusCountAggregateOutputType | null
    _avg: OrderStatusAvgAggregateOutputType | null
    _sum: OrderStatusSumAggregateOutputType | null
    _min: OrderStatusMinAggregateOutputType | null
    _max: OrderStatusMaxAggregateOutputType | null
  }

  export type OrderStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type OrderStatusSumAggregateOutputType = {
    id: number | null
  }

  export type OrderStatusMinAggregateOutputType = {
    id: number | null
    Status: $Enums.OrderStatusType | null
  }

  export type OrderStatusMaxAggregateOutputType = {
    id: number | null
    Status: $Enums.OrderStatusType | null
  }

  export type OrderStatusCountAggregateOutputType = {
    id: number
    Status: number
    _all: number
  }


  export type OrderStatusAvgAggregateInputType = {
    id?: true
  }

  export type OrderStatusSumAggregateInputType = {
    id?: true
  }

  export type OrderStatusMinAggregateInputType = {
    id?: true
    Status?: true
  }

  export type OrderStatusMaxAggregateInputType = {
    id?: true
    Status?: true
  }

  export type OrderStatusCountAggregateInputType = {
    id?: true
    Status?: true
    _all?: true
  }

  export type OrderStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderStatus to aggregate.
     */
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     */
    orderBy?: OrderStatusOrderByWithRelationInput | OrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderStatuses
    **/
    _count?: true | OrderStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderStatusMaxAggregateInputType
  }

  export type GetOrderStatusAggregateType<T extends OrderStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderStatus[P]>
      : GetScalarType<T[P], AggregateOrderStatus[P]>
  }




  export type OrderStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderStatusWhereInput
    orderBy?: OrderStatusOrderByWithAggregationInput | OrderStatusOrderByWithAggregationInput[]
    by: OrderStatusScalarFieldEnum[] | OrderStatusScalarFieldEnum
    having?: OrderStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderStatusCountAggregateInputType | true
    _avg?: OrderStatusAvgAggregateInputType
    _sum?: OrderStatusSumAggregateInputType
    _min?: OrderStatusMinAggregateInputType
    _max?: OrderStatusMaxAggregateInputType
  }

  export type OrderStatusGroupByOutputType = {
    id: number
    Status: $Enums.OrderStatusType
    _count: OrderStatusCountAggregateOutputType | null
    _avg: OrderStatusAvgAggregateOutputType | null
    _sum: OrderStatusSumAggregateOutputType | null
    _min: OrderStatusMinAggregateOutputType | null
    _max: OrderStatusMaxAggregateOutputType | null
  }

  type GetOrderStatusGroupByPayload<T extends OrderStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderStatusGroupByOutputType[P]>
            : GetScalarType<T[P], OrderStatusGroupByOutputType[P]>
        }
      >
    >


  export type OrderStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Status?: boolean
    orders?: boolean | OrderStatus$ordersArgs<ExtArgs>
    _count?: boolean | OrderStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderStatus"]>



  export type OrderStatusSelectScalar = {
    id?: boolean
    Status?: boolean
  }

  export type OrderStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Status", ExtArgs["result"]["orderStatus"]>
  export type OrderStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | OrderStatus$ordersArgs<ExtArgs>
    _count?: boolean | OrderStatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrderStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderStatus"
    objects: {
      orders: Prisma.$OrdersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      Status: $Enums.OrderStatusType
    }, ExtArgs["result"]["orderStatus"]>
    composites: {}
  }

  type OrderStatusGetPayload<S extends boolean | null | undefined | OrderStatusDefaultArgs> = $Result.GetResult<Prisma.$OrderStatusPayload, S>

  type OrderStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderStatusCountAggregateInputType | true
    }

  export interface OrderStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderStatus'], meta: { name: 'OrderStatus' } }
    /**
     * Find zero or one OrderStatus that matches the filter.
     * @param {OrderStatusFindUniqueArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderStatusFindUniqueArgs>(args: SelectSubset<T, OrderStatusFindUniqueArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderStatusFindUniqueOrThrowArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusFindFirstArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderStatusFindFirstArgs>(args?: SelectSubset<T, OrderStatusFindFirstArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusFindFirstOrThrowArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderStatuses
     * const orderStatuses = await prisma.orderStatus.findMany()
     * 
     * // Get first 10 OrderStatuses
     * const orderStatuses = await prisma.orderStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderStatusWithIdOnly = await prisma.orderStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderStatusFindManyArgs>(args?: SelectSubset<T, OrderStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderStatus.
     * @param {OrderStatusCreateArgs} args - Arguments to create a OrderStatus.
     * @example
     * // Create one OrderStatus
     * const OrderStatus = await prisma.orderStatus.create({
     *   data: {
     *     // ... data to create a OrderStatus
     *   }
     * })
     * 
     */
    create<T extends OrderStatusCreateArgs>(args: SelectSubset<T, OrderStatusCreateArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderStatuses.
     * @param {OrderStatusCreateManyArgs} args - Arguments to create many OrderStatuses.
     * @example
     * // Create many OrderStatuses
     * const orderStatus = await prisma.orderStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderStatusCreateManyArgs>(args?: SelectSubset<T, OrderStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderStatus.
     * @param {OrderStatusDeleteArgs} args - Arguments to delete one OrderStatus.
     * @example
     * // Delete one OrderStatus
     * const OrderStatus = await prisma.orderStatus.delete({
     *   where: {
     *     // ... filter to delete one OrderStatus
     *   }
     * })
     * 
     */
    delete<T extends OrderStatusDeleteArgs>(args: SelectSubset<T, OrderStatusDeleteArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderStatus.
     * @param {OrderStatusUpdateArgs} args - Arguments to update one OrderStatus.
     * @example
     * // Update one OrderStatus
     * const orderStatus = await prisma.orderStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderStatusUpdateArgs>(args: SelectSubset<T, OrderStatusUpdateArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderStatuses.
     * @param {OrderStatusDeleteManyArgs} args - Arguments to filter OrderStatuses to delete.
     * @example
     * // Delete a few OrderStatuses
     * const { count } = await prisma.orderStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderStatusDeleteManyArgs>(args?: SelectSubset<T, OrderStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderStatuses
     * const orderStatus = await prisma.orderStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderStatusUpdateManyArgs>(args: SelectSubset<T, OrderStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderStatus.
     * @param {OrderStatusUpsertArgs} args - Arguments to update or create a OrderStatus.
     * @example
     * // Update or create a OrderStatus
     * const orderStatus = await prisma.orderStatus.upsert({
     *   create: {
     *     // ... data to create a OrderStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderStatus we want to update
     *   }
     * })
     */
    upsert<T extends OrderStatusUpsertArgs>(args: SelectSubset<T, OrderStatusUpsertArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusCountArgs} args - Arguments to filter OrderStatuses to count.
     * @example
     * // Count the number of OrderStatuses
     * const count = await prisma.orderStatus.count({
     *   where: {
     *     // ... the filter for the OrderStatuses we want to count
     *   }
     * })
    **/
    count<T extends OrderStatusCountArgs>(
      args?: Subset<T, OrderStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderStatusAggregateArgs>(args: Subset<T, OrderStatusAggregateArgs>): Prisma.PrismaPromise<GetOrderStatusAggregateType<T>>

    /**
     * Group by OrderStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderStatusGroupByArgs['orderBy'] }
        : { orderBy?: OrderStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderStatus model
   */
  readonly fields: OrderStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends OrderStatus$ordersArgs<ExtArgs> = {}>(args?: Subset<T, OrderStatus$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderStatus model
   */
  interface OrderStatusFieldRefs {
    readonly id: FieldRef<"OrderStatus", 'Int'>
    readonly Status: FieldRef<"OrderStatus", 'OrderStatusType'>
  }
    

  // Custom InputTypes
  /**
   * OrderStatus findUnique
   */
  export type OrderStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatus to fetch.
     */
    where: OrderStatusWhereUniqueInput
  }

  /**
   * OrderStatus findUniqueOrThrow
   */
  export type OrderStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatus to fetch.
     */
    where: OrderStatusWhereUniqueInput
  }

  /**
   * OrderStatus findFirst
   */
  export type OrderStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatus to fetch.
     */
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     */
    orderBy?: OrderStatusOrderByWithRelationInput | OrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderStatuses.
     */
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderStatuses.
     */
    distinct?: OrderStatusScalarFieldEnum | OrderStatusScalarFieldEnum[]
  }

  /**
   * OrderStatus findFirstOrThrow
   */
  export type OrderStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatus to fetch.
     */
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     */
    orderBy?: OrderStatusOrderByWithRelationInput | OrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderStatuses.
     */
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderStatuses.
     */
    distinct?: OrderStatusScalarFieldEnum | OrderStatusScalarFieldEnum[]
  }

  /**
   * OrderStatus findMany
   */
  export type OrderStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatuses to fetch.
     */
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     */
    orderBy?: OrderStatusOrderByWithRelationInput | OrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderStatuses.
     */
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     */
    skip?: number
    distinct?: OrderStatusScalarFieldEnum | OrderStatusScalarFieldEnum[]
  }

  /**
   * OrderStatus create
   */
  export type OrderStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderStatus.
     */
    data: XOR<OrderStatusCreateInput, OrderStatusUncheckedCreateInput>
  }

  /**
   * OrderStatus createMany
   */
  export type OrderStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderStatuses.
     */
    data: OrderStatusCreateManyInput | OrderStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderStatus update
   */
  export type OrderStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderStatus.
     */
    data: XOR<OrderStatusUpdateInput, OrderStatusUncheckedUpdateInput>
    /**
     * Choose, which OrderStatus to update.
     */
    where: OrderStatusWhereUniqueInput
  }

  /**
   * OrderStatus updateMany
   */
  export type OrderStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderStatuses.
     */
    data: XOR<OrderStatusUpdateManyMutationInput, OrderStatusUncheckedUpdateManyInput>
    /**
     * Filter which OrderStatuses to update
     */
    where?: OrderStatusWhereInput
    /**
     * Limit how many OrderStatuses to update.
     */
    limit?: number
  }

  /**
   * OrderStatus upsert
   */
  export type OrderStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderStatus to update in case it exists.
     */
    where: OrderStatusWhereUniqueInput
    /**
     * In case the OrderStatus found by the `where` argument doesn't exist, create a new OrderStatus with this data.
     */
    create: XOR<OrderStatusCreateInput, OrderStatusUncheckedCreateInput>
    /**
     * In case the OrderStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderStatusUpdateInput, OrderStatusUncheckedUpdateInput>
  }

  /**
   * OrderStatus delete
   */
  export type OrderStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter which OrderStatus to delete.
     */
    where: OrderStatusWhereUniqueInput
  }

  /**
   * OrderStatus deleteMany
   */
  export type OrderStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderStatuses to delete
     */
    where?: OrderStatusWhereInput
    /**
     * Limit how many OrderStatuses to delete.
     */
    limit?: number
  }

  /**
   * OrderStatus.orders
   */
  export type OrderStatus$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    cursor?: OrdersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * OrderStatus without action
   */
  export type OrderStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
  }


  /**
   * Model Orders
   */

  export type AggregateOrders = {
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  export type OrdersAvgAggregateOutputType = {
    id: number | null
    totalValue: Decimal | null
    userId: number | null
    orderStatusId: number | null
    deliveryAddressId: number | null
  }

  export type OrdersSumAggregateOutputType = {
    id: number | null
    totalValue: Decimal | null
    userId: number | null
    orderStatusId: number | null
    deliveryAddressId: number | null
  }

  export type OrdersMinAggregateOutputType = {
    id: number | null
    totalValue: Decimal | null
    trackingCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sendDate: Date | null
    deliveryDate: Date | null
    minimumDeliveryForeast: Date | null
    maximumDeliveryForeast: Date | null
    usedCoupon: boolean | null
    userId: number | null
    orderStatusId: number | null
    deliveryAddressId: number | null
  }

  export type OrdersMaxAggregateOutputType = {
    id: number | null
    totalValue: Decimal | null
    trackingCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sendDate: Date | null
    deliveryDate: Date | null
    minimumDeliveryForeast: Date | null
    maximumDeliveryForeast: Date | null
    usedCoupon: boolean | null
    userId: number | null
    orderStatusId: number | null
    deliveryAddressId: number | null
  }

  export type OrdersCountAggregateOutputType = {
    id: number
    totalValue: number
    trackingCode: number
    createdAt: number
    updatedAt: number
    sendDate: number
    deliveryDate: number
    minimumDeliveryForeast: number
    maximumDeliveryForeast: number
    usedCoupon: number
    userId: number
    orderStatusId: number
    deliveryAddressId: number
    _all: number
  }


  export type OrdersAvgAggregateInputType = {
    id?: true
    totalValue?: true
    userId?: true
    orderStatusId?: true
    deliveryAddressId?: true
  }

  export type OrdersSumAggregateInputType = {
    id?: true
    totalValue?: true
    userId?: true
    orderStatusId?: true
    deliveryAddressId?: true
  }

  export type OrdersMinAggregateInputType = {
    id?: true
    totalValue?: true
    trackingCode?: true
    createdAt?: true
    updatedAt?: true
    sendDate?: true
    deliveryDate?: true
    minimumDeliveryForeast?: true
    maximumDeliveryForeast?: true
    usedCoupon?: true
    userId?: true
    orderStatusId?: true
    deliveryAddressId?: true
  }

  export type OrdersMaxAggregateInputType = {
    id?: true
    totalValue?: true
    trackingCode?: true
    createdAt?: true
    updatedAt?: true
    sendDate?: true
    deliveryDate?: true
    minimumDeliveryForeast?: true
    maximumDeliveryForeast?: true
    usedCoupon?: true
    userId?: true
    orderStatusId?: true
    deliveryAddressId?: true
  }

  export type OrdersCountAggregateInputType = {
    id?: true
    totalValue?: true
    trackingCode?: true
    createdAt?: true
    updatedAt?: true
    sendDate?: true
    deliveryDate?: true
    minimumDeliveryForeast?: true
    maximumDeliveryForeast?: true
    usedCoupon?: true
    userId?: true
    orderStatusId?: true
    deliveryAddressId?: true
    _all?: true
  }

  export type OrdersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to aggregate.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdersMaxAggregateInputType
  }

  export type GetOrdersAggregateType<T extends OrdersAggregateArgs> = {
        [P in keyof T & keyof AggregateOrders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrders[P]>
      : GetScalarType<T[P], AggregateOrders[P]>
  }




  export type OrdersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithAggregationInput | OrdersOrderByWithAggregationInput[]
    by: OrdersScalarFieldEnum[] | OrdersScalarFieldEnum
    having?: OrdersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdersCountAggregateInputType | true
    _avg?: OrdersAvgAggregateInputType
    _sum?: OrdersSumAggregateInputType
    _min?: OrdersMinAggregateInputType
    _max?: OrdersMaxAggregateInputType
  }

  export type OrdersGroupByOutputType = {
    id: number
    totalValue: Decimal
    trackingCode: string
    createdAt: Date
    updatedAt: Date
    sendDate: Date
    deliveryDate: Date
    minimumDeliveryForeast: Date
    maximumDeliveryForeast: Date
    usedCoupon: boolean
    userId: number
    orderStatusId: number
    deliveryAddressId: number
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  type GetOrdersGroupByPayload<T extends OrdersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdersGroupByOutputType[P]>
            : GetScalarType<T[P], OrdersGroupByOutputType[P]>
        }
      >
    >


  export type OrdersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalValue?: boolean
    trackingCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sendDate?: boolean
    deliveryDate?: boolean
    minimumDeliveryForeast?: boolean
    maximumDeliveryForeast?: boolean
    usedCoupon?: boolean
    userId?: boolean
    orderStatusId?: boolean
    deliveryAddressId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    orderStatus?: boolean | OrderStatusDefaultArgs<ExtArgs>
    deliveryAddress?: boolean | AddressesDefaultArgs<ExtArgs>
    usedCoupons?: boolean | Orders$usedCouponsArgs<ExtArgs>
    orderItems?: boolean | Orders$orderItemsArgs<ExtArgs>
    orderHistory?: boolean | Orders$orderHistoryArgs<ExtArgs>
    shipping?: boolean | Orders$shippingArgs<ExtArgs>
    ReturnExchange?: boolean | Orders$ReturnExchangeArgs<ExtArgs>
    _count?: boolean | OrdersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>



  export type OrdersSelectScalar = {
    id?: boolean
    totalValue?: boolean
    trackingCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sendDate?: boolean
    deliveryDate?: boolean
    minimumDeliveryForeast?: boolean
    maximumDeliveryForeast?: boolean
    usedCoupon?: boolean
    userId?: boolean
    orderStatusId?: boolean
    deliveryAddressId?: boolean
  }

  export type OrdersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "totalValue" | "trackingCode" | "createdAt" | "updatedAt" | "sendDate" | "deliveryDate" | "minimumDeliveryForeast" | "maximumDeliveryForeast" | "usedCoupon" | "userId" | "orderStatusId" | "deliveryAddressId", ExtArgs["result"]["orders"]>
  export type OrdersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    orderStatus?: boolean | OrderStatusDefaultArgs<ExtArgs>
    deliveryAddress?: boolean | AddressesDefaultArgs<ExtArgs>
    usedCoupons?: boolean | Orders$usedCouponsArgs<ExtArgs>
    orderItems?: boolean | Orders$orderItemsArgs<ExtArgs>
    orderHistory?: boolean | Orders$orderHistoryArgs<ExtArgs>
    shipping?: boolean | Orders$shippingArgs<ExtArgs>
    ReturnExchange?: boolean | Orders$ReturnExchangeArgs<ExtArgs>
    _count?: boolean | OrdersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrdersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Orders"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      orderStatus: Prisma.$OrderStatusPayload<ExtArgs>
      deliveryAddress: Prisma.$AddressesPayload<ExtArgs>
      usedCoupons: Prisma.$UserUsedCouponsPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemsPayload<ExtArgs>[]
      orderHistory: Prisma.$OrderHistoryPayload<ExtArgs>[]
      shipping: Prisma.$ShippingPayload<ExtArgs> | null
      ReturnExchange: Prisma.$ReturnExchangePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      totalValue: Prisma.Decimal
      trackingCode: string
      createdAt: Date
      updatedAt: Date
      sendDate: Date
      deliveryDate: Date
      minimumDeliveryForeast: Date
      maximumDeliveryForeast: Date
      usedCoupon: boolean
      userId: number
      orderStatusId: number
      deliveryAddressId: number
    }, ExtArgs["result"]["orders"]>
    composites: {}
  }

  type OrdersGetPayload<S extends boolean | null | undefined | OrdersDefaultArgs> = $Result.GetResult<Prisma.$OrdersPayload, S>

  type OrdersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrdersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrdersCountAggregateInputType | true
    }

  export interface OrdersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Orders'], meta: { name: 'Orders' } }
    /**
     * Find zero or one Orders that matches the filter.
     * @param {OrdersFindUniqueArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrdersFindUniqueArgs>(args: SelectSubset<T, OrdersFindUniqueArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Orders that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrdersFindUniqueOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrdersFindUniqueOrThrowArgs>(args: SelectSubset<T, OrdersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindFirstArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrdersFindFirstArgs>(args?: SelectSubset<T, OrdersFindFirstArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindFirstOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrdersFindFirstOrThrowArgs>(args?: SelectSubset<T, OrdersFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.orders.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.orders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ordersWithIdOnly = await prisma.orders.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrdersFindManyArgs>(args?: SelectSubset<T, OrdersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Orders.
     * @param {OrdersCreateArgs} args - Arguments to create a Orders.
     * @example
     * // Create one Orders
     * const Orders = await prisma.orders.create({
     *   data: {
     *     // ... data to create a Orders
     *   }
     * })
     * 
     */
    create<T extends OrdersCreateArgs>(args: SelectSubset<T, OrdersCreateArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrdersCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const orders = await prisma.orders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrdersCreateManyArgs>(args?: SelectSubset<T, OrdersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Orders.
     * @param {OrdersDeleteArgs} args - Arguments to delete one Orders.
     * @example
     * // Delete one Orders
     * const Orders = await prisma.orders.delete({
     *   where: {
     *     // ... filter to delete one Orders
     *   }
     * })
     * 
     */
    delete<T extends OrdersDeleteArgs>(args: SelectSubset<T, OrdersDeleteArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Orders.
     * @param {OrdersUpdateArgs} args - Arguments to update one Orders.
     * @example
     * // Update one Orders
     * const orders = await prisma.orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrdersUpdateArgs>(args: SelectSubset<T, OrdersUpdateArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrdersDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrdersDeleteManyArgs>(args?: SelectSubset<T, OrdersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrdersUpdateManyArgs>(args: SelectSubset<T, OrdersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Orders.
     * @param {OrdersUpsertArgs} args - Arguments to update or create a Orders.
     * @example
     * // Update or create a Orders
     * const orders = await prisma.orders.upsert({
     *   create: {
     *     // ... data to create a Orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orders we want to update
     *   }
     * })
     */
    upsert<T extends OrdersUpsertArgs>(args: SelectSubset<T, OrdersUpsertArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.orders.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrdersCountArgs>(
      args?: Subset<T, OrdersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdersAggregateArgs>(args: Subset<T, OrdersAggregateArgs>): Prisma.PrismaPromise<GetOrdersAggregateType<T>>

    /**
     * Group by Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrdersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrdersGroupByArgs['orderBy'] }
        : { orderBy?: OrdersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrdersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Orders model
   */
  readonly fields: OrdersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrdersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderStatus<T extends OrderStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderStatusDefaultArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deliveryAddress<T extends AddressesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddressesDefaultArgs<ExtArgs>>): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usedCoupons<T extends Orders$usedCouponsArgs<ExtArgs> = {}>(args?: Subset<T, Orders$usedCouponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserUsedCouponsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends Orders$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Orders$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderHistory<T extends Orders$orderHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Orders$orderHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shipping<T extends Orders$shippingArgs<ExtArgs> = {}>(args?: Subset<T, Orders$shippingArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ReturnExchange<T extends Orders$ReturnExchangeArgs<ExtArgs> = {}>(args?: Subset<T, Orders$ReturnExchangeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnExchangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Orders model
   */
  interface OrdersFieldRefs {
    readonly id: FieldRef<"Orders", 'Int'>
    readonly totalValue: FieldRef<"Orders", 'Decimal'>
    readonly trackingCode: FieldRef<"Orders", 'String'>
    readonly createdAt: FieldRef<"Orders", 'DateTime'>
    readonly updatedAt: FieldRef<"Orders", 'DateTime'>
    readonly sendDate: FieldRef<"Orders", 'DateTime'>
    readonly deliveryDate: FieldRef<"Orders", 'DateTime'>
    readonly minimumDeliveryForeast: FieldRef<"Orders", 'DateTime'>
    readonly maximumDeliveryForeast: FieldRef<"Orders", 'DateTime'>
    readonly usedCoupon: FieldRef<"Orders", 'Boolean'>
    readonly userId: FieldRef<"Orders", 'Int'>
    readonly orderStatusId: FieldRef<"Orders", 'Int'>
    readonly deliveryAddressId: FieldRef<"Orders", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Orders findUnique
   */
  export type OrdersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders findUniqueOrThrow
   */
  export type OrdersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders findFirst
   */
  export type OrdersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Orders findFirstOrThrow
   */
  export type OrdersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Orders findMany
   */
  export type OrdersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Orders create
   */
  export type OrdersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * The data needed to create a Orders.
     */
    data: XOR<OrdersCreateInput, OrdersUncheckedCreateInput>
  }

  /**
   * Orders createMany
   */
  export type OrdersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrdersCreateManyInput | OrdersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Orders update
   */
  export type OrdersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * The data needed to update a Orders.
     */
    data: XOR<OrdersUpdateInput, OrdersUncheckedUpdateInput>
    /**
     * Choose, which Orders to update.
     */
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders updateMany
   */
  export type OrdersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrdersWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Orders upsert
   */
  export type OrdersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * The filter to search for the Orders to update in case it exists.
     */
    where: OrdersWhereUniqueInput
    /**
     * In case the Orders found by the `where` argument doesn't exist, create a new Orders with this data.
     */
    create: XOR<OrdersCreateInput, OrdersUncheckedCreateInput>
    /**
     * In case the Orders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrdersUpdateInput, OrdersUncheckedUpdateInput>
  }

  /**
   * Orders delete
   */
  export type OrdersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter which Orders to delete.
     */
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders deleteMany
   */
  export type OrdersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrdersWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Orders.usedCoupons
   */
  export type Orders$usedCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUsedCoupons
     */
    select?: UserUsedCouponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUsedCoupons
     */
    omit?: UserUsedCouponsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUsedCouponsInclude<ExtArgs> | null
    where?: UserUsedCouponsWhereInput
    orderBy?: UserUsedCouponsOrderByWithRelationInput | UserUsedCouponsOrderByWithRelationInput[]
    cursor?: UserUsedCouponsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserUsedCouponsScalarFieldEnum | UserUsedCouponsScalarFieldEnum[]
  }

  /**
   * Orders.orderItems
   */
  export type Orders$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    where?: OrderItemsWhereInput
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    cursor?: OrderItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemsScalarFieldEnum | OrderItemsScalarFieldEnum[]
  }

  /**
   * Orders.orderHistory
   */
  export type Orders$orderHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHistory
     */
    omit?: OrderHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    where?: OrderHistoryWhereInput
    orderBy?: OrderHistoryOrderByWithRelationInput | OrderHistoryOrderByWithRelationInput[]
    cursor?: OrderHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderHistoryScalarFieldEnum | OrderHistoryScalarFieldEnum[]
  }

  /**
   * Orders.shipping
   */
  export type Orders$shippingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    where?: ShippingWhereInput
  }

  /**
   * Orders.ReturnExchange
   */
  export type Orders$ReturnExchangeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnExchange
     */
    select?: ReturnExchangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnExchange
     */
    omit?: ReturnExchangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnExchangeInclude<ExtArgs> | null
    where?: ReturnExchangeWhereInput
    orderBy?: ReturnExchangeOrderByWithRelationInput | ReturnExchangeOrderByWithRelationInput[]
    cursor?: ReturnExchangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnExchangeScalarFieldEnum | ReturnExchangeScalarFieldEnum[]
  }

  /**
   * Orders without action
   */
  export type OrdersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
  }


  /**
   * Model OrderHistory
   */

  export type AggregateOrderHistory = {
    _count: OrderHistoryCountAggregateOutputType | null
    _avg: OrderHistoryAvgAggregateOutputType | null
    _sum: OrderHistorySumAggregateOutputType | null
    _min: OrderHistoryMinAggregateOutputType | null
    _max: OrderHistoryMaxAggregateOutputType | null
  }

  export type OrderHistoryAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
  }

  export type OrderHistorySumAggregateOutputType = {
    id: number | null
    orderId: number | null
  }

  export type OrderHistoryMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    action: string | null
    updatedAt: Date | null
  }

  export type OrderHistoryMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    action: string | null
    updatedAt: Date | null
  }

  export type OrderHistoryCountAggregateOutputType = {
    id: number
    orderId: number
    action: number
    updatedAt: number
    _all: number
  }


  export type OrderHistoryAvgAggregateInputType = {
    id?: true
    orderId?: true
  }

  export type OrderHistorySumAggregateInputType = {
    id?: true
    orderId?: true
  }

  export type OrderHistoryMinAggregateInputType = {
    id?: true
    orderId?: true
    action?: true
    updatedAt?: true
  }

  export type OrderHistoryMaxAggregateInputType = {
    id?: true
    orderId?: true
    action?: true
    updatedAt?: true
  }

  export type OrderHistoryCountAggregateInputType = {
    id?: true
    orderId?: true
    action?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderHistory to aggregate.
     */
    where?: OrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHistories to fetch.
     */
    orderBy?: OrderHistoryOrderByWithRelationInput | OrderHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderHistories
    **/
    _count?: true | OrderHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderHistoryMaxAggregateInputType
  }

  export type GetOrderHistoryAggregateType<T extends OrderHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderHistory[P]>
      : GetScalarType<T[P], AggregateOrderHistory[P]>
  }




  export type OrderHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderHistoryWhereInput
    orderBy?: OrderHistoryOrderByWithAggregationInput | OrderHistoryOrderByWithAggregationInput[]
    by: OrderHistoryScalarFieldEnum[] | OrderHistoryScalarFieldEnum
    having?: OrderHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderHistoryCountAggregateInputType | true
    _avg?: OrderHistoryAvgAggregateInputType
    _sum?: OrderHistorySumAggregateInputType
    _min?: OrderHistoryMinAggregateInputType
    _max?: OrderHistoryMaxAggregateInputType
  }

  export type OrderHistoryGroupByOutputType = {
    id: number
    orderId: number
    action: string
    updatedAt: Date
    _count: OrderHistoryCountAggregateOutputType | null
    _avg: OrderHistoryAvgAggregateOutputType | null
    _sum: OrderHistorySumAggregateOutputType | null
    _min: OrderHistoryMinAggregateOutputType | null
    _max: OrderHistoryMaxAggregateOutputType | null
  }

  type GetOrderHistoryGroupByPayload<T extends OrderHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], OrderHistoryGroupByOutputType[P]>
        }
      >
    >


  export type OrderHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    action?: boolean
    updatedAt?: boolean
    order?: boolean | OrdersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderHistory"]>



  export type OrderHistorySelectScalar = {
    id?: boolean
    orderId?: boolean
    action?: boolean
    updatedAt?: boolean
  }

  export type OrderHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "action" | "updatedAt", ExtArgs["result"]["orderHistory"]>
  export type OrderHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrdersDefaultArgs<ExtArgs>
  }

  export type $OrderHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderHistory"
    objects: {
      order: Prisma.$OrdersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      action: string
      updatedAt: Date
    }, ExtArgs["result"]["orderHistory"]>
    composites: {}
  }

  type OrderHistoryGetPayload<S extends boolean | null | undefined | OrderHistoryDefaultArgs> = $Result.GetResult<Prisma.$OrderHistoryPayload, S>

  type OrderHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderHistoryCountAggregateInputType | true
    }

  export interface OrderHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderHistory'], meta: { name: 'OrderHistory' } }
    /**
     * Find zero or one OrderHistory that matches the filter.
     * @param {OrderHistoryFindUniqueArgs} args - Arguments to find a OrderHistory
     * @example
     * // Get one OrderHistory
     * const orderHistory = await prisma.orderHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderHistoryFindUniqueArgs>(args: SelectSubset<T, OrderHistoryFindUniqueArgs<ExtArgs>>): Prisma__OrderHistoryClient<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderHistoryFindUniqueOrThrowArgs} args - Arguments to find a OrderHistory
     * @example
     * // Get one OrderHistory
     * const orderHistory = await prisma.orderHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderHistoryClient<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoryFindFirstArgs} args - Arguments to find a OrderHistory
     * @example
     * // Get one OrderHistory
     * const orderHistory = await prisma.orderHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderHistoryFindFirstArgs>(args?: SelectSubset<T, OrderHistoryFindFirstArgs<ExtArgs>>): Prisma__OrderHistoryClient<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoryFindFirstOrThrowArgs} args - Arguments to find a OrderHistory
     * @example
     * // Get one OrderHistory
     * const orderHistory = await prisma.orderHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderHistoryClient<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderHistories
     * const orderHistories = await prisma.orderHistory.findMany()
     * 
     * // Get first 10 OrderHistories
     * const orderHistories = await prisma.orderHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderHistoryWithIdOnly = await prisma.orderHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderHistoryFindManyArgs>(args?: SelectSubset<T, OrderHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderHistory.
     * @param {OrderHistoryCreateArgs} args - Arguments to create a OrderHistory.
     * @example
     * // Create one OrderHistory
     * const OrderHistory = await prisma.orderHistory.create({
     *   data: {
     *     // ... data to create a OrderHistory
     *   }
     * })
     * 
     */
    create<T extends OrderHistoryCreateArgs>(args: SelectSubset<T, OrderHistoryCreateArgs<ExtArgs>>): Prisma__OrderHistoryClient<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderHistories.
     * @param {OrderHistoryCreateManyArgs} args - Arguments to create many OrderHistories.
     * @example
     * // Create many OrderHistories
     * const orderHistory = await prisma.orderHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderHistoryCreateManyArgs>(args?: SelectSubset<T, OrderHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderHistory.
     * @param {OrderHistoryDeleteArgs} args - Arguments to delete one OrderHistory.
     * @example
     * // Delete one OrderHistory
     * const OrderHistory = await prisma.orderHistory.delete({
     *   where: {
     *     // ... filter to delete one OrderHistory
     *   }
     * })
     * 
     */
    delete<T extends OrderHistoryDeleteArgs>(args: SelectSubset<T, OrderHistoryDeleteArgs<ExtArgs>>): Prisma__OrderHistoryClient<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderHistory.
     * @param {OrderHistoryUpdateArgs} args - Arguments to update one OrderHistory.
     * @example
     * // Update one OrderHistory
     * const orderHistory = await prisma.orderHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderHistoryUpdateArgs>(args: SelectSubset<T, OrderHistoryUpdateArgs<ExtArgs>>): Prisma__OrderHistoryClient<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderHistories.
     * @param {OrderHistoryDeleteManyArgs} args - Arguments to filter OrderHistories to delete.
     * @example
     * // Delete a few OrderHistories
     * const { count } = await prisma.orderHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderHistoryDeleteManyArgs>(args?: SelectSubset<T, OrderHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderHistories
     * const orderHistory = await prisma.orderHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderHistoryUpdateManyArgs>(args: SelectSubset<T, OrderHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderHistory.
     * @param {OrderHistoryUpsertArgs} args - Arguments to update or create a OrderHistory.
     * @example
     * // Update or create a OrderHistory
     * const orderHistory = await prisma.orderHistory.upsert({
     *   create: {
     *     // ... data to create a OrderHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderHistory we want to update
     *   }
     * })
     */
    upsert<T extends OrderHistoryUpsertArgs>(args: SelectSubset<T, OrderHistoryUpsertArgs<ExtArgs>>): Prisma__OrderHistoryClient<$Result.GetResult<Prisma.$OrderHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoryCountArgs} args - Arguments to filter OrderHistories to count.
     * @example
     * // Count the number of OrderHistories
     * const count = await prisma.orderHistory.count({
     *   where: {
     *     // ... the filter for the OrderHistories we want to count
     *   }
     * })
    **/
    count<T extends OrderHistoryCountArgs>(
      args?: Subset<T, OrderHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderHistoryAggregateArgs>(args: Subset<T, OrderHistoryAggregateArgs>): Prisma.PrismaPromise<GetOrderHistoryAggregateType<T>>

    /**
     * Group by OrderHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderHistoryGroupByArgs['orderBy'] }
        : { orderBy?: OrderHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderHistory model
   */
  readonly fields: OrderHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrdersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrdersDefaultArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderHistory model
   */
  interface OrderHistoryFieldRefs {
    readonly id: FieldRef<"OrderHistory", 'Int'>
    readonly orderId: FieldRef<"OrderHistory", 'Int'>
    readonly action: FieldRef<"OrderHistory", 'String'>
    readonly updatedAt: FieldRef<"OrderHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderHistory findUnique
   */
  export type OrderHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHistory
     */
    omit?: OrderHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OrderHistory to fetch.
     */
    where: OrderHistoryWhereUniqueInput
  }

  /**
   * OrderHistory findUniqueOrThrow
   */
  export type OrderHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHistory
     */
    omit?: OrderHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OrderHistory to fetch.
     */
    where: OrderHistoryWhereUniqueInput
  }

  /**
   * OrderHistory findFirst
   */
  export type OrderHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHistory
     */
    omit?: OrderHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OrderHistory to fetch.
     */
    where?: OrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHistories to fetch.
     */
    orderBy?: OrderHistoryOrderByWithRelationInput | OrderHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderHistories.
     */
    cursor?: OrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderHistories.
     */
    distinct?: OrderHistoryScalarFieldEnum | OrderHistoryScalarFieldEnum[]
  }

  /**
   * OrderHistory findFirstOrThrow
   */
  export type OrderHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHistory
     */
    omit?: OrderHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OrderHistory to fetch.
     */
    where?: OrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHistories to fetch.
     */
    orderBy?: OrderHistoryOrderByWithRelationInput | OrderHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderHistories.
     */
    cursor?: OrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderHistories.
     */
    distinct?: OrderHistoryScalarFieldEnum | OrderHistoryScalarFieldEnum[]
  }

  /**
   * OrderHistory findMany
   */
  export type OrderHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHistory
     */
    omit?: OrderHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OrderHistories to fetch.
     */
    where?: OrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderHistories to fetch.
     */
    orderBy?: OrderHistoryOrderByWithRelationInput | OrderHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderHistories.
     */
    cursor?: OrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderHistories.
     */
    skip?: number
    distinct?: OrderHistoryScalarFieldEnum | OrderHistoryScalarFieldEnum[]
  }

  /**
   * OrderHistory create
   */
  export type OrderHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHistory
     */
    omit?: OrderHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderHistory.
     */
    data: XOR<OrderHistoryCreateInput, OrderHistoryUncheckedCreateInput>
  }

  /**
   * OrderHistory createMany
   */
  export type OrderHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderHistories.
     */
    data: OrderHistoryCreateManyInput | OrderHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderHistory update
   */
  export type OrderHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHistory
     */
    omit?: OrderHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderHistory.
     */
    data: XOR<OrderHistoryUpdateInput, OrderHistoryUncheckedUpdateInput>
    /**
     * Choose, which OrderHistory to update.
     */
    where: OrderHistoryWhereUniqueInput
  }

  /**
   * OrderHistory updateMany
   */
  export type OrderHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderHistories.
     */
    data: XOR<OrderHistoryUpdateManyMutationInput, OrderHistoryUncheckedUpdateManyInput>
    /**
     * Filter which OrderHistories to update
     */
    where?: OrderHistoryWhereInput
    /**
     * Limit how many OrderHistories to update.
     */
    limit?: number
  }

  /**
   * OrderHistory upsert
   */
  export type OrderHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHistory
     */
    omit?: OrderHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderHistory to update in case it exists.
     */
    where: OrderHistoryWhereUniqueInput
    /**
     * In case the OrderHistory found by the `where` argument doesn't exist, create a new OrderHistory with this data.
     */
    create: XOR<OrderHistoryCreateInput, OrderHistoryUncheckedCreateInput>
    /**
     * In case the OrderHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderHistoryUpdateInput, OrderHistoryUncheckedUpdateInput>
  }

  /**
   * OrderHistory delete
   */
  export type OrderHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHistory
     */
    omit?: OrderHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHistoryInclude<ExtArgs> | null
    /**
     * Filter which OrderHistory to delete.
     */
    where: OrderHistoryWhereUniqueInput
  }

  /**
   * OrderHistory deleteMany
   */
  export type OrderHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderHistories to delete
     */
    where?: OrderHistoryWhereInput
    /**
     * Limit how many OrderHistories to delete.
     */
    limit?: number
  }

  /**
   * OrderHistory without action
   */
  export type OrderHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderHistory
     */
    select?: OrderHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderHistory
     */
    omit?: OrderHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderHistoryInclude<ExtArgs> | null
  }


  /**
   * Model OrderItems
   */

  export type AggregateOrderItems = {
    _count: OrderItemsCountAggregateOutputType | null
    _avg: OrderItemsAvgAggregateOutputType | null
    _sum: OrderItemsSumAggregateOutputType | null
    _min: OrderItemsMinAggregateOutputType | null
    _max: OrderItemsMaxAggregateOutputType | null
  }

  export type OrderItemsAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    storeId: number | null
    quantity: number | null
    price: Decimal | null
  }

  export type OrderItemsSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    storeId: number | null
    quantity: number | null
    price: Decimal | null
  }

  export type OrderItemsMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    storeId: number | null
    quantity: number | null
    price: Decimal | null
  }

  export type OrderItemsMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    storeId: number | null
    quantity: number | null
    price: Decimal | null
  }

  export type OrderItemsCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    storeId: number
    quantity: number
    price: number
    _all: number
  }


  export type OrderItemsAvgAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    storeId?: true
    quantity?: true
    price?: true
  }

  export type OrderItemsSumAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    storeId?: true
    quantity?: true
    price?: true
  }

  export type OrderItemsMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    storeId?: true
    quantity?: true
    price?: true
  }

  export type OrderItemsMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    storeId?: true
    quantity?: true
    price?: true
  }

  export type OrderItemsCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    storeId?: true
    quantity?: true
    price?: true
    _all?: true
  }

  export type OrderItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to aggregate.
     */
    where?: OrderItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemsMaxAggregateInputType
  }

  export type GetOrderItemsAggregateType<T extends OrderItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItems[P]>
      : GetScalarType<T[P], AggregateOrderItems[P]>
  }




  export type OrderItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemsWhereInput
    orderBy?: OrderItemsOrderByWithAggregationInput | OrderItemsOrderByWithAggregationInput[]
    by: OrderItemsScalarFieldEnum[] | OrderItemsScalarFieldEnum
    having?: OrderItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemsCountAggregateInputType | true
    _avg?: OrderItemsAvgAggregateInputType
    _sum?: OrderItemsSumAggregateInputType
    _min?: OrderItemsMinAggregateInputType
    _max?: OrderItemsMaxAggregateInputType
  }

  export type OrderItemsGroupByOutputType = {
    id: number
    orderId: number
    productId: number
    storeId: number
    quantity: number
    price: Decimal
    _count: OrderItemsCountAggregateOutputType | null
    _avg: OrderItemsAvgAggregateOutputType | null
    _sum: OrderItemsSumAggregateOutputType | null
    _min: OrderItemsMinAggregateOutputType | null
    _max: OrderItemsMaxAggregateOutputType | null
  }

  type GetOrderItemsGroupByPayload<T extends OrderItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemsGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemsGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    storeId?: boolean
    quantity?: boolean
    price?: boolean
    order?: boolean | OrdersDefaultArgs<ExtArgs>
    product?: boolean | ProductsDefaultArgs<ExtArgs>
    store?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItems"]>



  export type OrderItemsSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    storeId?: boolean
    quantity?: boolean
    price?: boolean
  }

  export type OrderItemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "storeId" | "quantity" | "price", ExtArgs["result"]["orderItems"]>
  export type OrderItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrdersDefaultArgs<ExtArgs>
    product?: boolean | ProductsDefaultArgs<ExtArgs>
    store?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $OrderItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItems"
    objects: {
      order: Prisma.$OrdersPayload<ExtArgs>
      product: Prisma.$ProductsPayload<ExtArgs>
      store: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      productId: number
      storeId: number
      quantity: number
      price: Prisma.Decimal
    }, ExtArgs["result"]["orderItems"]>
    composites: {}
  }

  type OrderItemsGetPayload<S extends boolean | null | undefined | OrderItemsDefaultArgs> = $Result.GetResult<Prisma.$OrderItemsPayload, S>

  type OrderItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemsCountAggregateInputType | true
    }

  export interface OrderItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItems'], meta: { name: 'OrderItems' } }
    /**
     * Find zero or one OrderItems that matches the filter.
     * @param {OrderItemsFindUniqueArgs} args - Arguments to find a OrderItems
     * @example
     * // Get one OrderItems
     * const orderItems = await prisma.orderItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemsFindUniqueArgs>(args: SelectSubset<T, OrderItemsFindUniqueArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemsFindUniqueOrThrowArgs} args - Arguments to find a OrderItems
     * @example
     * // Get one OrderItems
     * const orderItems = await prisma.orderItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsFindFirstArgs} args - Arguments to find a OrderItems
     * @example
     * // Get one OrderItems
     * const orderItems = await prisma.orderItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemsFindFirstArgs>(args?: SelectSubset<T, OrderItemsFindFirstArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsFindFirstOrThrowArgs} args - Arguments to find a OrderItems
     * @example
     * // Get one OrderItems
     * const orderItems = await prisma.orderItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItems.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemsWithIdOnly = await prisma.orderItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemsFindManyArgs>(args?: SelectSubset<T, OrderItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItems.
     * @param {OrderItemsCreateArgs} args - Arguments to create a OrderItems.
     * @example
     * // Create one OrderItems
     * const OrderItems = await prisma.orderItems.create({
     *   data: {
     *     // ... data to create a OrderItems
     *   }
     * })
     * 
     */
    create<T extends OrderItemsCreateArgs>(args: SelectSubset<T, OrderItemsCreateArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemsCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItems = await prisma.orderItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemsCreateManyArgs>(args?: SelectSubset<T, OrderItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderItems.
     * @param {OrderItemsDeleteArgs} args - Arguments to delete one OrderItems.
     * @example
     * // Delete one OrderItems
     * const OrderItems = await prisma.orderItems.delete({
     *   where: {
     *     // ... filter to delete one OrderItems
     *   }
     * })
     * 
     */
    delete<T extends OrderItemsDeleteArgs>(args: SelectSubset<T, OrderItemsDeleteArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItems.
     * @param {OrderItemsUpdateArgs} args - Arguments to update one OrderItems.
     * @example
     * // Update one OrderItems
     * const orderItems = await prisma.orderItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemsUpdateArgs>(args: SelectSubset<T, OrderItemsUpdateArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemsDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemsDeleteManyArgs>(args?: SelectSubset<T, OrderItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItems = await prisma.orderItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemsUpdateManyArgs>(args: SelectSubset<T, OrderItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItems.
     * @param {OrderItemsUpsertArgs} args - Arguments to update or create a OrderItems.
     * @example
     * // Update or create a OrderItems
     * const orderItems = await prisma.orderItems.upsert({
     *   create: {
     *     // ... data to create a OrderItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItems we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemsUpsertArgs>(args: SelectSubset<T, OrderItemsUpsertArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItems.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemsCountArgs>(
      args?: Subset<T, OrderItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemsAggregateArgs>(args: Subset<T, OrderItemsAggregateArgs>): Prisma.PrismaPromise<GetOrderItemsAggregateType<T>>

    /**
     * Group by OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemsGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItems model
   */
  readonly fields: OrderItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrdersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrdersDefaultArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductsDefaultArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    store<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItems model
   */
  interface OrderItemsFieldRefs {
    readonly id: FieldRef<"OrderItems", 'Int'>
    readonly orderId: FieldRef<"OrderItems", 'Int'>
    readonly productId: FieldRef<"OrderItems", 'Int'>
    readonly storeId: FieldRef<"OrderItems", 'Int'>
    readonly quantity: FieldRef<"OrderItems", 'Int'>
    readonly price: FieldRef<"OrderItems", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * OrderItems findUnique
   */
  export type OrderItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where: OrderItemsWhereUniqueInput
  }

  /**
   * OrderItems findUniqueOrThrow
   */
  export type OrderItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where: OrderItemsWhereUniqueInput
  }

  /**
   * OrderItems findFirst
   */
  export type OrderItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemsScalarFieldEnum | OrderItemsScalarFieldEnum[]
  }

  /**
   * OrderItems findFirstOrThrow
   */
  export type OrderItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemsScalarFieldEnum | OrderItemsScalarFieldEnum[]
  }

  /**
   * OrderItems findMany
   */
  export type OrderItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemsScalarFieldEnum | OrderItemsScalarFieldEnum[]
  }

  /**
   * OrderItems create
   */
  export type OrderItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItems.
     */
    data: XOR<OrderItemsCreateInput, OrderItemsUncheckedCreateInput>
  }

  /**
   * OrderItems createMany
   */
  export type OrderItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemsCreateManyInput | OrderItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItems update
   */
  export type OrderItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItems.
     */
    data: XOR<OrderItemsUpdateInput, OrderItemsUncheckedUpdateInput>
    /**
     * Choose, which OrderItems to update.
     */
    where: OrderItemsWhereUniqueInput
  }

  /**
   * OrderItems updateMany
   */
  export type OrderItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemsUpdateManyMutationInput, OrderItemsUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemsWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItems upsert
   */
  export type OrderItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItems to update in case it exists.
     */
    where: OrderItemsWhereUniqueInput
    /**
     * In case the OrderItems found by the `where` argument doesn't exist, create a new OrderItems with this data.
     */
    create: XOR<OrderItemsCreateInput, OrderItemsUncheckedCreateInput>
    /**
     * In case the OrderItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemsUpdateInput, OrderItemsUncheckedUpdateInput>
  }

  /**
   * OrderItems delete
   */
  export type OrderItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter which OrderItems to delete.
     */
    where: OrderItemsWhereUniqueInput
  }

  /**
   * OrderItems deleteMany
   */
  export type OrderItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemsWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItems without action
   */
  export type OrderItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItems
     */
    omit?: OrderItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
  }


  /**
   * Model Shipping
   */

  export type AggregateShipping = {
    _count: ShippingCountAggregateOutputType | null
    _avg: ShippingAvgAggregateOutputType | null
    _sum: ShippingSumAggregateOutputType | null
    _min: ShippingMinAggregateOutputType | null
    _max: ShippingMaxAggregateOutputType | null
  }

  export type ShippingAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    shippingCost: Decimal | null
  }

  export type ShippingSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    shippingCost: Decimal | null
  }

  export type ShippingMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    shippingMethod: string | null
    shippingCost: Decimal | null
    estimatedDelivery: Date | null
    trackingCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    shippingMethod: string | null
    shippingCost: Decimal | null
    estimatedDelivery: Date | null
    trackingCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingCountAggregateOutputType = {
    id: number
    orderId: number
    shippingMethod: number
    shippingCost: number
    estimatedDelivery: number
    trackingCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShippingAvgAggregateInputType = {
    id?: true
    orderId?: true
    shippingCost?: true
  }

  export type ShippingSumAggregateInputType = {
    id?: true
    orderId?: true
    shippingCost?: true
  }

  export type ShippingMinAggregateInputType = {
    id?: true
    orderId?: true
    shippingMethod?: true
    shippingCost?: true
    estimatedDelivery?: true
    trackingCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingMaxAggregateInputType = {
    id?: true
    orderId?: true
    shippingMethod?: true
    shippingCost?: true
    estimatedDelivery?: true
    trackingCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingCountAggregateInputType = {
    id?: true
    orderId?: true
    shippingMethod?: true
    shippingCost?: true
    estimatedDelivery?: true
    trackingCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShippingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shipping to aggregate.
     */
    where?: ShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shippings to fetch.
     */
    orderBy?: ShippingOrderByWithRelationInput | ShippingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shippings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shippings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shippings
    **/
    _count?: true | ShippingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShippingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShippingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShippingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShippingMaxAggregateInputType
  }

  export type GetShippingAggregateType<T extends ShippingAggregateArgs> = {
        [P in keyof T & keyof AggregateShipping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShipping[P]>
      : GetScalarType<T[P], AggregateShipping[P]>
  }




  export type ShippingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingWhereInput
    orderBy?: ShippingOrderByWithAggregationInput | ShippingOrderByWithAggregationInput[]
    by: ShippingScalarFieldEnum[] | ShippingScalarFieldEnum
    having?: ShippingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShippingCountAggregateInputType | true
    _avg?: ShippingAvgAggregateInputType
    _sum?: ShippingSumAggregateInputType
    _min?: ShippingMinAggregateInputType
    _max?: ShippingMaxAggregateInputType
  }

  export type ShippingGroupByOutputType = {
    id: number
    orderId: number
    shippingMethod: string
    shippingCost: Decimal
    estimatedDelivery: Date
    trackingCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShippingCountAggregateOutputType | null
    _avg: ShippingAvgAggregateOutputType | null
    _sum: ShippingSumAggregateOutputType | null
    _min: ShippingMinAggregateOutputType | null
    _max: ShippingMaxAggregateOutputType | null
  }

  type GetShippingGroupByPayload<T extends ShippingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShippingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShippingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShippingGroupByOutputType[P]>
            : GetScalarType<T[P], ShippingGroupByOutputType[P]>
        }
      >
    >


  export type ShippingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    shippingMethod?: boolean
    shippingCost?: boolean
    estimatedDelivery?: boolean
    trackingCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrdersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipping"]>



  export type ShippingSelectScalar = {
    id?: boolean
    orderId?: boolean
    shippingMethod?: boolean
    shippingCost?: boolean
    estimatedDelivery?: boolean
    trackingCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShippingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "shippingMethod" | "shippingCost" | "estimatedDelivery" | "trackingCode" | "createdAt" | "updatedAt", ExtArgs["result"]["shipping"]>
  export type ShippingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrdersDefaultArgs<ExtArgs>
  }

  export type $ShippingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shipping"
    objects: {
      order: Prisma.$OrdersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      shippingMethod: string
      shippingCost: Prisma.Decimal
      estimatedDelivery: Date
      trackingCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shipping"]>
    composites: {}
  }

  type ShippingGetPayload<S extends boolean | null | undefined | ShippingDefaultArgs> = $Result.GetResult<Prisma.$ShippingPayload, S>

  type ShippingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShippingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShippingCountAggregateInputType | true
    }

  export interface ShippingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shipping'], meta: { name: 'Shipping' } }
    /**
     * Find zero or one Shipping that matches the filter.
     * @param {ShippingFindUniqueArgs} args - Arguments to find a Shipping
     * @example
     * // Get one Shipping
     * const shipping = await prisma.shipping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShippingFindUniqueArgs>(args: SelectSubset<T, ShippingFindUniqueArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shipping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShippingFindUniqueOrThrowArgs} args - Arguments to find a Shipping
     * @example
     * // Get one Shipping
     * const shipping = await prisma.shipping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShippingFindUniqueOrThrowArgs>(args: SelectSubset<T, ShippingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shipping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingFindFirstArgs} args - Arguments to find a Shipping
     * @example
     * // Get one Shipping
     * const shipping = await prisma.shipping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShippingFindFirstArgs>(args?: SelectSubset<T, ShippingFindFirstArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shipping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingFindFirstOrThrowArgs} args - Arguments to find a Shipping
     * @example
     * // Get one Shipping
     * const shipping = await prisma.shipping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShippingFindFirstOrThrowArgs>(args?: SelectSubset<T, ShippingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shippings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shippings
     * const shippings = await prisma.shipping.findMany()
     * 
     * // Get first 10 Shippings
     * const shippings = await prisma.shipping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shippingWithIdOnly = await prisma.shipping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShippingFindManyArgs>(args?: SelectSubset<T, ShippingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shipping.
     * @param {ShippingCreateArgs} args - Arguments to create a Shipping.
     * @example
     * // Create one Shipping
     * const Shipping = await prisma.shipping.create({
     *   data: {
     *     // ... data to create a Shipping
     *   }
     * })
     * 
     */
    create<T extends ShippingCreateArgs>(args: SelectSubset<T, ShippingCreateArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shippings.
     * @param {ShippingCreateManyArgs} args - Arguments to create many Shippings.
     * @example
     * // Create many Shippings
     * const shipping = await prisma.shipping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShippingCreateManyArgs>(args?: SelectSubset<T, ShippingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shipping.
     * @param {ShippingDeleteArgs} args - Arguments to delete one Shipping.
     * @example
     * // Delete one Shipping
     * const Shipping = await prisma.shipping.delete({
     *   where: {
     *     // ... filter to delete one Shipping
     *   }
     * })
     * 
     */
    delete<T extends ShippingDeleteArgs>(args: SelectSubset<T, ShippingDeleteArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shipping.
     * @param {ShippingUpdateArgs} args - Arguments to update one Shipping.
     * @example
     * // Update one Shipping
     * const shipping = await prisma.shipping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShippingUpdateArgs>(args: SelectSubset<T, ShippingUpdateArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shippings.
     * @param {ShippingDeleteManyArgs} args - Arguments to filter Shippings to delete.
     * @example
     * // Delete a few Shippings
     * const { count } = await prisma.shipping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShippingDeleteManyArgs>(args?: SelectSubset<T, ShippingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shippings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shippings
     * const shipping = await prisma.shipping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShippingUpdateManyArgs>(args: SelectSubset<T, ShippingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shipping.
     * @param {ShippingUpsertArgs} args - Arguments to update or create a Shipping.
     * @example
     * // Update or create a Shipping
     * const shipping = await prisma.shipping.upsert({
     *   create: {
     *     // ... data to create a Shipping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shipping we want to update
     *   }
     * })
     */
    upsert<T extends ShippingUpsertArgs>(args: SelectSubset<T, ShippingUpsertArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shippings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingCountArgs} args - Arguments to filter Shippings to count.
     * @example
     * // Count the number of Shippings
     * const count = await prisma.shipping.count({
     *   where: {
     *     // ... the filter for the Shippings we want to count
     *   }
     * })
    **/
    count<T extends ShippingCountArgs>(
      args?: Subset<T, ShippingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShippingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shipping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShippingAggregateArgs>(args: Subset<T, ShippingAggregateArgs>): Prisma.PrismaPromise<GetShippingAggregateType<T>>

    /**
     * Group by Shipping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShippingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShippingGroupByArgs['orderBy'] }
        : { orderBy?: ShippingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShippingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShippingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shipping model
   */
  readonly fields: ShippingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shipping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShippingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrdersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrdersDefaultArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shipping model
   */
  interface ShippingFieldRefs {
    readonly id: FieldRef<"Shipping", 'Int'>
    readonly orderId: FieldRef<"Shipping", 'Int'>
    readonly shippingMethod: FieldRef<"Shipping", 'String'>
    readonly shippingCost: FieldRef<"Shipping", 'Decimal'>
    readonly estimatedDelivery: FieldRef<"Shipping", 'DateTime'>
    readonly trackingCode: FieldRef<"Shipping", 'String'>
    readonly createdAt: FieldRef<"Shipping", 'DateTime'>
    readonly updatedAt: FieldRef<"Shipping", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shipping findUnique
   */
  export type ShippingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * Filter, which Shipping to fetch.
     */
    where: ShippingWhereUniqueInput
  }

  /**
   * Shipping findUniqueOrThrow
   */
  export type ShippingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * Filter, which Shipping to fetch.
     */
    where: ShippingWhereUniqueInput
  }

  /**
   * Shipping findFirst
   */
  export type ShippingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * Filter, which Shipping to fetch.
     */
    where?: ShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shippings to fetch.
     */
    orderBy?: ShippingOrderByWithRelationInput | ShippingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shippings.
     */
    cursor?: ShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shippings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shippings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shippings.
     */
    distinct?: ShippingScalarFieldEnum | ShippingScalarFieldEnum[]
  }

  /**
   * Shipping findFirstOrThrow
   */
  export type ShippingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * Filter, which Shipping to fetch.
     */
    where?: ShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shippings to fetch.
     */
    orderBy?: ShippingOrderByWithRelationInput | ShippingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shippings.
     */
    cursor?: ShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shippings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shippings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shippings.
     */
    distinct?: ShippingScalarFieldEnum | ShippingScalarFieldEnum[]
  }

  /**
   * Shipping findMany
   */
  export type ShippingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * Filter, which Shippings to fetch.
     */
    where?: ShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shippings to fetch.
     */
    orderBy?: ShippingOrderByWithRelationInput | ShippingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shippings.
     */
    cursor?: ShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shippings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shippings.
     */
    skip?: number
    distinct?: ShippingScalarFieldEnum | ShippingScalarFieldEnum[]
  }

  /**
   * Shipping create
   */
  export type ShippingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * The data needed to create a Shipping.
     */
    data: XOR<ShippingCreateInput, ShippingUncheckedCreateInput>
  }

  /**
   * Shipping createMany
   */
  export type ShippingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shippings.
     */
    data: ShippingCreateManyInput | ShippingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shipping update
   */
  export type ShippingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * The data needed to update a Shipping.
     */
    data: XOR<ShippingUpdateInput, ShippingUncheckedUpdateInput>
    /**
     * Choose, which Shipping to update.
     */
    where: ShippingWhereUniqueInput
  }

  /**
   * Shipping updateMany
   */
  export type ShippingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shippings.
     */
    data: XOR<ShippingUpdateManyMutationInput, ShippingUncheckedUpdateManyInput>
    /**
     * Filter which Shippings to update
     */
    where?: ShippingWhereInput
    /**
     * Limit how many Shippings to update.
     */
    limit?: number
  }

  /**
   * Shipping upsert
   */
  export type ShippingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * The filter to search for the Shipping to update in case it exists.
     */
    where: ShippingWhereUniqueInput
    /**
     * In case the Shipping found by the `where` argument doesn't exist, create a new Shipping with this data.
     */
    create: XOR<ShippingCreateInput, ShippingUncheckedCreateInput>
    /**
     * In case the Shipping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShippingUpdateInput, ShippingUncheckedUpdateInput>
  }

  /**
   * Shipping delete
   */
  export type ShippingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * Filter which Shipping to delete.
     */
    where: ShippingWhereUniqueInput
  }

  /**
   * Shipping deleteMany
   */
  export type ShippingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shippings to delete
     */
    where?: ShippingWhereInput
    /**
     * Limit how many Shippings to delete.
     */
    limit?: number
  }

  /**
   * Shipping without action
   */
  export type ShippingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _avg: ChatAvgAggregateOutputType | null
    _sum: ChatSumAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    storeId: number | null
  }

  export type ChatSumAggregateOutputType = {
    id: number | null
    userId: number | null
    storeId: number | null
  }

  export type ChatMinAggregateOutputType = {
    id: number | null
    userId: number | null
    storeId: number | null
  }

  export type ChatMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    storeId: number | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    userId: number
    storeId: number
    _all: number
  }


  export type ChatAvgAggregateInputType = {
    id?: true
    userId?: true
    storeId?: true
  }

  export type ChatSumAggregateInputType = {
    id?: true
    userId?: true
    storeId?: true
  }

  export type ChatMinAggregateInputType = {
    id?: true
    userId?: true
    storeId?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    userId?: true
    storeId?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    userId?: true
    storeId?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _avg?: ChatAvgAggregateInputType
    _sum?: ChatSumAggregateInputType
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: number
    userId: number
    storeId: number
    _count: ChatCountAggregateOutputType | null
    _avg: ChatAvgAggregateOutputType | null
    _sum: ChatSumAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    storeId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | StoresDefaultArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>



  export type ChatSelectScalar = {
    id?: boolean
    userId?: boolean
    storeId?: boolean
  }

  export type ChatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "storeId", ExtArgs["result"]["chat"]>
  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | StoresDefaultArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      store: Prisma.$StoresPayload<ExtArgs>
      messages: Prisma.$chatMessagesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      storeId: number
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    store<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends Chat$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Chat$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatMessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'Int'>
    readonly userId: FieldRef<"Chat", 'Int'>
    readonly storeId: FieldRef<"Chat", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to delete.
     */
    limit?: number
  }

  /**
   * Chat.messages
   */
  export type Chat$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatMessages
     */
    select?: chatMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatMessages
     */
    omit?: chatMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatMessagesInclude<ExtArgs> | null
    where?: chatMessagesWhereInput
    orderBy?: chatMessagesOrderByWithRelationInput | chatMessagesOrderByWithRelationInput[]
    cursor?: chatMessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessagesScalarFieldEnum | ChatMessagesScalarFieldEnum[]
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model chatMessages
   */

  export type AggregateChatMessages = {
    _count: ChatMessagesCountAggregateOutputType | null
    _avg: ChatMessagesAvgAggregateOutputType | null
    _sum: ChatMessagesSumAggregateOutputType | null
    _min: ChatMessagesMinAggregateOutputType | null
    _max: ChatMessagesMaxAggregateOutputType | null
  }

  export type ChatMessagesAvgAggregateOutputType = {
    id: number | null
    chatId: number | null
    senderUserId: number | null
    senderStoreId: number | null
    receiverUserId: number | null
    receiverStoreId: number | null
    imageId: number | null
  }

  export type ChatMessagesSumAggregateOutputType = {
    id: number | null
    chatId: number | null
    senderUserId: number | null
    senderStoreId: number | null
    receiverUserId: number | null
    receiverStoreId: number | null
    imageId: number | null
  }

  export type ChatMessagesMinAggregateOutputType = {
    id: number | null
    content: string | null
    chatId: number | null
    senderUserId: number | null
    senderStoreId: number | null
    receiverUserId: number | null
    receiverStoreId: number | null
    imageId: number | null
    sentAt: Date | null
    receivedAt: Date | null
    wasReceived: boolean | null
    readAt: Date | null
    wasRead: boolean | null
  }

  export type ChatMessagesMaxAggregateOutputType = {
    id: number | null
    content: string | null
    chatId: number | null
    senderUserId: number | null
    senderStoreId: number | null
    receiverUserId: number | null
    receiverStoreId: number | null
    imageId: number | null
    sentAt: Date | null
    receivedAt: Date | null
    wasReceived: boolean | null
    readAt: Date | null
    wasRead: boolean | null
  }

  export type ChatMessagesCountAggregateOutputType = {
    id: number
    content: number
    chatId: number
    senderUserId: number
    senderStoreId: number
    receiverUserId: number
    receiverStoreId: number
    imageId: number
    sentAt: number
    receivedAt: number
    wasReceived: number
    readAt: number
    wasRead: number
    _all: number
  }


  export type ChatMessagesAvgAggregateInputType = {
    id?: true
    chatId?: true
    senderUserId?: true
    senderStoreId?: true
    receiverUserId?: true
    receiverStoreId?: true
    imageId?: true
  }

  export type ChatMessagesSumAggregateInputType = {
    id?: true
    chatId?: true
    senderUserId?: true
    senderStoreId?: true
    receiverUserId?: true
    receiverStoreId?: true
    imageId?: true
  }

  export type ChatMessagesMinAggregateInputType = {
    id?: true
    content?: true
    chatId?: true
    senderUserId?: true
    senderStoreId?: true
    receiverUserId?: true
    receiverStoreId?: true
    imageId?: true
    sentAt?: true
    receivedAt?: true
    wasReceived?: true
    readAt?: true
    wasRead?: true
  }

  export type ChatMessagesMaxAggregateInputType = {
    id?: true
    content?: true
    chatId?: true
    senderUserId?: true
    senderStoreId?: true
    receiverUserId?: true
    receiverStoreId?: true
    imageId?: true
    sentAt?: true
    receivedAt?: true
    wasReceived?: true
    readAt?: true
    wasRead?: true
  }

  export type ChatMessagesCountAggregateInputType = {
    id?: true
    content?: true
    chatId?: true
    senderUserId?: true
    senderStoreId?: true
    receiverUserId?: true
    receiverStoreId?: true
    imageId?: true
    sentAt?: true
    receivedAt?: true
    wasReceived?: true
    readAt?: true
    wasRead?: true
    _all?: true
  }

  export type ChatMessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatMessages to aggregate.
     */
    where?: chatMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatMessages to fetch.
     */
    orderBy?: chatMessagesOrderByWithRelationInput | chatMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chatMessages
    **/
    _count?: true | ChatMessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatMessagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatMessagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessagesMaxAggregateInputType
  }

  export type GetChatMessagesAggregateType<T extends ChatMessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessages[P]>
      : GetScalarType<T[P], AggregateChatMessages[P]>
  }




  export type chatMessagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatMessagesWhereInput
    orderBy?: chatMessagesOrderByWithAggregationInput | chatMessagesOrderByWithAggregationInput[]
    by: ChatMessagesScalarFieldEnum[] | ChatMessagesScalarFieldEnum
    having?: chatMessagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessagesCountAggregateInputType | true
    _avg?: ChatMessagesAvgAggregateInputType
    _sum?: ChatMessagesSumAggregateInputType
    _min?: ChatMessagesMinAggregateInputType
    _max?: ChatMessagesMaxAggregateInputType
  }

  export type ChatMessagesGroupByOutputType = {
    id: number
    content: string
    chatId: number
    senderUserId: number | null
    senderStoreId: number | null
    receiverUserId: number | null
    receiverStoreId: number | null
    imageId: number | null
    sentAt: Date
    receivedAt: Date | null
    wasReceived: boolean
    readAt: Date | null
    wasRead: boolean
    _count: ChatMessagesCountAggregateOutputType | null
    _avg: ChatMessagesAvgAggregateOutputType | null
    _sum: ChatMessagesSumAggregateOutputType | null
    _min: ChatMessagesMinAggregateOutputType | null
    _max: ChatMessagesMaxAggregateOutputType | null
  }

  type GetChatMessagesGroupByPayload<T extends chatMessagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessagesGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessagesGroupByOutputType[P]>
        }
      >
    >


  export type chatMessagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    chatId?: boolean
    senderUserId?: boolean
    senderStoreId?: boolean
    receiverUserId?: boolean
    receiverStoreId?: boolean
    imageId?: boolean
    sentAt?: boolean
    receivedAt?: boolean
    wasReceived?: boolean
    readAt?: boolean
    wasRead?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    senderUser?: boolean | chatMessages$senderUserArgs<ExtArgs>
    senderStore?: boolean | chatMessages$senderStoreArgs<ExtArgs>
    receiverUser?: boolean | chatMessages$receiverUserArgs<ExtArgs>
    receiverStore?: boolean | chatMessages$receiverStoreArgs<ExtArgs>
    image?: boolean | chatMessages$imageArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessages"]>



  export type chatMessagesSelectScalar = {
    id?: boolean
    content?: boolean
    chatId?: boolean
    senderUserId?: boolean
    senderStoreId?: boolean
    receiverUserId?: boolean
    receiverStoreId?: boolean
    imageId?: boolean
    sentAt?: boolean
    receivedAt?: boolean
    wasReceived?: boolean
    readAt?: boolean
    wasRead?: boolean
  }

  export type chatMessagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "chatId" | "senderUserId" | "senderStoreId" | "receiverUserId" | "receiverStoreId" | "imageId" | "sentAt" | "receivedAt" | "wasReceived" | "readAt" | "wasRead", ExtArgs["result"]["chatMessages"]>
  export type chatMessagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    senderUser?: boolean | chatMessages$senderUserArgs<ExtArgs>
    senderStore?: boolean | chatMessages$senderStoreArgs<ExtArgs>
    receiverUser?: boolean | chatMessages$receiverUserArgs<ExtArgs>
    receiverStore?: boolean | chatMessages$receiverStoreArgs<ExtArgs>
    image?: boolean | chatMessages$imageArgs<ExtArgs>
  }

  export type $chatMessagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chatMessages"
    objects: {
      chat: Prisma.$ChatPayload<ExtArgs>
      senderUser: Prisma.$UserPayload<ExtArgs> | null
      senderStore: Prisma.$StoresPayload<ExtArgs> | null
      receiverUser: Prisma.$UserPayload<ExtArgs> | null
      receiverStore: Prisma.$StoresPayload<ExtArgs> | null
      image: Prisma.$MessageImagesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string
      chatId: number
      senderUserId: number | null
      senderStoreId: number | null
      receiverUserId: number | null
      receiverStoreId: number | null
      imageId: number | null
      sentAt: Date
      receivedAt: Date | null
      wasReceived: boolean
      readAt: Date | null
      wasRead: boolean
    }, ExtArgs["result"]["chatMessages"]>
    composites: {}
  }

  type chatMessagesGetPayload<S extends boolean | null | undefined | chatMessagesDefaultArgs> = $Result.GetResult<Prisma.$chatMessagesPayload, S>

  type chatMessagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chatMessagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessagesCountAggregateInputType | true
    }

  export interface chatMessagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chatMessages'], meta: { name: 'chatMessages' } }
    /**
     * Find zero or one ChatMessages that matches the filter.
     * @param {chatMessagesFindUniqueArgs} args - Arguments to find a ChatMessages
     * @example
     * // Get one ChatMessages
     * const chatMessages = await prisma.chatMessages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatMessagesFindUniqueArgs>(args: SelectSubset<T, chatMessagesFindUniqueArgs<ExtArgs>>): Prisma__chatMessagesClient<$Result.GetResult<Prisma.$chatMessagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chatMessagesFindUniqueOrThrowArgs} args - Arguments to find a ChatMessages
     * @example
     * // Get one ChatMessages
     * const chatMessages = await prisma.chatMessages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatMessagesFindUniqueOrThrowArgs>(args: SelectSubset<T, chatMessagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatMessagesClient<$Result.GetResult<Prisma.$chatMessagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatMessagesFindFirstArgs} args - Arguments to find a ChatMessages
     * @example
     * // Get one ChatMessages
     * const chatMessages = await prisma.chatMessages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatMessagesFindFirstArgs>(args?: SelectSubset<T, chatMessagesFindFirstArgs<ExtArgs>>): Prisma__chatMessagesClient<$Result.GetResult<Prisma.$chatMessagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatMessagesFindFirstOrThrowArgs} args - Arguments to find a ChatMessages
     * @example
     * // Get one ChatMessages
     * const chatMessages = await prisma.chatMessages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatMessagesFindFirstOrThrowArgs>(args?: SelectSubset<T, chatMessagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatMessagesClient<$Result.GetResult<Prisma.$chatMessagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatMessagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessages.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessagesWithIdOnly = await prisma.chatMessages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chatMessagesFindManyArgs>(args?: SelectSubset<T, chatMessagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatMessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessages.
     * @param {chatMessagesCreateArgs} args - Arguments to create a ChatMessages.
     * @example
     * // Create one ChatMessages
     * const ChatMessages = await prisma.chatMessages.create({
     *   data: {
     *     // ... data to create a ChatMessages
     *   }
     * })
     * 
     */
    create<T extends chatMessagesCreateArgs>(args: SelectSubset<T, chatMessagesCreateArgs<ExtArgs>>): Prisma__chatMessagesClient<$Result.GetResult<Prisma.$chatMessagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {chatMessagesCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessages = await prisma.chatMessages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatMessagesCreateManyArgs>(args?: SelectSubset<T, chatMessagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChatMessages.
     * @param {chatMessagesDeleteArgs} args - Arguments to delete one ChatMessages.
     * @example
     * // Delete one ChatMessages
     * const ChatMessages = await prisma.chatMessages.delete({
     *   where: {
     *     // ... filter to delete one ChatMessages
     *   }
     * })
     * 
     */
    delete<T extends chatMessagesDeleteArgs>(args: SelectSubset<T, chatMessagesDeleteArgs<ExtArgs>>): Prisma__chatMessagesClient<$Result.GetResult<Prisma.$chatMessagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessages.
     * @param {chatMessagesUpdateArgs} args - Arguments to update one ChatMessages.
     * @example
     * // Update one ChatMessages
     * const chatMessages = await prisma.chatMessages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatMessagesUpdateArgs>(args: SelectSubset<T, chatMessagesUpdateArgs<ExtArgs>>): Prisma__chatMessagesClient<$Result.GetResult<Prisma.$chatMessagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {chatMessagesDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatMessagesDeleteManyArgs>(args?: SelectSubset<T, chatMessagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatMessagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessages = await prisma.chatMessages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatMessagesUpdateManyArgs>(args: SelectSubset<T, chatMessagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatMessages.
     * @param {chatMessagesUpsertArgs} args - Arguments to update or create a ChatMessages.
     * @example
     * // Update or create a ChatMessages
     * const chatMessages = await prisma.chatMessages.upsert({
     *   create: {
     *     // ... data to create a ChatMessages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessages we want to update
     *   }
     * })
     */
    upsert<T extends chatMessagesUpsertArgs>(args: SelectSubset<T, chatMessagesUpsertArgs<ExtArgs>>): Prisma__chatMessagesClient<$Result.GetResult<Prisma.$chatMessagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatMessagesCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessages.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends chatMessagesCountArgs>(
      args?: Subset<T, chatMessagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessagesAggregateArgs>(args: Subset<T, ChatMessagesAggregateArgs>): Prisma.PrismaPromise<GetChatMessagesAggregateType<T>>

    /**
     * Group by ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatMessagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatMessagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatMessagesGroupByArgs['orderBy'] }
        : { orderBy?: chatMessagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatMessagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chatMessages model
   */
  readonly fields: chatMessagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chatMessages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatMessagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    senderUser<T extends chatMessages$senderUserArgs<ExtArgs> = {}>(args?: Subset<T, chatMessages$senderUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    senderStore<T extends chatMessages$senderStoreArgs<ExtArgs> = {}>(args?: Subset<T, chatMessages$senderStoreArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    receiverUser<T extends chatMessages$receiverUserArgs<ExtArgs> = {}>(args?: Subset<T, chatMessages$receiverUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    receiverStore<T extends chatMessages$receiverStoreArgs<ExtArgs> = {}>(args?: Subset<T, chatMessages$receiverStoreArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    image<T extends chatMessages$imageArgs<ExtArgs> = {}>(args?: Subset<T, chatMessages$imageArgs<ExtArgs>>): Prisma__MessageImagesClient<$Result.GetResult<Prisma.$MessageImagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chatMessages model
   */
  interface chatMessagesFieldRefs {
    readonly id: FieldRef<"chatMessages", 'Int'>
    readonly content: FieldRef<"chatMessages", 'String'>
    readonly chatId: FieldRef<"chatMessages", 'Int'>
    readonly senderUserId: FieldRef<"chatMessages", 'Int'>
    readonly senderStoreId: FieldRef<"chatMessages", 'Int'>
    readonly receiverUserId: FieldRef<"chatMessages", 'Int'>
    readonly receiverStoreId: FieldRef<"chatMessages", 'Int'>
    readonly imageId: FieldRef<"chatMessages", 'Int'>
    readonly sentAt: FieldRef<"chatMessages", 'DateTime'>
    readonly receivedAt: FieldRef<"chatMessages", 'DateTime'>
    readonly wasReceived: FieldRef<"chatMessages", 'Boolean'>
    readonly readAt: FieldRef<"chatMessages", 'DateTime'>
    readonly wasRead: FieldRef<"chatMessages", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * chatMessages findUnique
   */
  export type chatMessagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatMessages
     */
    select?: chatMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatMessages
     */
    omit?: chatMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatMessagesInclude<ExtArgs> | null
    /**
     * Filter, which chatMessages to fetch.
     */
    where: chatMessagesWhereUniqueInput
  }

  /**
   * chatMessages findUniqueOrThrow
   */
  export type chatMessagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatMessages
     */
    select?: chatMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatMessages
     */
    omit?: chatMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatMessagesInclude<ExtArgs> | null
    /**
     * Filter, which chatMessages to fetch.
     */
    where: chatMessagesWhereUniqueInput
  }

  /**
   * chatMessages findFirst
   */
  export type chatMessagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatMessages
     */
    select?: chatMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatMessages
     */
    omit?: chatMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatMessagesInclude<ExtArgs> | null
    /**
     * Filter, which chatMessages to fetch.
     */
    where?: chatMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatMessages to fetch.
     */
    orderBy?: chatMessagesOrderByWithRelationInput | chatMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatMessages.
     */
    cursor?: chatMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatMessages.
     */
    distinct?: ChatMessagesScalarFieldEnum | ChatMessagesScalarFieldEnum[]
  }

  /**
   * chatMessages findFirstOrThrow
   */
  export type chatMessagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatMessages
     */
    select?: chatMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatMessages
     */
    omit?: chatMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatMessagesInclude<ExtArgs> | null
    /**
     * Filter, which chatMessages to fetch.
     */
    where?: chatMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatMessages to fetch.
     */
    orderBy?: chatMessagesOrderByWithRelationInput | chatMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatMessages.
     */
    cursor?: chatMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatMessages.
     */
    distinct?: ChatMessagesScalarFieldEnum | ChatMessagesScalarFieldEnum[]
  }

  /**
   * chatMessages findMany
   */
  export type chatMessagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatMessages
     */
    select?: chatMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatMessages
     */
    omit?: chatMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatMessagesInclude<ExtArgs> | null
    /**
     * Filter, which chatMessages to fetch.
     */
    where?: chatMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatMessages to fetch.
     */
    orderBy?: chatMessagesOrderByWithRelationInput | chatMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chatMessages.
     */
    cursor?: chatMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatMessages.
     */
    skip?: number
    distinct?: ChatMessagesScalarFieldEnum | ChatMessagesScalarFieldEnum[]
  }

  /**
   * chatMessages create
   */
  export type chatMessagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatMessages
     */
    select?: chatMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatMessages
     */
    omit?: chatMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatMessagesInclude<ExtArgs> | null
    /**
     * The data needed to create a chatMessages.
     */
    data: XOR<chatMessagesCreateInput, chatMessagesUncheckedCreateInput>
  }

  /**
   * chatMessages createMany
   */
  export type chatMessagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chatMessages.
     */
    data: chatMessagesCreateManyInput | chatMessagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chatMessages update
   */
  export type chatMessagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatMessages
     */
    select?: chatMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatMessages
     */
    omit?: chatMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatMessagesInclude<ExtArgs> | null
    /**
     * The data needed to update a chatMessages.
     */
    data: XOR<chatMessagesUpdateInput, chatMessagesUncheckedUpdateInput>
    /**
     * Choose, which chatMessages to update.
     */
    where: chatMessagesWhereUniqueInput
  }

  /**
   * chatMessages updateMany
   */
  export type chatMessagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chatMessages.
     */
    data: XOR<chatMessagesUpdateManyMutationInput, chatMessagesUncheckedUpdateManyInput>
    /**
     * Filter which chatMessages to update
     */
    where?: chatMessagesWhereInput
    /**
     * Limit how many chatMessages to update.
     */
    limit?: number
  }

  /**
   * chatMessages upsert
   */
  export type chatMessagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatMessages
     */
    select?: chatMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatMessages
     */
    omit?: chatMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatMessagesInclude<ExtArgs> | null
    /**
     * The filter to search for the chatMessages to update in case it exists.
     */
    where: chatMessagesWhereUniqueInput
    /**
     * In case the chatMessages found by the `where` argument doesn't exist, create a new chatMessages with this data.
     */
    create: XOR<chatMessagesCreateInput, chatMessagesUncheckedCreateInput>
    /**
     * In case the chatMessages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatMessagesUpdateInput, chatMessagesUncheckedUpdateInput>
  }

  /**
   * chatMessages delete
   */
  export type chatMessagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatMessages
     */
    select?: chatMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatMessages
     */
    omit?: chatMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatMessagesInclude<ExtArgs> | null
    /**
     * Filter which chatMessages to delete.
     */
    where: chatMessagesWhereUniqueInput
  }

  /**
   * chatMessages deleteMany
   */
  export type chatMessagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatMessages to delete
     */
    where?: chatMessagesWhereInput
    /**
     * Limit how many chatMessages to delete.
     */
    limit?: number
  }

  /**
   * chatMessages.senderUser
   */
  export type chatMessages$senderUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * chatMessages.senderStore
   */
  export type chatMessages$senderStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    where?: StoresWhereInput
  }

  /**
   * chatMessages.receiverUser
   */
  export type chatMessages$receiverUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * chatMessages.receiverStore
   */
  export type chatMessages$receiverStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    where?: StoresWhereInput
  }

  /**
   * chatMessages.image
   */
  export type chatMessages$imageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageImages
     */
    select?: MessageImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageImages
     */
    omit?: MessageImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageImagesInclude<ExtArgs> | null
    where?: MessageImagesWhereInput
  }

  /**
   * chatMessages without action
   */
  export type chatMessagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatMessages
     */
    select?: chatMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatMessages
     */
    omit?: chatMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatMessagesInclude<ExtArgs> | null
  }


  /**
   * Model MessageImages
   */

  export type AggregateMessageImages = {
    _count: MessageImagesCountAggregateOutputType | null
    _avg: MessageImagesAvgAggregateOutputType | null
    _sum: MessageImagesSumAggregateOutputType | null
    _min: MessageImagesMinAggregateOutputType | null
    _max: MessageImagesMaxAggregateOutputType | null
  }

  export type MessageImagesAvgAggregateOutputType = {
    id: number | null
  }

  export type MessageImagesSumAggregateOutputType = {
    id: number | null
  }

  export type MessageImagesMinAggregateOutputType = {
    id: number | null
    url: string | null
    publicId: string | null
  }

  export type MessageImagesMaxAggregateOutputType = {
    id: number | null
    url: string | null
    publicId: string | null
  }

  export type MessageImagesCountAggregateOutputType = {
    id: number
    url: number
    publicId: number
    _all: number
  }


  export type MessageImagesAvgAggregateInputType = {
    id?: true
  }

  export type MessageImagesSumAggregateInputType = {
    id?: true
  }

  export type MessageImagesMinAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
  }

  export type MessageImagesMaxAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
  }

  export type MessageImagesCountAggregateInputType = {
    id?: true
    url?: true
    publicId?: true
    _all?: true
  }

  export type MessageImagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageImages to aggregate.
     */
    where?: MessageImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageImages to fetch.
     */
    orderBy?: MessageImagesOrderByWithRelationInput | MessageImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageImages
    **/
    _count?: true | MessageImagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageImagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageImagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageImagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageImagesMaxAggregateInputType
  }

  export type GetMessageImagesAggregateType<T extends MessageImagesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageImages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageImages[P]>
      : GetScalarType<T[P], AggregateMessageImages[P]>
  }




  export type MessageImagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageImagesWhereInput
    orderBy?: MessageImagesOrderByWithAggregationInput | MessageImagesOrderByWithAggregationInput[]
    by: MessageImagesScalarFieldEnum[] | MessageImagesScalarFieldEnum
    having?: MessageImagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageImagesCountAggregateInputType | true
    _avg?: MessageImagesAvgAggregateInputType
    _sum?: MessageImagesSumAggregateInputType
    _min?: MessageImagesMinAggregateInputType
    _max?: MessageImagesMaxAggregateInputType
  }

  export type MessageImagesGroupByOutputType = {
    id: number
    url: string
    publicId: string
    _count: MessageImagesCountAggregateOutputType | null
    _avg: MessageImagesAvgAggregateOutputType | null
    _sum: MessageImagesSumAggregateOutputType | null
    _min: MessageImagesMinAggregateOutputType | null
    _max: MessageImagesMaxAggregateOutputType | null
  }

  type GetMessageImagesGroupByPayload<T extends MessageImagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageImagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageImagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageImagesGroupByOutputType[P]>
            : GetScalarType<T[P], MessageImagesGroupByOutputType[P]>
        }
      >
    >


  export type MessageImagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    publicId?: boolean
    messageImage?: boolean | MessageImages$messageImageArgs<ExtArgs>
  }, ExtArgs["result"]["messageImages"]>



  export type MessageImagesSelectScalar = {
    id?: boolean
    url?: boolean
    publicId?: boolean
  }

  export type MessageImagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "publicId", ExtArgs["result"]["messageImages"]>
  export type MessageImagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messageImage?: boolean | MessageImages$messageImageArgs<ExtArgs>
  }

  export type $MessageImagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageImages"
    objects: {
      messageImage: Prisma.$chatMessagesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      publicId: string
    }, ExtArgs["result"]["messageImages"]>
    composites: {}
  }

  type MessageImagesGetPayload<S extends boolean | null | undefined | MessageImagesDefaultArgs> = $Result.GetResult<Prisma.$MessageImagesPayload, S>

  type MessageImagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageImagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageImagesCountAggregateInputType | true
    }

  export interface MessageImagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageImages'], meta: { name: 'MessageImages' } }
    /**
     * Find zero or one MessageImages that matches the filter.
     * @param {MessageImagesFindUniqueArgs} args - Arguments to find a MessageImages
     * @example
     * // Get one MessageImages
     * const messageImages = await prisma.messageImages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageImagesFindUniqueArgs>(args: SelectSubset<T, MessageImagesFindUniqueArgs<ExtArgs>>): Prisma__MessageImagesClient<$Result.GetResult<Prisma.$MessageImagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageImages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageImagesFindUniqueOrThrowArgs} args - Arguments to find a MessageImages
     * @example
     * // Get one MessageImages
     * const messageImages = await prisma.messageImages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageImagesFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageImagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageImagesClient<$Result.GetResult<Prisma.$MessageImagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageImagesFindFirstArgs} args - Arguments to find a MessageImages
     * @example
     * // Get one MessageImages
     * const messageImages = await prisma.messageImages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageImagesFindFirstArgs>(args?: SelectSubset<T, MessageImagesFindFirstArgs<ExtArgs>>): Prisma__MessageImagesClient<$Result.GetResult<Prisma.$MessageImagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageImages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageImagesFindFirstOrThrowArgs} args - Arguments to find a MessageImages
     * @example
     * // Get one MessageImages
     * const messageImages = await prisma.messageImages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageImagesFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageImagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageImagesClient<$Result.GetResult<Prisma.$MessageImagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageImagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageImages
     * const messageImages = await prisma.messageImages.findMany()
     * 
     * // Get first 10 MessageImages
     * const messageImages = await prisma.messageImages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageImagesWithIdOnly = await prisma.messageImages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageImagesFindManyArgs>(args?: SelectSubset<T, MessageImagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageImagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageImages.
     * @param {MessageImagesCreateArgs} args - Arguments to create a MessageImages.
     * @example
     * // Create one MessageImages
     * const MessageImages = await prisma.messageImages.create({
     *   data: {
     *     // ... data to create a MessageImages
     *   }
     * })
     * 
     */
    create<T extends MessageImagesCreateArgs>(args: SelectSubset<T, MessageImagesCreateArgs<ExtArgs>>): Prisma__MessageImagesClient<$Result.GetResult<Prisma.$MessageImagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageImages.
     * @param {MessageImagesCreateManyArgs} args - Arguments to create many MessageImages.
     * @example
     * // Create many MessageImages
     * const messageImages = await prisma.messageImages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageImagesCreateManyArgs>(args?: SelectSubset<T, MessageImagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessageImages.
     * @param {MessageImagesDeleteArgs} args - Arguments to delete one MessageImages.
     * @example
     * // Delete one MessageImages
     * const MessageImages = await prisma.messageImages.delete({
     *   where: {
     *     // ... filter to delete one MessageImages
     *   }
     * })
     * 
     */
    delete<T extends MessageImagesDeleteArgs>(args: SelectSubset<T, MessageImagesDeleteArgs<ExtArgs>>): Prisma__MessageImagesClient<$Result.GetResult<Prisma.$MessageImagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageImages.
     * @param {MessageImagesUpdateArgs} args - Arguments to update one MessageImages.
     * @example
     * // Update one MessageImages
     * const messageImages = await prisma.messageImages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageImagesUpdateArgs>(args: SelectSubset<T, MessageImagesUpdateArgs<ExtArgs>>): Prisma__MessageImagesClient<$Result.GetResult<Prisma.$MessageImagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageImages.
     * @param {MessageImagesDeleteManyArgs} args - Arguments to filter MessageImages to delete.
     * @example
     * // Delete a few MessageImages
     * const { count } = await prisma.messageImages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageImagesDeleteManyArgs>(args?: SelectSubset<T, MessageImagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageImagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageImages
     * const messageImages = await prisma.messageImages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageImagesUpdateManyArgs>(args: SelectSubset<T, MessageImagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageImages.
     * @param {MessageImagesUpsertArgs} args - Arguments to update or create a MessageImages.
     * @example
     * // Update or create a MessageImages
     * const messageImages = await prisma.messageImages.upsert({
     *   create: {
     *     // ... data to create a MessageImages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageImages we want to update
     *   }
     * })
     */
    upsert<T extends MessageImagesUpsertArgs>(args: SelectSubset<T, MessageImagesUpsertArgs<ExtArgs>>): Prisma__MessageImagesClient<$Result.GetResult<Prisma.$MessageImagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageImagesCountArgs} args - Arguments to filter MessageImages to count.
     * @example
     * // Count the number of MessageImages
     * const count = await prisma.messageImages.count({
     *   where: {
     *     // ... the filter for the MessageImages we want to count
     *   }
     * })
    **/
    count<T extends MessageImagesCountArgs>(
      args?: Subset<T, MessageImagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageImagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageImagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageImagesAggregateArgs>(args: Subset<T, MessageImagesAggregateArgs>): Prisma.PrismaPromise<GetMessageImagesAggregateType<T>>

    /**
     * Group by MessageImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageImagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageImagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageImagesGroupByArgs['orderBy'] }
        : { orderBy?: MessageImagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageImagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageImagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageImages model
   */
  readonly fields: MessageImagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageImages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageImagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messageImage<T extends MessageImages$messageImageArgs<ExtArgs> = {}>(args?: Subset<T, MessageImages$messageImageArgs<ExtArgs>>): Prisma__chatMessagesClient<$Result.GetResult<Prisma.$chatMessagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageImages model
   */
  interface MessageImagesFieldRefs {
    readonly id: FieldRef<"MessageImages", 'Int'>
    readonly url: FieldRef<"MessageImages", 'String'>
    readonly publicId: FieldRef<"MessageImages", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MessageImages findUnique
   */
  export type MessageImagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageImages
     */
    select?: MessageImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageImages
     */
    omit?: MessageImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageImagesInclude<ExtArgs> | null
    /**
     * Filter, which MessageImages to fetch.
     */
    where: MessageImagesWhereUniqueInput
  }

  /**
   * MessageImages findUniqueOrThrow
   */
  export type MessageImagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageImages
     */
    select?: MessageImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageImages
     */
    omit?: MessageImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageImagesInclude<ExtArgs> | null
    /**
     * Filter, which MessageImages to fetch.
     */
    where: MessageImagesWhereUniqueInput
  }

  /**
   * MessageImages findFirst
   */
  export type MessageImagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageImages
     */
    select?: MessageImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageImages
     */
    omit?: MessageImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageImagesInclude<ExtArgs> | null
    /**
     * Filter, which MessageImages to fetch.
     */
    where?: MessageImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageImages to fetch.
     */
    orderBy?: MessageImagesOrderByWithRelationInput | MessageImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageImages.
     */
    cursor?: MessageImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageImages.
     */
    distinct?: MessageImagesScalarFieldEnum | MessageImagesScalarFieldEnum[]
  }

  /**
   * MessageImages findFirstOrThrow
   */
  export type MessageImagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageImages
     */
    select?: MessageImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageImages
     */
    omit?: MessageImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageImagesInclude<ExtArgs> | null
    /**
     * Filter, which MessageImages to fetch.
     */
    where?: MessageImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageImages to fetch.
     */
    orderBy?: MessageImagesOrderByWithRelationInput | MessageImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageImages.
     */
    cursor?: MessageImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageImages.
     */
    distinct?: MessageImagesScalarFieldEnum | MessageImagesScalarFieldEnum[]
  }

  /**
   * MessageImages findMany
   */
  export type MessageImagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageImages
     */
    select?: MessageImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageImages
     */
    omit?: MessageImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageImagesInclude<ExtArgs> | null
    /**
     * Filter, which MessageImages to fetch.
     */
    where?: MessageImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageImages to fetch.
     */
    orderBy?: MessageImagesOrderByWithRelationInput | MessageImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageImages.
     */
    cursor?: MessageImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageImages.
     */
    skip?: number
    distinct?: MessageImagesScalarFieldEnum | MessageImagesScalarFieldEnum[]
  }

  /**
   * MessageImages create
   */
  export type MessageImagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageImages
     */
    select?: MessageImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageImages
     */
    omit?: MessageImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageImagesInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageImages.
     */
    data: XOR<MessageImagesCreateInput, MessageImagesUncheckedCreateInput>
  }

  /**
   * MessageImages createMany
   */
  export type MessageImagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageImages.
     */
    data: MessageImagesCreateManyInput | MessageImagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageImages update
   */
  export type MessageImagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageImages
     */
    select?: MessageImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageImages
     */
    omit?: MessageImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageImagesInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageImages.
     */
    data: XOR<MessageImagesUpdateInput, MessageImagesUncheckedUpdateInput>
    /**
     * Choose, which MessageImages to update.
     */
    where: MessageImagesWhereUniqueInput
  }

  /**
   * MessageImages updateMany
   */
  export type MessageImagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageImages.
     */
    data: XOR<MessageImagesUpdateManyMutationInput, MessageImagesUncheckedUpdateManyInput>
    /**
     * Filter which MessageImages to update
     */
    where?: MessageImagesWhereInput
    /**
     * Limit how many MessageImages to update.
     */
    limit?: number
  }

  /**
   * MessageImages upsert
   */
  export type MessageImagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageImages
     */
    select?: MessageImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageImages
     */
    omit?: MessageImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageImagesInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageImages to update in case it exists.
     */
    where: MessageImagesWhereUniqueInput
    /**
     * In case the MessageImages found by the `where` argument doesn't exist, create a new MessageImages with this data.
     */
    create: XOR<MessageImagesCreateInput, MessageImagesUncheckedCreateInput>
    /**
     * In case the MessageImages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageImagesUpdateInput, MessageImagesUncheckedUpdateInput>
  }

  /**
   * MessageImages delete
   */
  export type MessageImagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageImages
     */
    select?: MessageImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageImages
     */
    omit?: MessageImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageImagesInclude<ExtArgs> | null
    /**
     * Filter which MessageImages to delete.
     */
    where: MessageImagesWhereUniqueInput
  }

  /**
   * MessageImages deleteMany
   */
  export type MessageImagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageImages to delete
     */
    where?: MessageImagesWhereInput
    /**
     * Limit how many MessageImages to delete.
     */
    limit?: number
  }

  /**
   * MessageImages.messageImage
   */
  export type MessageImages$messageImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatMessages
     */
    select?: chatMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatMessages
     */
    omit?: chatMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatMessagesInclude<ExtArgs> | null
    where?: chatMessagesWhereInput
  }

  /**
   * MessageImages without action
   */
  export type MessageImagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageImages
     */
    select?: MessageImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageImages
     */
    omit?: MessageImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageImagesInclude<ExtArgs> | null
  }


  /**
   * Model LoginToken
   */

  export type AggregateLoginToken = {
    _count: LoginTokenCountAggregateOutputType | null
    _avg: LoginTokenAvgAggregateOutputType | null
    _sum: LoginTokenSumAggregateOutputType | null
    _min: LoginTokenMinAggregateOutputType | null
    _max: LoginTokenMaxAggregateOutputType | null
  }

  export type LoginTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LoginTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LoginTokenMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
  }

  export type LoginTokenMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
  }

  export type LoginTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    _all: number
  }


  export type LoginTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LoginTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LoginTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
  }

  export type LoginTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
  }

  export type LoginTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    _all?: true
  }

  export type LoginTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginToken to aggregate.
     */
    where?: LoginTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginTokens to fetch.
     */
    orderBy?: LoginTokenOrderByWithRelationInput | LoginTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoginTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoginTokens
    **/
    _count?: true | LoginTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoginTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoginTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoginTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoginTokenMaxAggregateInputType
  }

  export type GetLoginTokenAggregateType<T extends LoginTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateLoginToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoginToken[P]>
      : GetScalarType<T[P], AggregateLoginToken[P]>
  }




  export type LoginTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginTokenWhereInput
    orderBy?: LoginTokenOrderByWithAggregationInput | LoginTokenOrderByWithAggregationInput[]
    by: LoginTokenScalarFieldEnum[] | LoginTokenScalarFieldEnum
    having?: LoginTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoginTokenCountAggregateInputType | true
    _avg?: LoginTokenAvgAggregateInputType
    _sum?: LoginTokenSumAggregateInputType
    _min?: LoginTokenMinAggregateInputType
    _max?: LoginTokenMaxAggregateInputType
  }

  export type LoginTokenGroupByOutputType = {
    id: number
    userId: number
    token: string
    _count: LoginTokenCountAggregateOutputType | null
    _avg: LoginTokenAvgAggregateOutputType | null
    _sum: LoginTokenSumAggregateOutputType | null
    _min: LoginTokenMinAggregateOutputType | null
    _max: LoginTokenMaxAggregateOutputType | null
  }

  type GetLoginTokenGroupByPayload<T extends LoginTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoginTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoginTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoginTokenGroupByOutputType[P]>
            : GetScalarType<T[P], LoginTokenGroupByOutputType[P]>
        }
      >
    >


  export type LoginTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loginToken"]>



  export type LoginTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
  }

  export type LoginTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token", ExtArgs["result"]["loginToken"]>
  export type LoginTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LoginTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoginToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
    }, ExtArgs["result"]["loginToken"]>
    composites: {}
  }

  type LoginTokenGetPayload<S extends boolean | null | undefined | LoginTokenDefaultArgs> = $Result.GetResult<Prisma.$LoginTokenPayload, S>

  type LoginTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoginTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoginTokenCountAggregateInputType | true
    }

  export interface LoginTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoginToken'], meta: { name: 'LoginToken' } }
    /**
     * Find zero or one LoginToken that matches the filter.
     * @param {LoginTokenFindUniqueArgs} args - Arguments to find a LoginToken
     * @example
     * // Get one LoginToken
     * const loginToken = await prisma.loginToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoginTokenFindUniqueArgs>(args: SelectSubset<T, LoginTokenFindUniqueArgs<ExtArgs>>): Prisma__LoginTokenClient<$Result.GetResult<Prisma.$LoginTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoginToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoginTokenFindUniqueOrThrowArgs} args - Arguments to find a LoginToken
     * @example
     * // Get one LoginToken
     * const loginToken = await prisma.loginToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoginTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, LoginTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoginTokenClient<$Result.GetResult<Prisma.$LoginTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoginToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginTokenFindFirstArgs} args - Arguments to find a LoginToken
     * @example
     * // Get one LoginToken
     * const loginToken = await prisma.loginToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoginTokenFindFirstArgs>(args?: SelectSubset<T, LoginTokenFindFirstArgs<ExtArgs>>): Prisma__LoginTokenClient<$Result.GetResult<Prisma.$LoginTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoginToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginTokenFindFirstOrThrowArgs} args - Arguments to find a LoginToken
     * @example
     * // Get one LoginToken
     * const loginToken = await prisma.loginToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoginTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, LoginTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoginTokenClient<$Result.GetResult<Prisma.$LoginTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoginTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoginTokens
     * const loginTokens = await prisma.loginToken.findMany()
     * 
     * // Get first 10 LoginTokens
     * const loginTokens = await prisma.loginToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loginTokenWithIdOnly = await prisma.loginToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoginTokenFindManyArgs>(args?: SelectSubset<T, LoginTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoginToken.
     * @param {LoginTokenCreateArgs} args - Arguments to create a LoginToken.
     * @example
     * // Create one LoginToken
     * const LoginToken = await prisma.loginToken.create({
     *   data: {
     *     // ... data to create a LoginToken
     *   }
     * })
     * 
     */
    create<T extends LoginTokenCreateArgs>(args: SelectSubset<T, LoginTokenCreateArgs<ExtArgs>>): Prisma__LoginTokenClient<$Result.GetResult<Prisma.$LoginTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoginTokens.
     * @param {LoginTokenCreateManyArgs} args - Arguments to create many LoginTokens.
     * @example
     * // Create many LoginTokens
     * const loginToken = await prisma.loginToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoginTokenCreateManyArgs>(args?: SelectSubset<T, LoginTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LoginToken.
     * @param {LoginTokenDeleteArgs} args - Arguments to delete one LoginToken.
     * @example
     * // Delete one LoginToken
     * const LoginToken = await prisma.loginToken.delete({
     *   where: {
     *     // ... filter to delete one LoginToken
     *   }
     * })
     * 
     */
    delete<T extends LoginTokenDeleteArgs>(args: SelectSubset<T, LoginTokenDeleteArgs<ExtArgs>>): Prisma__LoginTokenClient<$Result.GetResult<Prisma.$LoginTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoginToken.
     * @param {LoginTokenUpdateArgs} args - Arguments to update one LoginToken.
     * @example
     * // Update one LoginToken
     * const loginToken = await prisma.loginToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoginTokenUpdateArgs>(args: SelectSubset<T, LoginTokenUpdateArgs<ExtArgs>>): Prisma__LoginTokenClient<$Result.GetResult<Prisma.$LoginTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoginTokens.
     * @param {LoginTokenDeleteManyArgs} args - Arguments to filter LoginTokens to delete.
     * @example
     * // Delete a few LoginTokens
     * const { count } = await prisma.loginToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoginTokenDeleteManyArgs>(args?: SelectSubset<T, LoginTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoginTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoginTokens
     * const loginToken = await prisma.loginToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoginTokenUpdateManyArgs>(args: SelectSubset<T, LoginTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LoginToken.
     * @param {LoginTokenUpsertArgs} args - Arguments to update or create a LoginToken.
     * @example
     * // Update or create a LoginToken
     * const loginToken = await prisma.loginToken.upsert({
     *   create: {
     *     // ... data to create a LoginToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoginToken we want to update
     *   }
     * })
     */
    upsert<T extends LoginTokenUpsertArgs>(args: SelectSubset<T, LoginTokenUpsertArgs<ExtArgs>>): Prisma__LoginTokenClient<$Result.GetResult<Prisma.$LoginTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoginTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginTokenCountArgs} args - Arguments to filter LoginTokens to count.
     * @example
     * // Count the number of LoginTokens
     * const count = await prisma.loginToken.count({
     *   where: {
     *     // ... the filter for the LoginTokens we want to count
     *   }
     * })
    **/
    count<T extends LoginTokenCountArgs>(
      args?: Subset<T, LoginTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoginTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoginToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoginTokenAggregateArgs>(args: Subset<T, LoginTokenAggregateArgs>): Prisma.PrismaPromise<GetLoginTokenAggregateType<T>>

    /**
     * Group by LoginToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoginTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoginTokenGroupByArgs['orderBy'] }
        : { orderBy?: LoginTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoginTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoginTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoginToken model
   */
  readonly fields: LoginTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoginToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoginTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoginToken model
   */
  interface LoginTokenFieldRefs {
    readonly id: FieldRef<"LoginToken", 'Int'>
    readonly userId: FieldRef<"LoginToken", 'Int'>
    readonly token: FieldRef<"LoginToken", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LoginToken findUnique
   */
  export type LoginTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginToken
     */
    select?: LoginTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginToken
     */
    omit?: LoginTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginTokenInclude<ExtArgs> | null
    /**
     * Filter, which LoginToken to fetch.
     */
    where: LoginTokenWhereUniqueInput
  }

  /**
   * LoginToken findUniqueOrThrow
   */
  export type LoginTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginToken
     */
    select?: LoginTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginToken
     */
    omit?: LoginTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginTokenInclude<ExtArgs> | null
    /**
     * Filter, which LoginToken to fetch.
     */
    where: LoginTokenWhereUniqueInput
  }

  /**
   * LoginToken findFirst
   */
  export type LoginTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginToken
     */
    select?: LoginTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginToken
     */
    omit?: LoginTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginTokenInclude<ExtArgs> | null
    /**
     * Filter, which LoginToken to fetch.
     */
    where?: LoginTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginTokens to fetch.
     */
    orderBy?: LoginTokenOrderByWithRelationInput | LoginTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginTokens.
     */
    cursor?: LoginTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginTokens.
     */
    distinct?: LoginTokenScalarFieldEnum | LoginTokenScalarFieldEnum[]
  }

  /**
   * LoginToken findFirstOrThrow
   */
  export type LoginTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginToken
     */
    select?: LoginTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginToken
     */
    omit?: LoginTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginTokenInclude<ExtArgs> | null
    /**
     * Filter, which LoginToken to fetch.
     */
    where?: LoginTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginTokens to fetch.
     */
    orderBy?: LoginTokenOrderByWithRelationInput | LoginTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginTokens.
     */
    cursor?: LoginTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginTokens.
     */
    distinct?: LoginTokenScalarFieldEnum | LoginTokenScalarFieldEnum[]
  }

  /**
   * LoginToken findMany
   */
  export type LoginTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginToken
     */
    select?: LoginTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginToken
     */
    omit?: LoginTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginTokenInclude<ExtArgs> | null
    /**
     * Filter, which LoginTokens to fetch.
     */
    where?: LoginTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginTokens to fetch.
     */
    orderBy?: LoginTokenOrderByWithRelationInput | LoginTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoginTokens.
     */
    cursor?: LoginTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginTokens.
     */
    skip?: number
    distinct?: LoginTokenScalarFieldEnum | LoginTokenScalarFieldEnum[]
  }

  /**
   * LoginToken create
   */
  export type LoginTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginToken
     */
    select?: LoginTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginToken
     */
    omit?: LoginTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a LoginToken.
     */
    data: XOR<LoginTokenCreateInput, LoginTokenUncheckedCreateInput>
  }

  /**
   * LoginToken createMany
   */
  export type LoginTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoginTokens.
     */
    data: LoginTokenCreateManyInput | LoginTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoginToken update
   */
  export type LoginTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginToken
     */
    select?: LoginTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginToken
     */
    omit?: LoginTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a LoginToken.
     */
    data: XOR<LoginTokenUpdateInput, LoginTokenUncheckedUpdateInput>
    /**
     * Choose, which LoginToken to update.
     */
    where: LoginTokenWhereUniqueInput
  }

  /**
   * LoginToken updateMany
   */
  export type LoginTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoginTokens.
     */
    data: XOR<LoginTokenUpdateManyMutationInput, LoginTokenUncheckedUpdateManyInput>
    /**
     * Filter which LoginTokens to update
     */
    where?: LoginTokenWhereInput
    /**
     * Limit how many LoginTokens to update.
     */
    limit?: number
  }

  /**
   * LoginToken upsert
   */
  export type LoginTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginToken
     */
    select?: LoginTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginToken
     */
    omit?: LoginTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the LoginToken to update in case it exists.
     */
    where: LoginTokenWhereUniqueInput
    /**
     * In case the LoginToken found by the `where` argument doesn't exist, create a new LoginToken with this data.
     */
    create: XOR<LoginTokenCreateInput, LoginTokenUncheckedCreateInput>
    /**
     * In case the LoginToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoginTokenUpdateInput, LoginTokenUncheckedUpdateInput>
  }

  /**
   * LoginToken delete
   */
  export type LoginTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginToken
     */
    select?: LoginTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginToken
     */
    omit?: LoginTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginTokenInclude<ExtArgs> | null
    /**
     * Filter which LoginToken to delete.
     */
    where: LoginTokenWhereUniqueInput
  }

  /**
   * LoginToken deleteMany
   */
  export type LoginTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginTokens to delete
     */
    where?: LoginTokenWhereInput
    /**
     * Limit how many LoginTokens to delete.
     */
    limit?: number
  }

  /**
   * LoginToken without action
   */
  export type LoginTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginToken
     */
    select?: LoginTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginToken
     */
    omit?: LoginTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginTokenInclude<ExtArgs> | null
  }


  /**
   * Model ConfirmationToken
   */

  export type AggregateConfirmationToken = {
    _count: ConfirmationTokenCountAggregateOutputType | null
    _avg: ConfirmationTokenAvgAggregateOutputType | null
    _sum: ConfirmationTokenSumAggregateOutputType | null
    _min: ConfirmationTokenMinAggregateOutputType | null
    _max: ConfirmationTokenMaxAggregateOutputType | null
  }

  export type ConfirmationTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ConfirmationTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ConfirmationTokenMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
  }

  export type ConfirmationTokenMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
  }

  export type ConfirmationTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    _all: number
  }


  export type ConfirmationTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ConfirmationTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ConfirmationTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
  }

  export type ConfirmationTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
  }

  export type ConfirmationTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    _all?: true
  }

  export type ConfirmationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfirmationToken to aggregate.
     */
    where?: ConfirmationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfirmationTokens to fetch.
     */
    orderBy?: ConfirmationTokenOrderByWithRelationInput | ConfirmationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfirmationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfirmationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfirmationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfirmationTokens
    **/
    _count?: true | ConfirmationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfirmationTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfirmationTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfirmationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfirmationTokenMaxAggregateInputType
  }

  export type GetConfirmationTokenAggregateType<T extends ConfirmationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateConfirmationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfirmationToken[P]>
      : GetScalarType<T[P], AggregateConfirmationToken[P]>
  }




  export type ConfirmationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfirmationTokenWhereInput
    orderBy?: ConfirmationTokenOrderByWithAggregationInput | ConfirmationTokenOrderByWithAggregationInput[]
    by: ConfirmationTokenScalarFieldEnum[] | ConfirmationTokenScalarFieldEnum
    having?: ConfirmationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfirmationTokenCountAggregateInputType | true
    _avg?: ConfirmationTokenAvgAggregateInputType
    _sum?: ConfirmationTokenSumAggregateInputType
    _min?: ConfirmationTokenMinAggregateInputType
    _max?: ConfirmationTokenMaxAggregateInputType
  }

  export type ConfirmationTokenGroupByOutputType = {
    id: number
    userId: number
    token: string
    _count: ConfirmationTokenCountAggregateOutputType | null
    _avg: ConfirmationTokenAvgAggregateOutputType | null
    _sum: ConfirmationTokenSumAggregateOutputType | null
    _min: ConfirmationTokenMinAggregateOutputType | null
    _max: ConfirmationTokenMaxAggregateOutputType | null
  }

  type GetConfirmationTokenGroupByPayload<T extends ConfirmationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfirmationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfirmationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfirmationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], ConfirmationTokenGroupByOutputType[P]>
        }
      >
    >


  export type ConfirmationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["confirmationToken"]>



  export type ConfirmationTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
  }

  export type ConfirmationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token", ExtArgs["result"]["confirmationToken"]>
  export type ConfirmationTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConfirmationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfirmationToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
    }, ExtArgs["result"]["confirmationToken"]>
    composites: {}
  }

  type ConfirmationTokenGetPayload<S extends boolean | null | undefined | ConfirmationTokenDefaultArgs> = $Result.GetResult<Prisma.$ConfirmationTokenPayload, S>

  type ConfirmationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConfirmationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConfirmationTokenCountAggregateInputType | true
    }

  export interface ConfirmationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfirmationToken'], meta: { name: 'ConfirmationToken' } }
    /**
     * Find zero or one ConfirmationToken that matches the filter.
     * @param {ConfirmationTokenFindUniqueArgs} args - Arguments to find a ConfirmationToken
     * @example
     * // Get one ConfirmationToken
     * const confirmationToken = await prisma.confirmationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfirmationTokenFindUniqueArgs>(args: SelectSubset<T, ConfirmationTokenFindUniqueArgs<ExtArgs>>): Prisma__ConfirmationTokenClient<$Result.GetResult<Prisma.$ConfirmationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConfirmationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConfirmationTokenFindUniqueOrThrowArgs} args - Arguments to find a ConfirmationToken
     * @example
     * // Get one ConfirmationToken
     * const confirmationToken = await prisma.confirmationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfirmationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfirmationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfirmationTokenClient<$Result.GetResult<Prisma.$ConfirmationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConfirmationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfirmationTokenFindFirstArgs} args - Arguments to find a ConfirmationToken
     * @example
     * // Get one ConfirmationToken
     * const confirmationToken = await prisma.confirmationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfirmationTokenFindFirstArgs>(args?: SelectSubset<T, ConfirmationTokenFindFirstArgs<ExtArgs>>): Prisma__ConfirmationTokenClient<$Result.GetResult<Prisma.$ConfirmationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConfirmationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfirmationTokenFindFirstOrThrowArgs} args - Arguments to find a ConfirmationToken
     * @example
     * // Get one ConfirmationToken
     * const confirmationToken = await prisma.confirmationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfirmationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfirmationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfirmationTokenClient<$Result.GetResult<Prisma.$ConfirmationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConfirmationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfirmationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfirmationTokens
     * const confirmationTokens = await prisma.confirmationToken.findMany()
     * 
     * // Get first 10 ConfirmationTokens
     * const confirmationTokens = await prisma.confirmationToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const confirmationTokenWithIdOnly = await prisma.confirmationToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfirmationTokenFindManyArgs>(args?: SelectSubset<T, ConfirmationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfirmationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConfirmationToken.
     * @param {ConfirmationTokenCreateArgs} args - Arguments to create a ConfirmationToken.
     * @example
     * // Create one ConfirmationToken
     * const ConfirmationToken = await prisma.confirmationToken.create({
     *   data: {
     *     // ... data to create a ConfirmationToken
     *   }
     * })
     * 
     */
    create<T extends ConfirmationTokenCreateArgs>(args: SelectSubset<T, ConfirmationTokenCreateArgs<ExtArgs>>): Prisma__ConfirmationTokenClient<$Result.GetResult<Prisma.$ConfirmationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConfirmationTokens.
     * @param {ConfirmationTokenCreateManyArgs} args - Arguments to create many ConfirmationTokens.
     * @example
     * // Create many ConfirmationTokens
     * const confirmationToken = await prisma.confirmationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfirmationTokenCreateManyArgs>(args?: SelectSubset<T, ConfirmationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConfirmationToken.
     * @param {ConfirmationTokenDeleteArgs} args - Arguments to delete one ConfirmationToken.
     * @example
     * // Delete one ConfirmationToken
     * const ConfirmationToken = await prisma.confirmationToken.delete({
     *   where: {
     *     // ... filter to delete one ConfirmationToken
     *   }
     * })
     * 
     */
    delete<T extends ConfirmationTokenDeleteArgs>(args: SelectSubset<T, ConfirmationTokenDeleteArgs<ExtArgs>>): Prisma__ConfirmationTokenClient<$Result.GetResult<Prisma.$ConfirmationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConfirmationToken.
     * @param {ConfirmationTokenUpdateArgs} args - Arguments to update one ConfirmationToken.
     * @example
     * // Update one ConfirmationToken
     * const confirmationToken = await prisma.confirmationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfirmationTokenUpdateArgs>(args: SelectSubset<T, ConfirmationTokenUpdateArgs<ExtArgs>>): Prisma__ConfirmationTokenClient<$Result.GetResult<Prisma.$ConfirmationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConfirmationTokens.
     * @param {ConfirmationTokenDeleteManyArgs} args - Arguments to filter ConfirmationTokens to delete.
     * @example
     * // Delete a few ConfirmationTokens
     * const { count } = await prisma.confirmationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfirmationTokenDeleteManyArgs>(args?: SelectSubset<T, ConfirmationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfirmationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfirmationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfirmationTokens
     * const confirmationToken = await prisma.confirmationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfirmationTokenUpdateManyArgs>(args: SelectSubset<T, ConfirmationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConfirmationToken.
     * @param {ConfirmationTokenUpsertArgs} args - Arguments to update or create a ConfirmationToken.
     * @example
     * // Update or create a ConfirmationToken
     * const confirmationToken = await prisma.confirmationToken.upsert({
     *   create: {
     *     // ... data to create a ConfirmationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfirmationToken we want to update
     *   }
     * })
     */
    upsert<T extends ConfirmationTokenUpsertArgs>(args: SelectSubset<T, ConfirmationTokenUpsertArgs<ExtArgs>>): Prisma__ConfirmationTokenClient<$Result.GetResult<Prisma.$ConfirmationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConfirmationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfirmationTokenCountArgs} args - Arguments to filter ConfirmationTokens to count.
     * @example
     * // Count the number of ConfirmationTokens
     * const count = await prisma.confirmationToken.count({
     *   where: {
     *     // ... the filter for the ConfirmationTokens we want to count
     *   }
     * })
    **/
    count<T extends ConfirmationTokenCountArgs>(
      args?: Subset<T, ConfirmationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfirmationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfirmationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfirmationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfirmationTokenAggregateArgs>(args: Subset<T, ConfirmationTokenAggregateArgs>): Prisma.PrismaPromise<GetConfirmationTokenAggregateType<T>>

    /**
     * Group by ConfirmationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfirmationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfirmationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfirmationTokenGroupByArgs['orderBy'] }
        : { orderBy?: ConfirmationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfirmationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfirmationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfirmationToken model
   */
  readonly fields: ConfirmationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfirmationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfirmationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfirmationToken model
   */
  interface ConfirmationTokenFieldRefs {
    readonly id: FieldRef<"ConfirmationToken", 'Int'>
    readonly userId: FieldRef<"ConfirmationToken", 'Int'>
    readonly token: FieldRef<"ConfirmationToken", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConfirmationToken findUnique
   */
  export type ConfirmationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmationToken
     */
    select?: ConfirmationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfirmationToken
     */
    omit?: ConfirmationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfirmationTokenInclude<ExtArgs> | null
    /**
     * Filter, which ConfirmationToken to fetch.
     */
    where: ConfirmationTokenWhereUniqueInput
  }

  /**
   * ConfirmationToken findUniqueOrThrow
   */
  export type ConfirmationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmationToken
     */
    select?: ConfirmationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfirmationToken
     */
    omit?: ConfirmationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfirmationTokenInclude<ExtArgs> | null
    /**
     * Filter, which ConfirmationToken to fetch.
     */
    where: ConfirmationTokenWhereUniqueInput
  }

  /**
   * ConfirmationToken findFirst
   */
  export type ConfirmationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmationToken
     */
    select?: ConfirmationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfirmationToken
     */
    omit?: ConfirmationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfirmationTokenInclude<ExtArgs> | null
    /**
     * Filter, which ConfirmationToken to fetch.
     */
    where?: ConfirmationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfirmationTokens to fetch.
     */
    orderBy?: ConfirmationTokenOrderByWithRelationInput | ConfirmationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfirmationTokens.
     */
    cursor?: ConfirmationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfirmationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfirmationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfirmationTokens.
     */
    distinct?: ConfirmationTokenScalarFieldEnum | ConfirmationTokenScalarFieldEnum[]
  }

  /**
   * ConfirmationToken findFirstOrThrow
   */
  export type ConfirmationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmationToken
     */
    select?: ConfirmationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfirmationToken
     */
    omit?: ConfirmationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfirmationTokenInclude<ExtArgs> | null
    /**
     * Filter, which ConfirmationToken to fetch.
     */
    where?: ConfirmationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfirmationTokens to fetch.
     */
    orderBy?: ConfirmationTokenOrderByWithRelationInput | ConfirmationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfirmationTokens.
     */
    cursor?: ConfirmationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfirmationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfirmationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfirmationTokens.
     */
    distinct?: ConfirmationTokenScalarFieldEnum | ConfirmationTokenScalarFieldEnum[]
  }

  /**
   * ConfirmationToken findMany
   */
  export type ConfirmationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmationToken
     */
    select?: ConfirmationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfirmationToken
     */
    omit?: ConfirmationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfirmationTokenInclude<ExtArgs> | null
    /**
     * Filter, which ConfirmationTokens to fetch.
     */
    where?: ConfirmationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfirmationTokens to fetch.
     */
    orderBy?: ConfirmationTokenOrderByWithRelationInput | ConfirmationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfirmationTokens.
     */
    cursor?: ConfirmationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfirmationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfirmationTokens.
     */
    skip?: number
    distinct?: ConfirmationTokenScalarFieldEnum | ConfirmationTokenScalarFieldEnum[]
  }

  /**
   * ConfirmationToken create
   */
  export type ConfirmationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmationToken
     */
    select?: ConfirmationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfirmationToken
     */
    omit?: ConfirmationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfirmationTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a ConfirmationToken.
     */
    data: XOR<ConfirmationTokenCreateInput, ConfirmationTokenUncheckedCreateInput>
  }

  /**
   * ConfirmationToken createMany
   */
  export type ConfirmationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfirmationTokens.
     */
    data: ConfirmationTokenCreateManyInput | ConfirmationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfirmationToken update
   */
  export type ConfirmationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmationToken
     */
    select?: ConfirmationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfirmationToken
     */
    omit?: ConfirmationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfirmationTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a ConfirmationToken.
     */
    data: XOR<ConfirmationTokenUpdateInput, ConfirmationTokenUncheckedUpdateInput>
    /**
     * Choose, which ConfirmationToken to update.
     */
    where: ConfirmationTokenWhereUniqueInput
  }

  /**
   * ConfirmationToken updateMany
   */
  export type ConfirmationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfirmationTokens.
     */
    data: XOR<ConfirmationTokenUpdateManyMutationInput, ConfirmationTokenUncheckedUpdateManyInput>
    /**
     * Filter which ConfirmationTokens to update
     */
    where?: ConfirmationTokenWhereInput
    /**
     * Limit how many ConfirmationTokens to update.
     */
    limit?: number
  }

  /**
   * ConfirmationToken upsert
   */
  export type ConfirmationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmationToken
     */
    select?: ConfirmationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfirmationToken
     */
    omit?: ConfirmationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfirmationTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the ConfirmationToken to update in case it exists.
     */
    where: ConfirmationTokenWhereUniqueInput
    /**
     * In case the ConfirmationToken found by the `where` argument doesn't exist, create a new ConfirmationToken with this data.
     */
    create: XOR<ConfirmationTokenCreateInput, ConfirmationTokenUncheckedCreateInput>
    /**
     * In case the ConfirmationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfirmationTokenUpdateInput, ConfirmationTokenUncheckedUpdateInput>
  }

  /**
   * ConfirmationToken delete
   */
  export type ConfirmationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmationToken
     */
    select?: ConfirmationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfirmationToken
     */
    omit?: ConfirmationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfirmationTokenInclude<ExtArgs> | null
    /**
     * Filter which ConfirmationToken to delete.
     */
    where: ConfirmationTokenWhereUniqueInput
  }

  /**
   * ConfirmationToken deleteMany
   */
  export type ConfirmationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfirmationTokens to delete
     */
    where?: ConfirmationTokenWhereInput
    /**
     * Limit how many ConfirmationTokens to delete.
     */
    limit?: number
  }

  /**
   * ConfirmationToken without action
   */
  export type ConfirmationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfirmationToken
     */
    select?: ConfirmationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfirmationToken
     */
    omit?: ConfirmationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfirmationTokenInclude<ExtArgs> | null
  }


  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogAvgAggregateOutputType = {
    id: number | null
    recordId: number | null
    userId: number | null
  }

  export type LogSumAggregateOutputType = {
    id: number | null
    recordId: number | null
    userId: number | null
  }

  export type LogMinAggregateOutputType = {
    id: number | null
    action: string | null
    tableName: string | null
    recordId: number | null
    userId: number | null
    timestamp: Date | null
    details: string | null
  }

  export type LogMaxAggregateOutputType = {
    id: number | null
    action: string | null
    tableName: string | null
    recordId: number | null
    userId: number | null
    timestamp: Date | null
    details: string | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    action: number
    tableName: number
    recordId: number
    userId: number
    timestamp: number
    details: number
    _all: number
  }


  export type LogAvgAggregateInputType = {
    id?: true
    recordId?: true
    userId?: true
  }

  export type LogSumAggregateInputType = {
    id?: true
    recordId?: true
    userId?: true
  }

  export type LogMinAggregateInputType = {
    id?: true
    action?: true
    tableName?: true
    recordId?: true
    userId?: true
    timestamp?: true
    details?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    action?: true
    tableName?: true
    recordId?: true
    userId?: true
    timestamp?: true
    details?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    action?: true
    tableName?: true
    recordId?: true
    userId?: true
    timestamp?: true
    details?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _avg?: LogAvgAggregateInputType
    _sum?: LogSumAggregateInputType
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: number
    action: string
    tableName: string
    recordId: number | null
    userId: number | null
    timestamp: Date
    details: string | null
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    tableName?: boolean
    recordId?: boolean
    userId?: boolean
    timestamp?: boolean
    details?: boolean
    user?: boolean | Log$userArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>



  export type LogSelectScalar = {
    id?: boolean
    action?: boolean
    tableName?: boolean
    recordId?: boolean
    userId?: boolean
    timestamp?: boolean
    details?: boolean
  }

  export type LogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "tableName" | "recordId" | "userId" | "timestamp" | "details", ExtArgs["result"]["log"]>
  export type LogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Log$userArgs<ExtArgs>
  }

  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      action: string
      tableName: string
      recordId: number | null
      userId: number | null
      timestamp: Date
      details: string | null
    }, ExtArgs["result"]["log"]>
    composites: {}
  }

  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogFindUniqueArgs>(args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(args: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogFindFirstArgs>(args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogFindManyArgs>(args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends LogCreateArgs>(args: SelectSubset<T, LogCreateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logs.
     * @param {LogCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogCreateManyArgs>(args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends LogDeleteArgs>(args: SelectSubset<T, LogDeleteArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogUpdateArgs>(args: SelectSubset<T, LogUpdateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogDeleteManyArgs>(args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogUpdateManyArgs>(args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends LogUpsertArgs>(args: SelectSubset<T, LogUpsertArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Log$userArgs<ExtArgs> = {}>(args?: Subset<T, Log$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Log model
   */
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'Int'>
    readonly action: FieldRef<"Log", 'String'>
    readonly tableName: FieldRef<"Log", 'String'>
    readonly recordId: FieldRef<"Log", 'Int'>
    readonly userId: FieldRef<"Log", 'Int'>
    readonly timestamp: FieldRef<"Log", 'DateTime'>
    readonly details: FieldRef<"Log", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
  }

  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
  }

  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }

  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to delete.
     */
    limit?: number
  }

  /**
   * Log.user
   */
  export type Log$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
  }


  /**
   * Model TwoFactorAuth
   */

  export type AggregateTwoFactorAuth = {
    _count: TwoFactorAuthCountAggregateOutputType | null
    _avg: TwoFactorAuthAvgAggregateOutputType | null
    _sum: TwoFactorAuthSumAggregateOutputType | null
    _min: TwoFactorAuthMinAggregateOutputType | null
    _max: TwoFactorAuthMaxAggregateOutputType | null
  }

  export type TwoFactorAuthAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TwoFactorAuthSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TwoFactorAuthMinAggregateOutputType = {
    id: number | null
    userId: number | null
    secret: string | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwoFactorAuthMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    secret: string | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwoFactorAuthCountAggregateOutputType = {
    id: number
    userId: number
    secret: number
    isEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwoFactorAuthAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TwoFactorAuthSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TwoFactorAuthMinAggregateInputType = {
    id?: true
    userId?: true
    secret?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwoFactorAuthMaxAggregateInputType = {
    id?: true
    userId?: true
    secret?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwoFactorAuthCountAggregateInputType = {
    id?: true
    userId?: true
    secret?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwoFactorAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorAuth to aggregate.
     */
    where?: TwoFactorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorAuths to fetch.
     */
    orderBy?: TwoFactorAuthOrderByWithRelationInput | TwoFactorAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwoFactorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwoFactorAuths
    **/
    _count?: true | TwoFactorAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwoFactorAuthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwoFactorAuthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwoFactorAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwoFactorAuthMaxAggregateInputType
  }

  export type GetTwoFactorAuthAggregateType<T extends TwoFactorAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateTwoFactorAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwoFactorAuth[P]>
      : GetScalarType<T[P], AggregateTwoFactorAuth[P]>
  }




  export type TwoFactorAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorAuthWhereInput
    orderBy?: TwoFactorAuthOrderByWithAggregationInput | TwoFactorAuthOrderByWithAggregationInput[]
    by: TwoFactorAuthScalarFieldEnum[] | TwoFactorAuthScalarFieldEnum
    having?: TwoFactorAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwoFactorAuthCountAggregateInputType | true
    _avg?: TwoFactorAuthAvgAggregateInputType
    _sum?: TwoFactorAuthSumAggregateInputType
    _min?: TwoFactorAuthMinAggregateInputType
    _max?: TwoFactorAuthMaxAggregateInputType
  }

  export type TwoFactorAuthGroupByOutputType = {
    id: number
    userId: number
    secret: string
    isEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: TwoFactorAuthCountAggregateOutputType | null
    _avg: TwoFactorAuthAvgAggregateOutputType | null
    _sum: TwoFactorAuthSumAggregateOutputType | null
    _min: TwoFactorAuthMinAggregateOutputType | null
    _max: TwoFactorAuthMaxAggregateOutputType | null
  }

  type GetTwoFactorAuthGroupByPayload<T extends TwoFactorAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TwoFactorAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwoFactorAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwoFactorAuthGroupByOutputType[P]>
            : GetScalarType<T[P], TwoFactorAuthGroupByOutputType[P]>
        }
      >
    >


  export type TwoFactorAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    secret?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactorAuth"]>



  export type TwoFactorAuthSelectScalar = {
    id?: boolean
    userId?: boolean
    secret?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TwoFactorAuthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "secret" | "isEnabled" | "createdAt" | "updatedAt", ExtArgs["result"]["twoFactorAuth"]>
  export type TwoFactorAuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TwoFactorAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TwoFactorAuth"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      secret: string
      isEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["twoFactorAuth"]>
    composites: {}
  }

  type TwoFactorAuthGetPayload<S extends boolean | null | undefined | TwoFactorAuthDefaultArgs> = $Result.GetResult<Prisma.$TwoFactorAuthPayload, S>

  type TwoFactorAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TwoFactorAuthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TwoFactorAuthCountAggregateInputType | true
    }

  export interface TwoFactorAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwoFactorAuth'], meta: { name: 'TwoFactorAuth' } }
    /**
     * Find zero or one TwoFactorAuth that matches the filter.
     * @param {TwoFactorAuthFindUniqueArgs} args - Arguments to find a TwoFactorAuth
     * @example
     * // Get one TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TwoFactorAuthFindUniqueArgs>(args: SelectSubset<T, TwoFactorAuthFindUniqueArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TwoFactorAuth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TwoFactorAuthFindUniqueOrThrowArgs} args - Arguments to find a TwoFactorAuth
     * @example
     * // Get one TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TwoFactorAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, TwoFactorAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwoFactorAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthFindFirstArgs} args - Arguments to find a TwoFactorAuth
     * @example
     * // Get one TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TwoFactorAuthFindFirstArgs>(args?: SelectSubset<T, TwoFactorAuthFindFirstArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwoFactorAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthFindFirstOrThrowArgs} args - Arguments to find a TwoFactorAuth
     * @example
     * // Get one TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TwoFactorAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, TwoFactorAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TwoFactorAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwoFactorAuths
     * const twoFactorAuths = await prisma.twoFactorAuth.findMany()
     * 
     * // Get first 10 TwoFactorAuths
     * const twoFactorAuths = await prisma.twoFactorAuth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twoFactorAuthWithIdOnly = await prisma.twoFactorAuth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TwoFactorAuthFindManyArgs>(args?: SelectSubset<T, TwoFactorAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TwoFactorAuth.
     * @param {TwoFactorAuthCreateArgs} args - Arguments to create a TwoFactorAuth.
     * @example
     * // Create one TwoFactorAuth
     * const TwoFactorAuth = await prisma.twoFactorAuth.create({
     *   data: {
     *     // ... data to create a TwoFactorAuth
     *   }
     * })
     * 
     */
    create<T extends TwoFactorAuthCreateArgs>(args: SelectSubset<T, TwoFactorAuthCreateArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TwoFactorAuths.
     * @param {TwoFactorAuthCreateManyArgs} args - Arguments to create many TwoFactorAuths.
     * @example
     * // Create many TwoFactorAuths
     * const twoFactorAuth = await prisma.twoFactorAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TwoFactorAuthCreateManyArgs>(args?: SelectSubset<T, TwoFactorAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwoFactorAuth.
     * @param {TwoFactorAuthDeleteArgs} args - Arguments to delete one TwoFactorAuth.
     * @example
     * // Delete one TwoFactorAuth
     * const TwoFactorAuth = await prisma.twoFactorAuth.delete({
     *   where: {
     *     // ... filter to delete one TwoFactorAuth
     *   }
     * })
     * 
     */
    delete<T extends TwoFactorAuthDeleteArgs>(args: SelectSubset<T, TwoFactorAuthDeleteArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TwoFactorAuth.
     * @param {TwoFactorAuthUpdateArgs} args - Arguments to update one TwoFactorAuth.
     * @example
     * // Update one TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TwoFactorAuthUpdateArgs>(args: SelectSubset<T, TwoFactorAuthUpdateArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TwoFactorAuths.
     * @param {TwoFactorAuthDeleteManyArgs} args - Arguments to filter TwoFactorAuths to delete.
     * @example
     * // Delete a few TwoFactorAuths
     * const { count } = await prisma.twoFactorAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TwoFactorAuthDeleteManyArgs>(args?: SelectSubset<T, TwoFactorAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwoFactorAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwoFactorAuths
     * const twoFactorAuth = await prisma.twoFactorAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TwoFactorAuthUpdateManyArgs>(args: SelectSubset<T, TwoFactorAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwoFactorAuth.
     * @param {TwoFactorAuthUpsertArgs} args - Arguments to update or create a TwoFactorAuth.
     * @example
     * // Update or create a TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.upsert({
     *   create: {
     *     // ... data to create a TwoFactorAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwoFactorAuth we want to update
     *   }
     * })
     */
    upsert<T extends TwoFactorAuthUpsertArgs>(args: SelectSubset<T, TwoFactorAuthUpsertArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Result.GetResult<Prisma.$TwoFactorAuthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TwoFactorAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthCountArgs} args - Arguments to filter TwoFactorAuths to count.
     * @example
     * // Count the number of TwoFactorAuths
     * const count = await prisma.twoFactorAuth.count({
     *   where: {
     *     // ... the filter for the TwoFactorAuths we want to count
     *   }
     * })
    **/
    count<T extends TwoFactorAuthCountArgs>(
      args?: Subset<T, TwoFactorAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwoFactorAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwoFactorAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwoFactorAuthAggregateArgs>(args: Subset<T, TwoFactorAuthAggregateArgs>): Prisma.PrismaPromise<GetTwoFactorAuthAggregateType<T>>

    /**
     * Group by TwoFactorAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwoFactorAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwoFactorAuthGroupByArgs['orderBy'] }
        : { orderBy?: TwoFactorAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwoFactorAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwoFactorAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TwoFactorAuth model
   */
  readonly fields: TwoFactorAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TwoFactorAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TwoFactorAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TwoFactorAuth model
   */
  interface TwoFactorAuthFieldRefs {
    readonly id: FieldRef<"TwoFactorAuth", 'Int'>
    readonly userId: FieldRef<"TwoFactorAuth", 'Int'>
    readonly secret: FieldRef<"TwoFactorAuth", 'String'>
    readonly isEnabled: FieldRef<"TwoFactorAuth", 'Boolean'>
    readonly createdAt: FieldRef<"TwoFactorAuth", 'DateTime'>
    readonly updatedAt: FieldRef<"TwoFactorAuth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TwoFactorAuth findUnique
   */
  export type TwoFactorAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAuth to fetch.
     */
    where: TwoFactorAuthWhereUniqueInput
  }

  /**
   * TwoFactorAuth findUniqueOrThrow
   */
  export type TwoFactorAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAuth to fetch.
     */
    where: TwoFactorAuthWhereUniqueInput
  }

  /**
   * TwoFactorAuth findFirst
   */
  export type TwoFactorAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAuth to fetch.
     */
    where?: TwoFactorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorAuths to fetch.
     */
    orderBy?: TwoFactorAuthOrderByWithRelationInput | TwoFactorAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorAuths.
     */
    cursor?: TwoFactorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorAuths.
     */
    distinct?: TwoFactorAuthScalarFieldEnum | TwoFactorAuthScalarFieldEnum[]
  }

  /**
   * TwoFactorAuth findFirstOrThrow
   */
  export type TwoFactorAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAuth to fetch.
     */
    where?: TwoFactorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorAuths to fetch.
     */
    orderBy?: TwoFactorAuthOrderByWithRelationInput | TwoFactorAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorAuths.
     */
    cursor?: TwoFactorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorAuths.
     */
    distinct?: TwoFactorAuthScalarFieldEnum | TwoFactorAuthScalarFieldEnum[]
  }

  /**
   * TwoFactorAuth findMany
   */
  export type TwoFactorAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAuths to fetch.
     */
    where?: TwoFactorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorAuths to fetch.
     */
    orderBy?: TwoFactorAuthOrderByWithRelationInput | TwoFactorAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwoFactorAuths.
     */
    cursor?: TwoFactorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorAuths.
     */
    skip?: number
    distinct?: TwoFactorAuthScalarFieldEnum | TwoFactorAuthScalarFieldEnum[]
  }

  /**
   * TwoFactorAuth create
   */
  export type TwoFactorAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a TwoFactorAuth.
     */
    data: XOR<TwoFactorAuthCreateInput, TwoFactorAuthUncheckedCreateInput>
  }

  /**
   * TwoFactorAuth createMany
   */
  export type TwoFactorAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwoFactorAuths.
     */
    data: TwoFactorAuthCreateManyInput | TwoFactorAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TwoFactorAuth update
   */
  export type TwoFactorAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a TwoFactorAuth.
     */
    data: XOR<TwoFactorAuthUpdateInput, TwoFactorAuthUncheckedUpdateInput>
    /**
     * Choose, which TwoFactorAuth to update.
     */
    where: TwoFactorAuthWhereUniqueInput
  }

  /**
   * TwoFactorAuth updateMany
   */
  export type TwoFactorAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwoFactorAuths.
     */
    data: XOR<TwoFactorAuthUpdateManyMutationInput, TwoFactorAuthUncheckedUpdateManyInput>
    /**
     * Filter which TwoFactorAuths to update
     */
    where?: TwoFactorAuthWhereInput
    /**
     * Limit how many TwoFactorAuths to update.
     */
    limit?: number
  }

  /**
   * TwoFactorAuth upsert
   */
  export type TwoFactorAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the TwoFactorAuth to update in case it exists.
     */
    where: TwoFactorAuthWhereUniqueInput
    /**
     * In case the TwoFactorAuth found by the `where` argument doesn't exist, create a new TwoFactorAuth with this data.
     */
    create: XOR<TwoFactorAuthCreateInput, TwoFactorAuthUncheckedCreateInput>
    /**
     * In case the TwoFactorAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwoFactorAuthUpdateInput, TwoFactorAuthUncheckedUpdateInput>
  }

  /**
   * TwoFactorAuth delete
   */
  export type TwoFactorAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter which TwoFactorAuth to delete.
     */
    where: TwoFactorAuthWhereUniqueInput
  }

  /**
   * TwoFactorAuth deleteMany
   */
  export type TwoFactorAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorAuths to delete
     */
    where?: TwoFactorAuthWhereInput
    /**
     * Limit how many TwoFactorAuths to delete.
     */
    limit?: number
  }

  /**
   * TwoFactorAuth without action
   */
  export type TwoFactorAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAuth
     */
    omit?: TwoFactorAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
  }


  /**
   * Model AbandonedCart
   */

  export type AggregateAbandonedCart = {
    _count: AbandonedCartCountAggregateOutputType | null
    _avg: AbandonedCartAvgAggregateOutputType | null
    _sum: AbandonedCartSumAggregateOutputType | null
    _min: AbandonedCartMinAggregateOutputType | null
    _max: AbandonedCartMaxAggregateOutputType | null
  }

  export type AbandonedCartAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AbandonedCartSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AbandonedCartMinAggregateOutputType = {
    id: number | null
    userId: number | null
    abandonedAt: Date | null
  }

  export type AbandonedCartMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    abandonedAt: Date | null
  }

  export type AbandonedCartCountAggregateOutputType = {
    id: number
    userId: number
    abandonedAt: number
    _all: number
  }


  export type AbandonedCartAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AbandonedCartSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AbandonedCartMinAggregateInputType = {
    id?: true
    userId?: true
    abandonedAt?: true
  }

  export type AbandonedCartMaxAggregateInputType = {
    id?: true
    userId?: true
    abandonedAt?: true
  }

  export type AbandonedCartCountAggregateInputType = {
    id?: true
    userId?: true
    abandonedAt?: true
    _all?: true
  }

  export type AbandonedCartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AbandonedCart to aggregate.
     */
    where?: AbandonedCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbandonedCarts to fetch.
     */
    orderBy?: AbandonedCartOrderByWithRelationInput | AbandonedCartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AbandonedCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbandonedCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbandonedCarts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AbandonedCarts
    **/
    _count?: true | AbandonedCartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AbandonedCartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AbandonedCartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AbandonedCartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AbandonedCartMaxAggregateInputType
  }

  export type GetAbandonedCartAggregateType<T extends AbandonedCartAggregateArgs> = {
        [P in keyof T & keyof AggregateAbandonedCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbandonedCart[P]>
      : GetScalarType<T[P], AggregateAbandonedCart[P]>
  }




  export type AbandonedCartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbandonedCartWhereInput
    orderBy?: AbandonedCartOrderByWithAggregationInput | AbandonedCartOrderByWithAggregationInput[]
    by: AbandonedCartScalarFieldEnum[] | AbandonedCartScalarFieldEnum
    having?: AbandonedCartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AbandonedCartCountAggregateInputType | true
    _avg?: AbandonedCartAvgAggregateInputType
    _sum?: AbandonedCartSumAggregateInputType
    _min?: AbandonedCartMinAggregateInputType
    _max?: AbandonedCartMaxAggregateInputType
  }

  export type AbandonedCartGroupByOutputType = {
    id: number
    userId: number
    abandonedAt: Date
    _count: AbandonedCartCountAggregateOutputType | null
    _avg: AbandonedCartAvgAggregateOutputType | null
    _sum: AbandonedCartSumAggregateOutputType | null
    _min: AbandonedCartMinAggregateOutputType | null
    _max: AbandonedCartMaxAggregateOutputType | null
  }

  type GetAbandonedCartGroupByPayload<T extends AbandonedCartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AbandonedCartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AbandonedCartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AbandonedCartGroupByOutputType[P]>
            : GetScalarType<T[P], AbandonedCartGroupByOutputType[P]>
        }
      >
    >


  export type AbandonedCartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    abandonedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cartItems?: boolean | AbandonedCart$cartItemsArgs<ExtArgs>
    _count?: boolean | AbandonedCartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["abandonedCart"]>



  export type AbandonedCartSelectScalar = {
    id?: boolean
    userId?: boolean
    abandonedAt?: boolean
  }

  export type AbandonedCartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "abandonedAt", ExtArgs["result"]["abandonedCart"]>
  export type AbandonedCartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cartItems?: boolean | AbandonedCart$cartItemsArgs<ExtArgs>
    _count?: boolean | AbandonedCartCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AbandonedCartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AbandonedCart"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      cartItems: Prisma.$CartItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      abandonedAt: Date
    }, ExtArgs["result"]["abandonedCart"]>
    composites: {}
  }

  type AbandonedCartGetPayload<S extends boolean | null | undefined | AbandonedCartDefaultArgs> = $Result.GetResult<Prisma.$AbandonedCartPayload, S>

  type AbandonedCartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AbandonedCartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AbandonedCartCountAggregateInputType | true
    }

  export interface AbandonedCartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AbandonedCart'], meta: { name: 'AbandonedCart' } }
    /**
     * Find zero or one AbandonedCart that matches the filter.
     * @param {AbandonedCartFindUniqueArgs} args - Arguments to find a AbandonedCart
     * @example
     * // Get one AbandonedCart
     * const abandonedCart = await prisma.abandonedCart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AbandonedCartFindUniqueArgs>(args: SelectSubset<T, AbandonedCartFindUniqueArgs<ExtArgs>>): Prisma__AbandonedCartClient<$Result.GetResult<Prisma.$AbandonedCartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AbandonedCart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AbandonedCartFindUniqueOrThrowArgs} args - Arguments to find a AbandonedCart
     * @example
     * // Get one AbandonedCart
     * const abandonedCart = await prisma.abandonedCart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AbandonedCartFindUniqueOrThrowArgs>(args: SelectSubset<T, AbandonedCartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AbandonedCartClient<$Result.GetResult<Prisma.$AbandonedCartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AbandonedCart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbandonedCartFindFirstArgs} args - Arguments to find a AbandonedCart
     * @example
     * // Get one AbandonedCart
     * const abandonedCart = await prisma.abandonedCart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AbandonedCartFindFirstArgs>(args?: SelectSubset<T, AbandonedCartFindFirstArgs<ExtArgs>>): Prisma__AbandonedCartClient<$Result.GetResult<Prisma.$AbandonedCartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AbandonedCart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbandonedCartFindFirstOrThrowArgs} args - Arguments to find a AbandonedCart
     * @example
     * // Get one AbandonedCart
     * const abandonedCart = await prisma.abandonedCart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AbandonedCartFindFirstOrThrowArgs>(args?: SelectSubset<T, AbandonedCartFindFirstOrThrowArgs<ExtArgs>>): Prisma__AbandonedCartClient<$Result.GetResult<Prisma.$AbandonedCartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AbandonedCarts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbandonedCartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AbandonedCarts
     * const abandonedCarts = await prisma.abandonedCart.findMany()
     * 
     * // Get first 10 AbandonedCarts
     * const abandonedCarts = await prisma.abandonedCart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const abandonedCartWithIdOnly = await prisma.abandonedCart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AbandonedCartFindManyArgs>(args?: SelectSubset<T, AbandonedCartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbandonedCartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AbandonedCart.
     * @param {AbandonedCartCreateArgs} args - Arguments to create a AbandonedCart.
     * @example
     * // Create one AbandonedCart
     * const AbandonedCart = await prisma.abandonedCart.create({
     *   data: {
     *     // ... data to create a AbandonedCart
     *   }
     * })
     * 
     */
    create<T extends AbandonedCartCreateArgs>(args: SelectSubset<T, AbandonedCartCreateArgs<ExtArgs>>): Prisma__AbandonedCartClient<$Result.GetResult<Prisma.$AbandonedCartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AbandonedCarts.
     * @param {AbandonedCartCreateManyArgs} args - Arguments to create many AbandonedCarts.
     * @example
     * // Create many AbandonedCarts
     * const abandonedCart = await prisma.abandonedCart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AbandonedCartCreateManyArgs>(args?: SelectSubset<T, AbandonedCartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AbandonedCart.
     * @param {AbandonedCartDeleteArgs} args - Arguments to delete one AbandonedCart.
     * @example
     * // Delete one AbandonedCart
     * const AbandonedCart = await prisma.abandonedCart.delete({
     *   where: {
     *     // ... filter to delete one AbandonedCart
     *   }
     * })
     * 
     */
    delete<T extends AbandonedCartDeleteArgs>(args: SelectSubset<T, AbandonedCartDeleteArgs<ExtArgs>>): Prisma__AbandonedCartClient<$Result.GetResult<Prisma.$AbandonedCartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AbandonedCart.
     * @param {AbandonedCartUpdateArgs} args - Arguments to update one AbandonedCart.
     * @example
     * // Update one AbandonedCart
     * const abandonedCart = await prisma.abandonedCart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AbandonedCartUpdateArgs>(args: SelectSubset<T, AbandonedCartUpdateArgs<ExtArgs>>): Prisma__AbandonedCartClient<$Result.GetResult<Prisma.$AbandonedCartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AbandonedCarts.
     * @param {AbandonedCartDeleteManyArgs} args - Arguments to filter AbandonedCarts to delete.
     * @example
     * // Delete a few AbandonedCarts
     * const { count } = await prisma.abandonedCart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AbandonedCartDeleteManyArgs>(args?: SelectSubset<T, AbandonedCartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AbandonedCarts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbandonedCartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AbandonedCarts
     * const abandonedCart = await prisma.abandonedCart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AbandonedCartUpdateManyArgs>(args: SelectSubset<T, AbandonedCartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AbandonedCart.
     * @param {AbandonedCartUpsertArgs} args - Arguments to update or create a AbandonedCart.
     * @example
     * // Update or create a AbandonedCart
     * const abandonedCart = await prisma.abandonedCart.upsert({
     *   create: {
     *     // ... data to create a AbandonedCart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AbandonedCart we want to update
     *   }
     * })
     */
    upsert<T extends AbandonedCartUpsertArgs>(args: SelectSubset<T, AbandonedCartUpsertArgs<ExtArgs>>): Prisma__AbandonedCartClient<$Result.GetResult<Prisma.$AbandonedCartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AbandonedCarts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbandonedCartCountArgs} args - Arguments to filter AbandonedCarts to count.
     * @example
     * // Count the number of AbandonedCarts
     * const count = await prisma.abandonedCart.count({
     *   where: {
     *     // ... the filter for the AbandonedCarts we want to count
     *   }
     * })
    **/
    count<T extends AbandonedCartCountArgs>(
      args?: Subset<T, AbandonedCartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AbandonedCartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AbandonedCart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbandonedCartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AbandonedCartAggregateArgs>(args: Subset<T, AbandonedCartAggregateArgs>): Prisma.PrismaPromise<GetAbandonedCartAggregateType<T>>

    /**
     * Group by AbandonedCart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbandonedCartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AbandonedCartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AbandonedCartGroupByArgs['orderBy'] }
        : { orderBy?: AbandonedCartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AbandonedCartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbandonedCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AbandonedCart model
   */
  readonly fields: AbandonedCartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AbandonedCart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AbandonedCartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cartItems<T extends AbandonedCart$cartItemsArgs<ExtArgs> = {}>(args?: Subset<T, AbandonedCart$cartItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AbandonedCart model
   */
  interface AbandonedCartFieldRefs {
    readonly id: FieldRef<"AbandonedCart", 'Int'>
    readonly userId: FieldRef<"AbandonedCart", 'Int'>
    readonly abandonedAt: FieldRef<"AbandonedCart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AbandonedCart findUnique
   */
  export type AbandonedCartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbandonedCart
     */
    select?: AbandonedCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbandonedCart
     */
    omit?: AbandonedCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbandonedCartInclude<ExtArgs> | null
    /**
     * Filter, which AbandonedCart to fetch.
     */
    where: AbandonedCartWhereUniqueInput
  }

  /**
   * AbandonedCart findUniqueOrThrow
   */
  export type AbandonedCartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbandonedCart
     */
    select?: AbandonedCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbandonedCart
     */
    omit?: AbandonedCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbandonedCartInclude<ExtArgs> | null
    /**
     * Filter, which AbandonedCart to fetch.
     */
    where: AbandonedCartWhereUniqueInput
  }

  /**
   * AbandonedCart findFirst
   */
  export type AbandonedCartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbandonedCart
     */
    select?: AbandonedCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbandonedCart
     */
    omit?: AbandonedCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbandonedCartInclude<ExtArgs> | null
    /**
     * Filter, which AbandonedCart to fetch.
     */
    where?: AbandonedCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbandonedCarts to fetch.
     */
    orderBy?: AbandonedCartOrderByWithRelationInput | AbandonedCartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AbandonedCarts.
     */
    cursor?: AbandonedCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbandonedCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbandonedCarts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AbandonedCarts.
     */
    distinct?: AbandonedCartScalarFieldEnum | AbandonedCartScalarFieldEnum[]
  }

  /**
   * AbandonedCart findFirstOrThrow
   */
  export type AbandonedCartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbandonedCart
     */
    select?: AbandonedCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbandonedCart
     */
    omit?: AbandonedCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbandonedCartInclude<ExtArgs> | null
    /**
     * Filter, which AbandonedCart to fetch.
     */
    where?: AbandonedCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbandonedCarts to fetch.
     */
    orderBy?: AbandonedCartOrderByWithRelationInput | AbandonedCartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AbandonedCarts.
     */
    cursor?: AbandonedCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbandonedCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbandonedCarts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AbandonedCarts.
     */
    distinct?: AbandonedCartScalarFieldEnum | AbandonedCartScalarFieldEnum[]
  }

  /**
   * AbandonedCart findMany
   */
  export type AbandonedCartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbandonedCart
     */
    select?: AbandonedCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbandonedCart
     */
    omit?: AbandonedCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbandonedCartInclude<ExtArgs> | null
    /**
     * Filter, which AbandonedCarts to fetch.
     */
    where?: AbandonedCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AbandonedCarts to fetch.
     */
    orderBy?: AbandonedCartOrderByWithRelationInput | AbandonedCartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AbandonedCarts.
     */
    cursor?: AbandonedCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AbandonedCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AbandonedCarts.
     */
    skip?: number
    distinct?: AbandonedCartScalarFieldEnum | AbandonedCartScalarFieldEnum[]
  }

  /**
   * AbandonedCart create
   */
  export type AbandonedCartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbandonedCart
     */
    select?: AbandonedCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbandonedCart
     */
    omit?: AbandonedCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbandonedCartInclude<ExtArgs> | null
    /**
     * The data needed to create a AbandonedCart.
     */
    data: XOR<AbandonedCartCreateInput, AbandonedCartUncheckedCreateInput>
  }

  /**
   * AbandonedCart createMany
   */
  export type AbandonedCartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AbandonedCarts.
     */
    data: AbandonedCartCreateManyInput | AbandonedCartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AbandonedCart update
   */
  export type AbandonedCartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbandonedCart
     */
    select?: AbandonedCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbandonedCart
     */
    omit?: AbandonedCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbandonedCartInclude<ExtArgs> | null
    /**
     * The data needed to update a AbandonedCart.
     */
    data: XOR<AbandonedCartUpdateInput, AbandonedCartUncheckedUpdateInput>
    /**
     * Choose, which AbandonedCart to update.
     */
    where: AbandonedCartWhereUniqueInput
  }

  /**
   * AbandonedCart updateMany
   */
  export type AbandonedCartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AbandonedCarts.
     */
    data: XOR<AbandonedCartUpdateManyMutationInput, AbandonedCartUncheckedUpdateManyInput>
    /**
     * Filter which AbandonedCarts to update
     */
    where?: AbandonedCartWhereInput
    /**
     * Limit how many AbandonedCarts to update.
     */
    limit?: number
  }

  /**
   * AbandonedCart upsert
   */
  export type AbandonedCartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbandonedCart
     */
    select?: AbandonedCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbandonedCart
     */
    omit?: AbandonedCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbandonedCartInclude<ExtArgs> | null
    /**
     * The filter to search for the AbandonedCart to update in case it exists.
     */
    where: AbandonedCartWhereUniqueInput
    /**
     * In case the AbandonedCart found by the `where` argument doesn't exist, create a new AbandonedCart with this data.
     */
    create: XOR<AbandonedCartCreateInput, AbandonedCartUncheckedCreateInput>
    /**
     * In case the AbandonedCart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AbandonedCartUpdateInput, AbandonedCartUncheckedUpdateInput>
  }

  /**
   * AbandonedCart delete
   */
  export type AbandonedCartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbandonedCart
     */
    select?: AbandonedCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbandonedCart
     */
    omit?: AbandonedCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbandonedCartInclude<ExtArgs> | null
    /**
     * Filter which AbandonedCart to delete.
     */
    where: AbandonedCartWhereUniqueInput
  }

  /**
   * AbandonedCart deleteMany
   */
  export type AbandonedCartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AbandonedCarts to delete
     */
    where?: AbandonedCartWhereInput
    /**
     * Limit how many AbandonedCarts to delete.
     */
    limit?: number
  }

  /**
   * AbandonedCart.cartItems
   */
  export type AbandonedCart$cartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItems
     */
    select?: CartItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItems
     */
    omit?: CartItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemsInclude<ExtArgs> | null
    where?: CartItemsWhereInput
    orderBy?: CartItemsOrderByWithRelationInput | CartItemsOrderByWithRelationInput[]
    cursor?: CartItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemsScalarFieldEnum | CartItemsScalarFieldEnum[]
  }

  /**
   * AbandonedCart without action
   */
  export type AbandonedCartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbandonedCart
     */
    select?: AbandonedCartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AbandonedCart
     */
    omit?: AbandonedCartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbandonedCartInclude<ExtArgs> | null
  }


  /**
   * Model ReturnExchange
   */

  export type AggregateReturnExchange = {
    _count: ReturnExchangeCountAggregateOutputType | null
    _avg: ReturnExchangeAvgAggregateOutputType | null
    _sum: ReturnExchangeSumAggregateOutputType | null
    _min: ReturnExchangeMinAggregateOutputType | null
    _max: ReturnExchangeMaxAggregateOutputType | null
  }

  export type ReturnExchangeAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
  }

  export type ReturnExchangeSumAggregateOutputType = {
    id: number | null
    orderId: number | null
  }

  export type ReturnExchangeMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    reason: string | null
    status: $Enums.ReturnExchangeStatus | null
    requestedAt: Date | null
    completedAt: Date | null
  }

  export type ReturnExchangeMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    reason: string | null
    status: $Enums.ReturnExchangeStatus | null
    requestedAt: Date | null
    completedAt: Date | null
  }

  export type ReturnExchangeCountAggregateOutputType = {
    id: number
    orderId: number
    reason: number
    status: number
    requestedAt: number
    completedAt: number
    _all: number
  }


  export type ReturnExchangeAvgAggregateInputType = {
    id?: true
    orderId?: true
  }

  export type ReturnExchangeSumAggregateInputType = {
    id?: true
    orderId?: true
  }

  export type ReturnExchangeMinAggregateInputType = {
    id?: true
    orderId?: true
    reason?: true
    status?: true
    requestedAt?: true
    completedAt?: true
  }

  export type ReturnExchangeMaxAggregateInputType = {
    id?: true
    orderId?: true
    reason?: true
    status?: true
    requestedAt?: true
    completedAt?: true
  }

  export type ReturnExchangeCountAggregateInputType = {
    id?: true
    orderId?: true
    reason?: true
    status?: true
    requestedAt?: true
    completedAt?: true
    _all?: true
  }

  export type ReturnExchangeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnExchange to aggregate.
     */
    where?: ReturnExchangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnExchanges to fetch.
     */
    orderBy?: ReturnExchangeOrderByWithRelationInput | ReturnExchangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReturnExchangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnExchanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnExchanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReturnExchanges
    **/
    _count?: true | ReturnExchangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReturnExchangeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReturnExchangeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReturnExchangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReturnExchangeMaxAggregateInputType
  }

  export type GetReturnExchangeAggregateType<T extends ReturnExchangeAggregateArgs> = {
        [P in keyof T & keyof AggregateReturnExchange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturnExchange[P]>
      : GetScalarType<T[P], AggregateReturnExchange[P]>
  }




  export type ReturnExchangeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnExchangeWhereInput
    orderBy?: ReturnExchangeOrderByWithAggregationInput | ReturnExchangeOrderByWithAggregationInput[]
    by: ReturnExchangeScalarFieldEnum[] | ReturnExchangeScalarFieldEnum
    having?: ReturnExchangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReturnExchangeCountAggregateInputType | true
    _avg?: ReturnExchangeAvgAggregateInputType
    _sum?: ReturnExchangeSumAggregateInputType
    _min?: ReturnExchangeMinAggregateInputType
    _max?: ReturnExchangeMaxAggregateInputType
  }

  export type ReturnExchangeGroupByOutputType = {
    id: number
    orderId: number
    reason: string
    status: $Enums.ReturnExchangeStatus
    requestedAt: Date
    completedAt: Date | null
    _count: ReturnExchangeCountAggregateOutputType | null
    _avg: ReturnExchangeAvgAggregateOutputType | null
    _sum: ReturnExchangeSumAggregateOutputType | null
    _min: ReturnExchangeMinAggregateOutputType | null
    _max: ReturnExchangeMaxAggregateOutputType | null
  }

  type GetReturnExchangeGroupByPayload<T extends ReturnExchangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReturnExchangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReturnExchangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReturnExchangeGroupByOutputType[P]>
            : GetScalarType<T[P], ReturnExchangeGroupByOutputType[P]>
        }
      >
    >


  export type ReturnExchangeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    reason?: boolean
    status?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    order?: boolean | OrdersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["returnExchange"]>



  export type ReturnExchangeSelectScalar = {
    id?: boolean
    orderId?: boolean
    reason?: boolean
    status?: boolean
    requestedAt?: boolean
    completedAt?: boolean
  }

  export type ReturnExchangeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "reason" | "status" | "requestedAt" | "completedAt", ExtArgs["result"]["returnExchange"]>
  export type ReturnExchangeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrdersDefaultArgs<ExtArgs>
  }

  export type $ReturnExchangePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReturnExchange"
    objects: {
      order: Prisma.$OrdersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      reason: string
      status: $Enums.ReturnExchangeStatus
      requestedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["returnExchange"]>
    composites: {}
  }

  type ReturnExchangeGetPayload<S extends boolean | null | undefined | ReturnExchangeDefaultArgs> = $Result.GetResult<Prisma.$ReturnExchangePayload, S>

  type ReturnExchangeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReturnExchangeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReturnExchangeCountAggregateInputType | true
    }

  export interface ReturnExchangeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReturnExchange'], meta: { name: 'ReturnExchange' } }
    /**
     * Find zero or one ReturnExchange that matches the filter.
     * @param {ReturnExchangeFindUniqueArgs} args - Arguments to find a ReturnExchange
     * @example
     * // Get one ReturnExchange
     * const returnExchange = await prisma.returnExchange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReturnExchangeFindUniqueArgs>(args: SelectSubset<T, ReturnExchangeFindUniqueArgs<ExtArgs>>): Prisma__ReturnExchangeClient<$Result.GetResult<Prisma.$ReturnExchangePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReturnExchange that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReturnExchangeFindUniqueOrThrowArgs} args - Arguments to find a ReturnExchange
     * @example
     * // Get one ReturnExchange
     * const returnExchange = await prisma.returnExchange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReturnExchangeFindUniqueOrThrowArgs>(args: SelectSubset<T, ReturnExchangeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReturnExchangeClient<$Result.GetResult<Prisma.$ReturnExchangePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReturnExchange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnExchangeFindFirstArgs} args - Arguments to find a ReturnExchange
     * @example
     * // Get one ReturnExchange
     * const returnExchange = await prisma.returnExchange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReturnExchangeFindFirstArgs>(args?: SelectSubset<T, ReturnExchangeFindFirstArgs<ExtArgs>>): Prisma__ReturnExchangeClient<$Result.GetResult<Prisma.$ReturnExchangePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReturnExchange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnExchangeFindFirstOrThrowArgs} args - Arguments to find a ReturnExchange
     * @example
     * // Get one ReturnExchange
     * const returnExchange = await prisma.returnExchange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReturnExchangeFindFirstOrThrowArgs>(args?: SelectSubset<T, ReturnExchangeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReturnExchangeClient<$Result.GetResult<Prisma.$ReturnExchangePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReturnExchanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnExchangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReturnExchanges
     * const returnExchanges = await prisma.returnExchange.findMany()
     * 
     * // Get first 10 ReturnExchanges
     * const returnExchanges = await prisma.returnExchange.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const returnExchangeWithIdOnly = await prisma.returnExchange.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReturnExchangeFindManyArgs>(args?: SelectSubset<T, ReturnExchangeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnExchangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReturnExchange.
     * @param {ReturnExchangeCreateArgs} args - Arguments to create a ReturnExchange.
     * @example
     * // Create one ReturnExchange
     * const ReturnExchange = await prisma.returnExchange.create({
     *   data: {
     *     // ... data to create a ReturnExchange
     *   }
     * })
     * 
     */
    create<T extends ReturnExchangeCreateArgs>(args: SelectSubset<T, ReturnExchangeCreateArgs<ExtArgs>>): Prisma__ReturnExchangeClient<$Result.GetResult<Prisma.$ReturnExchangePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReturnExchanges.
     * @param {ReturnExchangeCreateManyArgs} args - Arguments to create many ReturnExchanges.
     * @example
     * // Create many ReturnExchanges
     * const returnExchange = await prisma.returnExchange.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReturnExchangeCreateManyArgs>(args?: SelectSubset<T, ReturnExchangeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReturnExchange.
     * @param {ReturnExchangeDeleteArgs} args - Arguments to delete one ReturnExchange.
     * @example
     * // Delete one ReturnExchange
     * const ReturnExchange = await prisma.returnExchange.delete({
     *   where: {
     *     // ... filter to delete one ReturnExchange
     *   }
     * })
     * 
     */
    delete<T extends ReturnExchangeDeleteArgs>(args: SelectSubset<T, ReturnExchangeDeleteArgs<ExtArgs>>): Prisma__ReturnExchangeClient<$Result.GetResult<Prisma.$ReturnExchangePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReturnExchange.
     * @param {ReturnExchangeUpdateArgs} args - Arguments to update one ReturnExchange.
     * @example
     * // Update one ReturnExchange
     * const returnExchange = await prisma.returnExchange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReturnExchangeUpdateArgs>(args: SelectSubset<T, ReturnExchangeUpdateArgs<ExtArgs>>): Prisma__ReturnExchangeClient<$Result.GetResult<Prisma.$ReturnExchangePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReturnExchanges.
     * @param {ReturnExchangeDeleteManyArgs} args - Arguments to filter ReturnExchanges to delete.
     * @example
     * // Delete a few ReturnExchanges
     * const { count } = await prisma.returnExchange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReturnExchangeDeleteManyArgs>(args?: SelectSubset<T, ReturnExchangeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReturnExchanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnExchangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReturnExchanges
     * const returnExchange = await prisma.returnExchange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReturnExchangeUpdateManyArgs>(args: SelectSubset<T, ReturnExchangeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReturnExchange.
     * @param {ReturnExchangeUpsertArgs} args - Arguments to update or create a ReturnExchange.
     * @example
     * // Update or create a ReturnExchange
     * const returnExchange = await prisma.returnExchange.upsert({
     *   create: {
     *     // ... data to create a ReturnExchange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReturnExchange we want to update
     *   }
     * })
     */
    upsert<T extends ReturnExchangeUpsertArgs>(args: SelectSubset<T, ReturnExchangeUpsertArgs<ExtArgs>>): Prisma__ReturnExchangeClient<$Result.GetResult<Prisma.$ReturnExchangePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReturnExchanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnExchangeCountArgs} args - Arguments to filter ReturnExchanges to count.
     * @example
     * // Count the number of ReturnExchanges
     * const count = await prisma.returnExchange.count({
     *   where: {
     *     // ... the filter for the ReturnExchanges we want to count
     *   }
     * })
    **/
    count<T extends ReturnExchangeCountArgs>(
      args?: Subset<T, ReturnExchangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReturnExchangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReturnExchange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnExchangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReturnExchangeAggregateArgs>(args: Subset<T, ReturnExchangeAggregateArgs>): Prisma.PrismaPromise<GetReturnExchangeAggregateType<T>>

    /**
     * Group by ReturnExchange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnExchangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReturnExchangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReturnExchangeGroupByArgs['orderBy'] }
        : { orderBy?: ReturnExchangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReturnExchangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturnExchangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReturnExchange model
   */
  readonly fields: ReturnExchangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReturnExchange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReturnExchangeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrdersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrdersDefaultArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReturnExchange model
   */
  interface ReturnExchangeFieldRefs {
    readonly id: FieldRef<"ReturnExchange", 'Int'>
    readonly orderId: FieldRef<"ReturnExchange", 'Int'>
    readonly reason: FieldRef<"ReturnExchange", 'String'>
    readonly status: FieldRef<"ReturnExchange", 'ReturnExchangeStatus'>
    readonly requestedAt: FieldRef<"ReturnExchange", 'DateTime'>
    readonly completedAt: FieldRef<"ReturnExchange", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReturnExchange findUnique
   */
  export type ReturnExchangeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnExchange
     */
    select?: ReturnExchangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnExchange
     */
    omit?: ReturnExchangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnExchangeInclude<ExtArgs> | null
    /**
     * Filter, which ReturnExchange to fetch.
     */
    where: ReturnExchangeWhereUniqueInput
  }

  /**
   * ReturnExchange findUniqueOrThrow
   */
  export type ReturnExchangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnExchange
     */
    select?: ReturnExchangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnExchange
     */
    omit?: ReturnExchangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnExchangeInclude<ExtArgs> | null
    /**
     * Filter, which ReturnExchange to fetch.
     */
    where: ReturnExchangeWhereUniqueInput
  }

  /**
   * ReturnExchange findFirst
   */
  export type ReturnExchangeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnExchange
     */
    select?: ReturnExchangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnExchange
     */
    omit?: ReturnExchangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnExchangeInclude<ExtArgs> | null
    /**
     * Filter, which ReturnExchange to fetch.
     */
    where?: ReturnExchangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnExchanges to fetch.
     */
    orderBy?: ReturnExchangeOrderByWithRelationInput | ReturnExchangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnExchanges.
     */
    cursor?: ReturnExchangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnExchanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnExchanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnExchanges.
     */
    distinct?: ReturnExchangeScalarFieldEnum | ReturnExchangeScalarFieldEnum[]
  }

  /**
   * ReturnExchange findFirstOrThrow
   */
  export type ReturnExchangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnExchange
     */
    select?: ReturnExchangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnExchange
     */
    omit?: ReturnExchangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnExchangeInclude<ExtArgs> | null
    /**
     * Filter, which ReturnExchange to fetch.
     */
    where?: ReturnExchangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnExchanges to fetch.
     */
    orderBy?: ReturnExchangeOrderByWithRelationInput | ReturnExchangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnExchanges.
     */
    cursor?: ReturnExchangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnExchanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnExchanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnExchanges.
     */
    distinct?: ReturnExchangeScalarFieldEnum | ReturnExchangeScalarFieldEnum[]
  }

  /**
   * ReturnExchange findMany
   */
  export type ReturnExchangeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnExchange
     */
    select?: ReturnExchangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnExchange
     */
    omit?: ReturnExchangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnExchangeInclude<ExtArgs> | null
    /**
     * Filter, which ReturnExchanges to fetch.
     */
    where?: ReturnExchangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnExchanges to fetch.
     */
    orderBy?: ReturnExchangeOrderByWithRelationInput | ReturnExchangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReturnExchanges.
     */
    cursor?: ReturnExchangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnExchanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnExchanges.
     */
    skip?: number
    distinct?: ReturnExchangeScalarFieldEnum | ReturnExchangeScalarFieldEnum[]
  }

  /**
   * ReturnExchange create
   */
  export type ReturnExchangeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnExchange
     */
    select?: ReturnExchangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnExchange
     */
    omit?: ReturnExchangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnExchangeInclude<ExtArgs> | null
    /**
     * The data needed to create a ReturnExchange.
     */
    data: XOR<ReturnExchangeCreateInput, ReturnExchangeUncheckedCreateInput>
  }

  /**
   * ReturnExchange createMany
   */
  export type ReturnExchangeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReturnExchanges.
     */
    data: ReturnExchangeCreateManyInput | ReturnExchangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReturnExchange update
   */
  export type ReturnExchangeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnExchange
     */
    select?: ReturnExchangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnExchange
     */
    omit?: ReturnExchangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnExchangeInclude<ExtArgs> | null
    /**
     * The data needed to update a ReturnExchange.
     */
    data: XOR<ReturnExchangeUpdateInput, ReturnExchangeUncheckedUpdateInput>
    /**
     * Choose, which ReturnExchange to update.
     */
    where: ReturnExchangeWhereUniqueInput
  }

  /**
   * ReturnExchange updateMany
   */
  export type ReturnExchangeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReturnExchanges.
     */
    data: XOR<ReturnExchangeUpdateManyMutationInput, ReturnExchangeUncheckedUpdateManyInput>
    /**
     * Filter which ReturnExchanges to update
     */
    where?: ReturnExchangeWhereInput
    /**
     * Limit how many ReturnExchanges to update.
     */
    limit?: number
  }

  /**
   * ReturnExchange upsert
   */
  export type ReturnExchangeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnExchange
     */
    select?: ReturnExchangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnExchange
     */
    omit?: ReturnExchangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnExchangeInclude<ExtArgs> | null
    /**
     * The filter to search for the ReturnExchange to update in case it exists.
     */
    where: ReturnExchangeWhereUniqueInput
    /**
     * In case the ReturnExchange found by the `where` argument doesn't exist, create a new ReturnExchange with this data.
     */
    create: XOR<ReturnExchangeCreateInput, ReturnExchangeUncheckedCreateInput>
    /**
     * In case the ReturnExchange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReturnExchangeUpdateInput, ReturnExchangeUncheckedUpdateInput>
  }

  /**
   * ReturnExchange delete
   */
  export type ReturnExchangeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnExchange
     */
    select?: ReturnExchangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnExchange
     */
    omit?: ReturnExchangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnExchangeInclude<ExtArgs> | null
    /**
     * Filter which ReturnExchange to delete.
     */
    where: ReturnExchangeWhereUniqueInput
  }

  /**
   * ReturnExchange deleteMany
   */
  export type ReturnExchangeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnExchanges to delete
     */
    where?: ReturnExchangeWhereInput
    /**
     * Limit how many ReturnExchanges to delete.
     */
    limit?: number
  }

  /**
   * ReturnExchange without action
   */
  export type ReturnExchangeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnExchange
     */
    select?: ReturnExchangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnExchange
     */
    omit?: ReturnExchangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnExchangeInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    cpf: 'cpf',
    email: 'email',
    password: 'password',
    bornDate: 'bornDate',
    avatarId: 'avatarId',
    principalAddressId: 'principalAddressId',
    cartId: 'cartId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AvatarUserScalarFieldEnum: {
    id: 'id',
    url: 'url',
    publicId: 'publicId',
    userId: 'userId'
  };

  export type AvatarUserScalarFieldEnum = (typeof AvatarUserScalarFieldEnum)[keyof typeof AvatarUserScalarFieldEnum]


  export const AddressesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    cep: 'cep',
    road: 'road',
    number: 'number',
    complement: 'complement',
    neighborhood: 'neighborhood',
    city: 'city',
    state: 'state',
    country: 'country',
    type: 'type',
    reference: 'reference'
  };

  export type AddressesScalarFieldEnum = (typeof AddressesScalarFieldEnum)[keyof typeof AddressesScalarFieldEnum]


  export const UserUsedCouponsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    couponId: 'couponId',
    usedAt: 'usedAt',
    orderId: 'orderId'
  };

  export type UserUsedCouponsScalarFieldEnum = (typeof UserUsedCouponsScalarFieldEnum)[keyof typeof UserUsedCouponsScalarFieldEnum]


  export const StoresScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    cnpj: 'cnpj',
    avatarId: 'avatarId'
  };

  export type StoresScalarFieldEnum = (typeof StoresScalarFieldEnum)[keyof typeof StoresScalarFieldEnum]


  export const AvatarStoreScalarFieldEnum: {
    id: 'id',
    url: 'url',
    publicId: 'publicId'
  };

  export type AvatarStoreScalarFieldEnum = (typeof AvatarStoreScalarFieldEnum)[keyof typeof AvatarStoreScalarFieldEnum]


  export const StoreAvaliationsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    storeId: 'storeId',
    note: 'note',
    avaliationDate: 'avaliationDate',
    comment: 'comment'
  };

  export type StoreAvaliationsScalarFieldEnum = (typeof StoreAvaliationsScalarFieldEnum)[keyof typeof StoreAvaliationsScalarFieldEnum]


  export const StoreAvaliationImagesScalarFieldEnum: {
    id: 'id',
    url: 'url',
    publicId: 'publicId',
    storeAvaliationId: 'storeAvaliationId'
  };

  export type StoreAvaliationImagesScalarFieldEnum = (typeof StoreAvaliationImagesScalarFieldEnum)[keyof typeof StoreAvaliationImagesScalarFieldEnum]


  export const CouponsScalarFieldEnum: {
    id: 'id',
    code: 'code',
    expirationDate: 'expirationDate',
    percentageDiscount: 'percentageDiscount',
    discountValue: 'discountValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    storeId: 'storeId'
  };

  export type CouponsScalarFieldEnum = (typeof CouponsScalarFieldEnum)[keyof typeof CouponsScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    price: 'price'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const ProductImagesScalarFieldEnum: {
    id: 'id',
    url: 'url',
    publicId: 'publicId',
    productId: 'productId'
  };

  export type ProductImagesScalarFieldEnum = (typeof ProductImagesScalarFieldEnum)[keyof typeof ProductImagesScalarFieldEnum]


  export const WishlistScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WishlistScalarFieldEnum = (typeof WishlistScalarFieldEnum)[keyof typeof WishlistScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const PromotionScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    discountType: 'discountType',
    discountValue: 'discountValue',
    startDate: 'startDate',
    endDate: 'endDate',
    storeId: 'storeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromotionScalarFieldEnum = (typeof PromotionScalarFieldEnum)[keyof typeof PromotionScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ProductAvaliationsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    note: 'note',
    avaliationDate: 'avaliationDate',
    comment: 'comment'
  };

  export type ProductAvaliationsScalarFieldEnum = (typeof ProductAvaliationsScalarFieldEnum)[keyof typeof ProductAvaliationsScalarFieldEnum]


  export const ProductAvaliationImagesScalarFieldEnum: {
    id: 'id',
    url: 'url',
    publicId: 'publicId',
    productAvaliationId: 'productAvaliationId'
  };

  export type ProductAvaliationImagesScalarFieldEnum = (typeof ProductAvaliationImagesScalarFieldEnum)[keyof typeof ProductAvaliationImagesScalarFieldEnum]


  export const CartScalarFieldEnum: {
    id: 'id'
  };

  export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


  export const CartItemsScalarFieldEnum: {
    id: 'id',
    cartId: 'cartId',
    productId: 'productId',
    quantidade: 'quantidade',
    abandonedCartId: 'abandonedCartId'
  };

  export type CartItemsScalarFieldEnum = (typeof CartItemsScalarFieldEnum)[keyof typeof CartItemsScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    method: 'method'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    valor: 'valor',
    paymentDate: 'paymentDate',
    paymentMethodId: 'paymentMethodId'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const OrderStatusScalarFieldEnum: {
    id: 'id',
    Status: 'Status'
  };

  export type OrderStatusScalarFieldEnum = (typeof OrderStatusScalarFieldEnum)[keyof typeof OrderStatusScalarFieldEnum]


  export const OrdersScalarFieldEnum: {
    id: 'id',
    totalValue: 'totalValue',
    trackingCode: 'trackingCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sendDate: 'sendDate',
    deliveryDate: 'deliveryDate',
    minimumDeliveryForeast: 'minimumDeliveryForeast',
    maximumDeliveryForeast: 'maximumDeliveryForeast',
    usedCoupon: 'usedCoupon',
    userId: 'userId',
    orderStatusId: 'orderStatusId',
    deliveryAddressId: 'deliveryAddressId'
  };

  export type OrdersScalarFieldEnum = (typeof OrdersScalarFieldEnum)[keyof typeof OrdersScalarFieldEnum]


  export const OrderHistoryScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    action: 'action',
    updatedAt: 'updatedAt'
  };

  export type OrderHistoryScalarFieldEnum = (typeof OrderHistoryScalarFieldEnum)[keyof typeof OrderHistoryScalarFieldEnum]


  export const OrderItemsScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    storeId: 'storeId',
    quantity: 'quantity',
    price: 'price'
  };

  export type OrderItemsScalarFieldEnum = (typeof OrderItemsScalarFieldEnum)[keyof typeof OrderItemsScalarFieldEnum]


  export const ShippingScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    shippingMethod: 'shippingMethod',
    shippingCost: 'shippingCost',
    estimatedDelivery: 'estimatedDelivery',
    trackingCode: 'trackingCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShippingScalarFieldEnum = (typeof ShippingScalarFieldEnum)[keyof typeof ShippingScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    storeId: 'storeId'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const ChatMessagesScalarFieldEnum: {
    id: 'id',
    content: 'content',
    chatId: 'chatId',
    senderUserId: 'senderUserId',
    senderStoreId: 'senderStoreId',
    receiverUserId: 'receiverUserId',
    receiverStoreId: 'receiverStoreId',
    imageId: 'imageId',
    sentAt: 'sentAt',
    receivedAt: 'receivedAt',
    wasReceived: 'wasReceived',
    readAt: 'readAt',
    wasRead: 'wasRead'
  };

  export type ChatMessagesScalarFieldEnum = (typeof ChatMessagesScalarFieldEnum)[keyof typeof ChatMessagesScalarFieldEnum]


  export const MessageImagesScalarFieldEnum: {
    id: 'id',
    url: 'url',
    publicId: 'publicId'
  };

  export type MessageImagesScalarFieldEnum = (typeof MessageImagesScalarFieldEnum)[keyof typeof MessageImagesScalarFieldEnum]


  export const LoginTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token'
  };

  export type LoginTokenScalarFieldEnum = (typeof LoginTokenScalarFieldEnum)[keyof typeof LoginTokenScalarFieldEnum]


  export const ConfirmationTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token'
  };

  export type ConfirmationTokenScalarFieldEnum = (typeof ConfirmationTokenScalarFieldEnum)[keyof typeof ConfirmationTokenScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    tableName: 'tableName',
    recordId: 'recordId',
    userId: 'userId',
    timestamp: 'timestamp',
    details: 'details'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const TwoFactorAuthScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    secret: 'secret',
    isEnabled: 'isEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwoFactorAuthScalarFieldEnum = (typeof TwoFactorAuthScalarFieldEnum)[keyof typeof TwoFactorAuthScalarFieldEnum]


  export const AbandonedCartScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    abandonedAt: 'abandonedAt'
  };

  export type AbandonedCartScalarFieldEnum = (typeof AbandonedCartScalarFieldEnum)[keyof typeof AbandonedCartScalarFieldEnum]


  export const ReturnExchangeScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    reason: 'reason',
    status: 'status',
    requestedAt: 'requestedAt',
    completedAt: 'completedAt'
  };

  export type ReturnExchangeScalarFieldEnum = (typeof ReturnExchangeScalarFieldEnum)[keyof typeof ReturnExchangeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    name: 'name',
    cpf: 'cpf',
    email: 'email',
    password: 'password'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const AvatarUserOrderByRelevanceFieldEnum: {
    url: 'url',
    publicId: 'publicId'
  };

  export type AvatarUserOrderByRelevanceFieldEnum = (typeof AvatarUserOrderByRelevanceFieldEnum)[keyof typeof AvatarUserOrderByRelevanceFieldEnum]


  export const AddressesOrderByRelevanceFieldEnum: {
    cep: 'cep',
    road: 'road',
    number: 'number',
    complement: 'complement',
    neighborhood: 'neighborhood',
    city: 'city',
    state: 'state',
    country: 'country',
    type: 'type',
    reference: 'reference'
  };

  export type AddressesOrderByRelevanceFieldEnum = (typeof AddressesOrderByRelevanceFieldEnum)[keyof typeof AddressesOrderByRelevanceFieldEnum]


  export const StoresOrderByRelevanceFieldEnum: {
    name: 'name',
    cnpj: 'cnpj'
  };

  export type StoresOrderByRelevanceFieldEnum = (typeof StoresOrderByRelevanceFieldEnum)[keyof typeof StoresOrderByRelevanceFieldEnum]


  export const AvatarStoreOrderByRelevanceFieldEnum: {
    url: 'url',
    publicId: 'publicId'
  };

  export type AvatarStoreOrderByRelevanceFieldEnum = (typeof AvatarStoreOrderByRelevanceFieldEnum)[keyof typeof AvatarStoreOrderByRelevanceFieldEnum]


  export const StoreAvaliationsOrderByRelevanceFieldEnum: {
    comment: 'comment'
  };

  export type StoreAvaliationsOrderByRelevanceFieldEnum = (typeof StoreAvaliationsOrderByRelevanceFieldEnum)[keyof typeof StoreAvaliationsOrderByRelevanceFieldEnum]


  export const StoreAvaliationImagesOrderByRelevanceFieldEnum: {
    url: 'url',
    publicId: 'publicId'
  };

  export type StoreAvaliationImagesOrderByRelevanceFieldEnum = (typeof StoreAvaliationImagesOrderByRelevanceFieldEnum)[keyof typeof StoreAvaliationImagesOrderByRelevanceFieldEnum]


  export const CouponsOrderByRelevanceFieldEnum: {
    code: 'code'
  };

  export type CouponsOrderByRelevanceFieldEnum = (typeof CouponsOrderByRelevanceFieldEnum)[keyof typeof CouponsOrderByRelevanceFieldEnum]


  export const ProductsOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type ProductsOrderByRelevanceFieldEnum = (typeof ProductsOrderByRelevanceFieldEnum)[keyof typeof ProductsOrderByRelevanceFieldEnum]


  export const ProductImagesOrderByRelevanceFieldEnum: {
    url: 'url',
    publicId: 'publicId'
  };

  export type ProductImagesOrderByRelevanceFieldEnum = (typeof ProductImagesOrderByRelevanceFieldEnum)[keyof typeof ProductImagesOrderByRelevanceFieldEnum]


  export const PromotionOrderByRelevanceFieldEnum: {
    code: 'code',
    description: 'description',
    discountType: 'discountType'
  };

  export type PromotionOrderByRelevanceFieldEnum = (typeof PromotionOrderByRelevanceFieldEnum)[keyof typeof PromotionOrderByRelevanceFieldEnum]


  export const CategoryOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type CategoryOrderByRelevanceFieldEnum = (typeof CategoryOrderByRelevanceFieldEnum)[keyof typeof CategoryOrderByRelevanceFieldEnum]


  export const ProductAvaliationsOrderByRelevanceFieldEnum: {
    comment: 'comment'
  };

  export type ProductAvaliationsOrderByRelevanceFieldEnum = (typeof ProductAvaliationsOrderByRelevanceFieldEnum)[keyof typeof ProductAvaliationsOrderByRelevanceFieldEnum]


  export const ProductAvaliationImagesOrderByRelevanceFieldEnum: {
    url: 'url',
    publicId: 'publicId'
  };

  export type ProductAvaliationImagesOrderByRelevanceFieldEnum = (typeof ProductAvaliationImagesOrderByRelevanceFieldEnum)[keyof typeof ProductAvaliationImagesOrderByRelevanceFieldEnum]


  export const OrdersOrderByRelevanceFieldEnum: {
    trackingCode: 'trackingCode'
  };

  export type OrdersOrderByRelevanceFieldEnum = (typeof OrdersOrderByRelevanceFieldEnum)[keyof typeof OrdersOrderByRelevanceFieldEnum]


  export const OrderHistoryOrderByRelevanceFieldEnum: {
    action: 'action'
  };

  export type OrderHistoryOrderByRelevanceFieldEnum = (typeof OrderHistoryOrderByRelevanceFieldEnum)[keyof typeof OrderHistoryOrderByRelevanceFieldEnum]


  export const ShippingOrderByRelevanceFieldEnum: {
    shippingMethod: 'shippingMethod',
    trackingCode: 'trackingCode'
  };

  export type ShippingOrderByRelevanceFieldEnum = (typeof ShippingOrderByRelevanceFieldEnum)[keyof typeof ShippingOrderByRelevanceFieldEnum]


  export const chatMessagesOrderByRelevanceFieldEnum: {
    content: 'content'
  };

  export type chatMessagesOrderByRelevanceFieldEnum = (typeof chatMessagesOrderByRelevanceFieldEnum)[keyof typeof chatMessagesOrderByRelevanceFieldEnum]


  export const MessageImagesOrderByRelevanceFieldEnum: {
    url: 'url',
    publicId: 'publicId'
  };

  export type MessageImagesOrderByRelevanceFieldEnum = (typeof MessageImagesOrderByRelevanceFieldEnum)[keyof typeof MessageImagesOrderByRelevanceFieldEnum]


  export const LoginTokenOrderByRelevanceFieldEnum: {
    token: 'token'
  };

  export type LoginTokenOrderByRelevanceFieldEnum = (typeof LoginTokenOrderByRelevanceFieldEnum)[keyof typeof LoginTokenOrderByRelevanceFieldEnum]


  export const ConfirmationTokenOrderByRelevanceFieldEnum: {
    token: 'token'
  };

  export type ConfirmationTokenOrderByRelevanceFieldEnum = (typeof ConfirmationTokenOrderByRelevanceFieldEnum)[keyof typeof ConfirmationTokenOrderByRelevanceFieldEnum]


  export const LogOrderByRelevanceFieldEnum: {
    action: 'action',
    tableName: 'tableName',
    details: 'details'
  };

  export type LogOrderByRelevanceFieldEnum = (typeof LogOrderByRelevanceFieldEnum)[keyof typeof LogOrderByRelevanceFieldEnum]


  export const TwoFactorAuthOrderByRelevanceFieldEnum: {
    secret: 'secret'
  };

  export type TwoFactorAuthOrderByRelevanceFieldEnum = (typeof TwoFactorAuthOrderByRelevanceFieldEnum)[keyof typeof TwoFactorAuthOrderByRelevanceFieldEnum]


  export const ReturnExchangeOrderByRelevanceFieldEnum: {
    reason: 'reason'
  };

  export type ReturnExchangeOrderByRelevanceFieldEnum = (typeof ReturnExchangeOrderByRelevanceFieldEnum)[keyof typeof ReturnExchangeOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'PaymentMethodType'
   */
  export type EnumPaymentMethodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethodType'>
    


  /**
   * Reference to a field of type 'OrderStatusType'
   */
  export type EnumOrderStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatusType'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ReturnExchangeStatus'
   */
  export type EnumReturnExchangeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReturnExchangeStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    userId?: IntFilter<"Admin"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    userId?: IntWithAggregatesFilter<"Admin"> | number
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    name?: StringFilter<"User"> | string
    cpf?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    bornDate?: DateTimeFilter<"User"> | Date | string
    avatarId?: IntNullableFilter<"User"> | number | null
    principalAddressId?: IntNullableFilter<"User"> | number | null
    cartId?: IntFilter<"User"> | number
    avatar?: XOR<AvatarUserNullableScalarRelationFilter, AvatarUserWhereInput> | null
    tokenLogin?: XOR<LoginTokenNullableScalarRelationFilter, LoginTokenWhereInput> | null
    confirmationToken?: XOR<ConfirmationTokenNullableScalarRelationFilter, ConfirmationTokenWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    principalAddress?: XOR<AddressesNullableScalarRelationFilter, AddressesWhereInput> | null
    addresses?: AddressesListRelationFilter
    store?: XOR<StoresNullableScalarRelationFilter, StoresWhereInput> | null
    productAvaliations?: ProductAvaliationsListRelationFilter
    storeAvaliations?: StoreAvaliationsListRelationFilter
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    orders?: OrdersListRelationFilter
    usedCoupons?: UserUsedCouponsListRelationFilter
    chat?: ChatListRelationFilter
    sentMessages?: ChatMessagesListRelationFilter
    receivedMessages?: ChatMessagesListRelationFilter
    logs?: LogListRelationFilter
    TwoFactorAuth?: TwoFactorAuthListRelationFilter
    Wishlist?: WishlistListRelationFilter
    AbandonedCart?: AbandonedCartListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    cpf?: SortOrder
    email?: SortOrder
    password?: SortOrder
    bornDate?: SortOrder
    avatarId?: SortOrderInput | SortOrder
    principalAddressId?: SortOrderInput | SortOrder
    cartId?: SortOrder
    avatar?: AvatarUserOrderByWithRelationInput
    tokenLogin?: LoginTokenOrderByWithRelationInput
    confirmationToken?: ConfirmationTokenOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
    principalAddress?: AddressesOrderByWithRelationInput
    addresses?: AddressesOrderByRelationAggregateInput
    store?: StoresOrderByWithRelationInput
    productAvaliations?: ProductAvaliationsOrderByRelationAggregateInput
    storeAvaliations?: StoreAvaliationsOrderByRelationAggregateInput
    cart?: CartOrderByWithRelationInput
    orders?: OrdersOrderByRelationAggregateInput
    usedCoupons?: UserUsedCouponsOrderByRelationAggregateInput
    chat?: ChatOrderByRelationAggregateInput
    sentMessages?: chatMessagesOrderByRelationAggregateInput
    receivedMessages?: chatMessagesOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
    TwoFactorAuth?: TwoFactorAuthOrderByRelationAggregateInput
    Wishlist?: WishlistOrderByRelationAggregateInput
    AbandonedCart?: AbandonedCartOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cpf?: string
    email?: string
    avatarId?: number
    principalAddressId?: number
    cartId?: number
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    bornDate?: DateTimeFilter<"User"> | Date | string
    avatar?: XOR<AvatarUserNullableScalarRelationFilter, AvatarUserWhereInput> | null
    tokenLogin?: XOR<LoginTokenNullableScalarRelationFilter, LoginTokenWhereInput> | null
    confirmationToken?: XOR<ConfirmationTokenNullableScalarRelationFilter, ConfirmationTokenWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    principalAddress?: XOR<AddressesNullableScalarRelationFilter, AddressesWhereInput> | null
    addresses?: AddressesListRelationFilter
    store?: XOR<StoresNullableScalarRelationFilter, StoresWhereInput> | null
    productAvaliations?: ProductAvaliationsListRelationFilter
    storeAvaliations?: StoreAvaliationsListRelationFilter
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    orders?: OrdersListRelationFilter
    usedCoupons?: UserUsedCouponsListRelationFilter
    chat?: ChatListRelationFilter
    sentMessages?: ChatMessagesListRelationFilter
    receivedMessages?: ChatMessagesListRelationFilter
    logs?: LogListRelationFilter
    TwoFactorAuth?: TwoFactorAuthListRelationFilter
    Wishlist?: WishlistListRelationFilter
    AbandonedCart?: AbandonedCartListRelationFilter
  }, "id" | "cpf" | "email" | "avatarId" | "principalAddressId" | "cartId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    cpf?: SortOrder
    email?: SortOrder
    password?: SortOrder
    bornDate?: SortOrder
    avatarId?: SortOrderInput | SortOrder
    principalAddressId?: SortOrderInput | SortOrder
    cartId?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    name?: StringWithAggregatesFilter<"User"> | string
    cpf?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    bornDate?: DateTimeWithAggregatesFilter<"User"> | Date | string
    avatarId?: IntNullableWithAggregatesFilter<"User"> | number | null
    principalAddressId?: IntNullableWithAggregatesFilter<"User"> | number | null
    cartId?: IntWithAggregatesFilter<"User"> | number
  }

  export type AvatarUserWhereInput = {
    AND?: AvatarUserWhereInput | AvatarUserWhereInput[]
    OR?: AvatarUserWhereInput[]
    NOT?: AvatarUserWhereInput | AvatarUserWhereInput[]
    id?: IntFilter<"AvatarUser"> | number
    url?: StringFilter<"AvatarUser"> | string
    publicId?: StringFilter<"AvatarUser"> | string
    userId?: IntFilter<"AvatarUser"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AvatarUserOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: AvatarUserOrderByRelevanceInput
  }

  export type AvatarUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: AvatarUserWhereInput | AvatarUserWhereInput[]
    OR?: AvatarUserWhereInput[]
    NOT?: AvatarUserWhereInput | AvatarUserWhereInput[]
    url?: StringFilter<"AvatarUser"> | string
    publicId?: StringFilter<"AvatarUser"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AvatarUserOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    userId?: SortOrder
    _count?: AvatarUserCountOrderByAggregateInput
    _avg?: AvatarUserAvgOrderByAggregateInput
    _max?: AvatarUserMaxOrderByAggregateInput
    _min?: AvatarUserMinOrderByAggregateInput
    _sum?: AvatarUserSumOrderByAggregateInput
  }

  export type AvatarUserScalarWhereWithAggregatesInput = {
    AND?: AvatarUserScalarWhereWithAggregatesInput | AvatarUserScalarWhereWithAggregatesInput[]
    OR?: AvatarUserScalarWhereWithAggregatesInput[]
    NOT?: AvatarUserScalarWhereWithAggregatesInput | AvatarUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AvatarUser"> | number
    url?: StringWithAggregatesFilter<"AvatarUser"> | string
    publicId?: StringWithAggregatesFilter<"AvatarUser"> | string
    userId?: IntWithAggregatesFilter<"AvatarUser"> | number
  }

  export type AddressesWhereInput = {
    AND?: AddressesWhereInput | AddressesWhereInput[]
    OR?: AddressesWhereInput[]
    NOT?: AddressesWhereInput | AddressesWhereInput[]
    id?: IntFilter<"Addresses"> | number
    userId?: IntFilter<"Addresses"> | number
    cep?: StringFilter<"Addresses"> | string
    road?: StringFilter<"Addresses"> | string
    number?: StringFilter<"Addresses"> | string
    complement?: StringNullableFilter<"Addresses"> | string | null
    neighborhood?: StringFilter<"Addresses"> | string
    city?: StringFilter<"Addresses"> | string
    state?: StringFilter<"Addresses"> | string
    country?: StringFilter<"Addresses"> | string
    type?: StringNullableFilter<"Addresses"> | string | null
    reference?: StringNullableFilter<"Addresses"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    principalOf?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    order?: OrdersListRelationFilter
  }

  export type AddressesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    cep?: SortOrder
    road?: SortOrder
    number?: SortOrder
    complement?: SortOrderInput | SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    type?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    principalOf?: UserOrderByWithRelationInput
    order?: OrdersOrderByRelationAggregateInput
    _relevance?: AddressesOrderByRelevanceInput
  }

  export type AddressesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddressesWhereInput | AddressesWhereInput[]
    OR?: AddressesWhereInput[]
    NOT?: AddressesWhereInput | AddressesWhereInput[]
    userId?: IntFilter<"Addresses"> | number
    cep?: StringFilter<"Addresses"> | string
    road?: StringFilter<"Addresses"> | string
    number?: StringFilter<"Addresses"> | string
    complement?: StringNullableFilter<"Addresses"> | string | null
    neighborhood?: StringFilter<"Addresses"> | string
    city?: StringFilter<"Addresses"> | string
    state?: StringFilter<"Addresses"> | string
    country?: StringFilter<"Addresses"> | string
    type?: StringNullableFilter<"Addresses"> | string | null
    reference?: StringNullableFilter<"Addresses"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    principalOf?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    order?: OrdersListRelationFilter
  }, "id">

  export type AddressesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    cep?: SortOrder
    road?: SortOrder
    number?: SortOrder
    complement?: SortOrderInput | SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    type?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    _count?: AddressesCountOrderByAggregateInput
    _avg?: AddressesAvgOrderByAggregateInput
    _max?: AddressesMaxOrderByAggregateInput
    _min?: AddressesMinOrderByAggregateInput
    _sum?: AddressesSumOrderByAggregateInput
  }

  export type AddressesScalarWhereWithAggregatesInput = {
    AND?: AddressesScalarWhereWithAggregatesInput | AddressesScalarWhereWithAggregatesInput[]
    OR?: AddressesScalarWhereWithAggregatesInput[]
    NOT?: AddressesScalarWhereWithAggregatesInput | AddressesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Addresses"> | number
    userId?: IntWithAggregatesFilter<"Addresses"> | number
    cep?: StringWithAggregatesFilter<"Addresses"> | string
    road?: StringWithAggregatesFilter<"Addresses"> | string
    number?: StringWithAggregatesFilter<"Addresses"> | string
    complement?: StringNullableWithAggregatesFilter<"Addresses"> | string | null
    neighborhood?: StringWithAggregatesFilter<"Addresses"> | string
    city?: StringWithAggregatesFilter<"Addresses"> | string
    state?: StringWithAggregatesFilter<"Addresses"> | string
    country?: StringWithAggregatesFilter<"Addresses"> | string
    type?: StringNullableWithAggregatesFilter<"Addresses"> | string | null
    reference?: StringNullableWithAggregatesFilter<"Addresses"> | string | null
  }

  export type UserUsedCouponsWhereInput = {
    AND?: UserUsedCouponsWhereInput | UserUsedCouponsWhereInput[]
    OR?: UserUsedCouponsWhereInput[]
    NOT?: UserUsedCouponsWhereInput | UserUsedCouponsWhereInput[]
    id?: IntFilter<"UserUsedCoupons"> | number
    userId?: IntFilter<"UserUsedCoupons"> | number
    couponId?: IntFilter<"UserUsedCoupons"> | number
    usedAt?: DateTimeFilter<"UserUsedCoupons"> | Date | string
    orderId?: IntNullableFilter<"UserUsedCoupons"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coupon?: XOR<CouponsScalarRelationFilter, CouponsWhereInput>
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
  }

  export type UserUsedCouponsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    couponId?: SortOrder
    usedAt?: SortOrder
    orderId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    coupon?: CouponsOrderByWithRelationInput
    order?: OrdersOrderByWithRelationInput
  }

  export type UserUsedCouponsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderId?: number
    AND?: UserUsedCouponsWhereInput | UserUsedCouponsWhereInput[]
    OR?: UserUsedCouponsWhereInput[]
    NOT?: UserUsedCouponsWhereInput | UserUsedCouponsWhereInput[]
    userId?: IntFilter<"UserUsedCoupons"> | number
    couponId?: IntFilter<"UserUsedCoupons"> | number
    usedAt?: DateTimeFilter<"UserUsedCoupons"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coupon?: XOR<CouponsScalarRelationFilter, CouponsWhereInput>
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
  }, "id" | "orderId">

  export type UserUsedCouponsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    couponId?: SortOrder
    usedAt?: SortOrder
    orderId?: SortOrderInput | SortOrder
    _count?: UserUsedCouponsCountOrderByAggregateInput
    _avg?: UserUsedCouponsAvgOrderByAggregateInput
    _max?: UserUsedCouponsMaxOrderByAggregateInput
    _min?: UserUsedCouponsMinOrderByAggregateInput
    _sum?: UserUsedCouponsSumOrderByAggregateInput
  }

  export type UserUsedCouponsScalarWhereWithAggregatesInput = {
    AND?: UserUsedCouponsScalarWhereWithAggregatesInput | UserUsedCouponsScalarWhereWithAggregatesInput[]
    OR?: UserUsedCouponsScalarWhereWithAggregatesInput[]
    NOT?: UserUsedCouponsScalarWhereWithAggregatesInput | UserUsedCouponsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserUsedCoupons"> | number
    userId?: IntWithAggregatesFilter<"UserUsedCoupons"> | number
    couponId?: IntWithAggregatesFilter<"UserUsedCoupons"> | number
    usedAt?: DateTimeWithAggregatesFilter<"UserUsedCoupons"> | Date | string
    orderId?: IntNullableWithAggregatesFilter<"UserUsedCoupons"> | number | null
  }

  export type StoresWhereInput = {
    AND?: StoresWhereInput | StoresWhereInput[]
    OR?: StoresWhereInput[]
    NOT?: StoresWhereInput | StoresWhereInput[]
    id?: IntFilter<"Stores"> | number
    userId?: IntFilter<"Stores"> | number
    created_at?: DateTimeFilter<"Stores"> | Date | string
    updated_at?: DateTimeFilter<"Stores"> | Date | string
    name?: StringFilter<"Stores"> | string
    cnpj?: StringNullableFilter<"Stores"> | string | null
    avatarId?: IntNullableFilter<"Stores"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    avatar?: XOR<AvatarStoreNullableScalarRelationFilter, AvatarStoreWhereInput> | null
    product?: ProductsListRelationFilter
    avaliations?: StoreAvaliationsListRelationFilter
    coupons?: CouponsListRelationFilter
    chat?: ChatListRelationFilter
    sentMessages?: ChatMessagesListRelationFilter
    receivedMessages?: ChatMessagesListRelationFilter
    orderItems?: OrderItemsListRelationFilter
    promotions?: PromotionListRelationFilter
  }

  export type StoresOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    cnpj?: SortOrderInput | SortOrder
    avatarId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    avatar?: AvatarStoreOrderByWithRelationInput
    product?: ProductsOrderByRelationAggregateInput
    avaliations?: StoreAvaliationsOrderByRelationAggregateInput
    coupons?: CouponsOrderByRelationAggregateInput
    chat?: ChatOrderByRelationAggregateInput
    sentMessages?: chatMessagesOrderByRelationAggregateInput
    receivedMessages?: chatMessagesOrderByRelationAggregateInput
    orderItems?: OrderItemsOrderByRelationAggregateInput
    promotions?: PromotionOrderByRelationAggregateInput
    _relevance?: StoresOrderByRelevanceInput
  }

  export type StoresWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    cnpj?: string
    avatarId?: number
    AND?: StoresWhereInput | StoresWhereInput[]
    OR?: StoresWhereInput[]
    NOT?: StoresWhereInput | StoresWhereInput[]
    created_at?: DateTimeFilter<"Stores"> | Date | string
    updated_at?: DateTimeFilter<"Stores"> | Date | string
    name?: StringFilter<"Stores"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    avatar?: XOR<AvatarStoreNullableScalarRelationFilter, AvatarStoreWhereInput> | null
    product?: ProductsListRelationFilter
    avaliations?: StoreAvaliationsListRelationFilter
    coupons?: CouponsListRelationFilter
    chat?: ChatListRelationFilter
    sentMessages?: ChatMessagesListRelationFilter
    receivedMessages?: ChatMessagesListRelationFilter
    orderItems?: OrderItemsListRelationFilter
    promotions?: PromotionListRelationFilter
  }, "id" | "userId" | "cnpj" | "avatarId">

  export type StoresOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    cnpj?: SortOrderInput | SortOrder
    avatarId?: SortOrderInput | SortOrder
    _count?: StoresCountOrderByAggregateInput
    _avg?: StoresAvgOrderByAggregateInput
    _max?: StoresMaxOrderByAggregateInput
    _min?: StoresMinOrderByAggregateInput
    _sum?: StoresSumOrderByAggregateInput
  }

  export type StoresScalarWhereWithAggregatesInput = {
    AND?: StoresScalarWhereWithAggregatesInput | StoresScalarWhereWithAggregatesInput[]
    OR?: StoresScalarWhereWithAggregatesInput[]
    NOT?: StoresScalarWhereWithAggregatesInput | StoresScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Stores"> | number
    userId?: IntWithAggregatesFilter<"Stores"> | number
    created_at?: DateTimeWithAggregatesFilter<"Stores"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Stores"> | Date | string
    name?: StringWithAggregatesFilter<"Stores"> | string
    cnpj?: StringNullableWithAggregatesFilter<"Stores"> | string | null
    avatarId?: IntNullableWithAggregatesFilter<"Stores"> | number | null
  }

  export type AvatarStoreWhereInput = {
    AND?: AvatarStoreWhereInput | AvatarStoreWhereInput[]
    OR?: AvatarStoreWhereInput[]
    NOT?: AvatarStoreWhereInput | AvatarStoreWhereInput[]
    id?: IntFilter<"AvatarStore"> | number
    url?: StringFilter<"AvatarStore"> | string
    publicId?: StringFilter<"AvatarStore"> | string
    storeAvatar?: XOR<StoresNullableScalarRelationFilter, StoresWhereInput> | null
  }

  export type AvatarStoreOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    storeAvatar?: StoresOrderByWithRelationInput
    _relevance?: AvatarStoreOrderByRelevanceInput
  }

  export type AvatarStoreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AvatarStoreWhereInput | AvatarStoreWhereInput[]
    OR?: AvatarStoreWhereInput[]
    NOT?: AvatarStoreWhereInput | AvatarStoreWhereInput[]
    url?: StringFilter<"AvatarStore"> | string
    publicId?: StringFilter<"AvatarStore"> | string
    storeAvatar?: XOR<StoresNullableScalarRelationFilter, StoresWhereInput> | null
  }, "id">

  export type AvatarStoreOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    _count?: AvatarStoreCountOrderByAggregateInput
    _avg?: AvatarStoreAvgOrderByAggregateInput
    _max?: AvatarStoreMaxOrderByAggregateInput
    _min?: AvatarStoreMinOrderByAggregateInput
    _sum?: AvatarStoreSumOrderByAggregateInput
  }

  export type AvatarStoreScalarWhereWithAggregatesInput = {
    AND?: AvatarStoreScalarWhereWithAggregatesInput | AvatarStoreScalarWhereWithAggregatesInput[]
    OR?: AvatarStoreScalarWhereWithAggregatesInput[]
    NOT?: AvatarStoreScalarWhereWithAggregatesInput | AvatarStoreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AvatarStore"> | number
    url?: StringWithAggregatesFilter<"AvatarStore"> | string
    publicId?: StringWithAggregatesFilter<"AvatarStore"> | string
  }

  export type StoreAvaliationsWhereInput = {
    AND?: StoreAvaliationsWhereInput | StoreAvaliationsWhereInput[]
    OR?: StoreAvaliationsWhereInput[]
    NOT?: StoreAvaliationsWhereInput | StoreAvaliationsWhereInput[]
    id?: IntFilter<"StoreAvaliations"> | number
    userId?: IntFilter<"StoreAvaliations"> | number
    storeId?: IntFilter<"StoreAvaliations"> | number
    note?: IntFilter<"StoreAvaliations"> | number
    avaliationDate?: DateTimeFilter<"StoreAvaliations"> | Date | string
    comment?: StringNullableFilter<"StoreAvaliations"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    store?: XOR<StoresScalarRelationFilter, StoresWhereInput>
    images?: StoreAvaliationImagesListRelationFilter
  }

  export type StoreAvaliationsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    note?: SortOrder
    avaliationDate?: SortOrder
    comment?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    store?: StoresOrderByWithRelationInput
    images?: StoreAvaliationImagesOrderByRelationAggregateInput
    _relevance?: StoreAvaliationsOrderByRelevanceInput
  }

  export type StoreAvaliationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StoreAvaliationsWhereInput | StoreAvaliationsWhereInput[]
    OR?: StoreAvaliationsWhereInput[]
    NOT?: StoreAvaliationsWhereInput | StoreAvaliationsWhereInput[]
    userId?: IntFilter<"StoreAvaliations"> | number
    storeId?: IntFilter<"StoreAvaliations"> | number
    note?: IntFilter<"StoreAvaliations"> | number
    avaliationDate?: DateTimeFilter<"StoreAvaliations"> | Date | string
    comment?: StringNullableFilter<"StoreAvaliations"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    store?: XOR<StoresScalarRelationFilter, StoresWhereInput>
    images?: StoreAvaliationImagesListRelationFilter
  }, "id">

  export type StoreAvaliationsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    note?: SortOrder
    avaliationDate?: SortOrder
    comment?: SortOrderInput | SortOrder
    _count?: StoreAvaliationsCountOrderByAggregateInput
    _avg?: StoreAvaliationsAvgOrderByAggregateInput
    _max?: StoreAvaliationsMaxOrderByAggregateInput
    _min?: StoreAvaliationsMinOrderByAggregateInput
    _sum?: StoreAvaliationsSumOrderByAggregateInput
  }

  export type StoreAvaliationsScalarWhereWithAggregatesInput = {
    AND?: StoreAvaliationsScalarWhereWithAggregatesInput | StoreAvaliationsScalarWhereWithAggregatesInput[]
    OR?: StoreAvaliationsScalarWhereWithAggregatesInput[]
    NOT?: StoreAvaliationsScalarWhereWithAggregatesInput | StoreAvaliationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StoreAvaliations"> | number
    userId?: IntWithAggregatesFilter<"StoreAvaliations"> | number
    storeId?: IntWithAggregatesFilter<"StoreAvaliations"> | number
    note?: IntWithAggregatesFilter<"StoreAvaliations"> | number
    avaliationDate?: DateTimeWithAggregatesFilter<"StoreAvaliations"> | Date | string
    comment?: StringNullableWithAggregatesFilter<"StoreAvaliations"> | string | null
  }

  export type StoreAvaliationImagesWhereInput = {
    AND?: StoreAvaliationImagesWhereInput | StoreAvaliationImagesWhereInput[]
    OR?: StoreAvaliationImagesWhereInput[]
    NOT?: StoreAvaliationImagesWhereInput | StoreAvaliationImagesWhereInput[]
    id?: IntFilter<"StoreAvaliationImages"> | number
    url?: StringFilter<"StoreAvaliationImages"> | string
    publicId?: StringFilter<"StoreAvaliationImages"> | string
    storeAvaliationId?: IntNullableFilter<"StoreAvaliationImages"> | number | null
    storeAvaliation?: XOR<StoreAvaliationsNullableScalarRelationFilter, StoreAvaliationsWhereInput> | null
  }

  export type StoreAvaliationImagesOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    storeAvaliationId?: SortOrderInput | SortOrder
    storeAvaliation?: StoreAvaliationsOrderByWithRelationInput
    _relevance?: StoreAvaliationImagesOrderByRelevanceInput
  }

  export type StoreAvaliationImagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StoreAvaliationImagesWhereInput | StoreAvaliationImagesWhereInput[]
    OR?: StoreAvaliationImagesWhereInput[]
    NOT?: StoreAvaliationImagesWhereInput | StoreAvaliationImagesWhereInput[]
    url?: StringFilter<"StoreAvaliationImages"> | string
    publicId?: StringFilter<"StoreAvaliationImages"> | string
    storeAvaliationId?: IntNullableFilter<"StoreAvaliationImages"> | number | null
    storeAvaliation?: XOR<StoreAvaliationsNullableScalarRelationFilter, StoreAvaliationsWhereInput> | null
  }, "id">

  export type StoreAvaliationImagesOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    storeAvaliationId?: SortOrderInput | SortOrder
    _count?: StoreAvaliationImagesCountOrderByAggregateInput
    _avg?: StoreAvaliationImagesAvgOrderByAggregateInput
    _max?: StoreAvaliationImagesMaxOrderByAggregateInput
    _min?: StoreAvaliationImagesMinOrderByAggregateInput
    _sum?: StoreAvaliationImagesSumOrderByAggregateInput
  }

  export type StoreAvaliationImagesScalarWhereWithAggregatesInput = {
    AND?: StoreAvaliationImagesScalarWhereWithAggregatesInput | StoreAvaliationImagesScalarWhereWithAggregatesInput[]
    OR?: StoreAvaliationImagesScalarWhereWithAggregatesInput[]
    NOT?: StoreAvaliationImagesScalarWhereWithAggregatesInput | StoreAvaliationImagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StoreAvaliationImages"> | number
    url?: StringWithAggregatesFilter<"StoreAvaliationImages"> | string
    publicId?: StringWithAggregatesFilter<"StoreAvaliationImages"> | string
    storeAvaliationId?: IntNullableWithAggregatesFilter<"StoreAvaliationImages"> | number | null
  }

  export type CouponsWhereInput = {
    AND?: CouponsWhereInput | CouponsWhereInput[]
    OR?: CouponsWhereInput[]
    NOT?: CouponsWhereInput | CouponsWhereInput[]
    id?: IntFilter<"Coupons"> | number
    code?: StringFilter<"Coupons"> | string
    expirationDate?: DateTimeFilter<"Coupons"> | Date | string
    percentageDiscount?: IntFilter<"Coupons"> | number
    discountValue?: DecimalFilter<"Coupons"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Coupons"> | Date | string
    updatedAt?: DateTimeFilter<"Coupons"> | Date | string
    storeId?: IntFilter<"Coupons"> | number
    store?: XOR<StoresScalarRelationFilter, StoresWhereInput>
    usedCoupons?: UserUsedCouponsListRelationFilter
  }

  export type CouponsOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    expirationDate?: SortOrder
    percentageDiscount?: SortOrder
    discountValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    store?: StoresOrderByWithRelationInput
    usedCoupons?: UserUsedCouponsOrderByRelationAggregateInput
    _relevance?: CouponsOrderByRelevanceInput
  }

  export type CouponsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CouponsWhereInput | CouponsWhereInput[]
    OR?: CouponsWhereInput[]
    NOT?: CouponsWhereInput | CouponsWhereInput[]
    code?: StringFilter<"Coupons"> | string
    expirationDate?: DateTimeFilter<"Coupons"> | Date | string
    percentageDiscount?: IntFilter<"Coupons"> | number
    discountValue?: DecimalFilter<"Coupons"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Coupons"> | Date | string
    updatedAt?: DateTimeFilter<"Coupons"> | Date | string
    storeId?: IntFilter<"Coupons"> | number
    store?: XOR<StoresScalarRelationFilter, StoresWhereInput>
    usedCoupons?: UserUsedCouponsListRelationFilter
  }, "id">

  export type CouponsOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    expirationDate?: SortOrder
    percentageDiscount?: SortOrder
    discountValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    _count?: CouponsCountOrderByAggregateInput
    _avg?: CouponsAvgOrderByAggregateInput
    _max?: CouponsMaxOrderByAggregateInput
    _min?: CouponsMinOrderByAggregateInput
    _sum?: CouponsSumOrderByAggregateInput
  }

  export type CouponsScalarWhereWithAggregatesInput = {
    AND?: CouponsScalarWhereWithAggregatesInput | CouponsScalarWhereWithAggregatesInput[]
    OR?: CouponsScalarWhereWithAggregatesInput[]
    NOT?: CouponsScalarWhereWithAggregatesInput | CouponsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Coupons"> | number
    code?: StringWithAggregatesFilter<"Coupons"> | string
    expirationDate?: DateTimeWithAggregatesFilter<"Coupons"> | Date | string
    percentageDiscount?: IntWithAggregatesFilter<"Coupons"> | number
    discountValue?: DecimalWithAggregatesFilter<"Coupons"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Coupons"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Coupons"> | Date | string
    storeId?: IntWithAggregatesFilter<"Coupons"> | number
  }

  export type ProductsWhereInput = {
    AND?: ProductsWhereInput | ProductsWhereInput[]
    OR?: ProductsWhereInput[]
    NOT?: ProductsWhereInput | ProductsWhereInput[]
    id?: IntFilter<"Products"> | number
    storeId?: IntFilter<"Products"> | number
    created_at?: DateTimeFilter<"Products"> | Date | string
    updated_at?: DateTimeFilter<"Products"> | Date | string
    name?: StringFilter<"Products"> | string
    price?: DecimalFilter<"Products"> | Decimal | DecimalJsLike | number | string
    store?: XOR<StoresScalarRelationFilter, StoresWhereInput>
    inventory?: XOR<InventoryNullableScalarRelationFilter, InventoryWhereInput> | null
    images?: ProductImagesListRelationFilter
    category?: CategoryListRelationFilter
    avaliations?: ProductAvaliationsListRelationFilter
    promotions?: PromotionListRelationFilter
    cartItem?: CartItemsListRelationFilter
    orderItems?: OrderItemsListRelationFilter
    wishlists?: WishlistListRelationFilter
  }

  export type ProductsOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    price?: SortOrder
    store?: StoresOrderByWithRelationInput
    inventory?: InventoryOrderByWithRelationInput
    images?: ProductImagesOrderByRelationAggregateInput
    category?: CategoryOrderByRelationAggregateInput
    avaliations?: ProductAvaliationsOrderByRelationAggregateInput
    promotions?: PromotionOrderByRelationAggregateInput
    cartItem?: CartItemsOrderByRelationAggregateInput
    orderItems?: OrderItemsOrderByRelationAggregateInput
    wishlists?: WishlistOrderByRelationAggregateInput
    _relevance?: ProductsOrderByRelevanceInput
  }

  export type ProductsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductsWhereInput | ProductsWhereInput[]
    OR?: ProductsWhereInput[]
    NOT?: ProductsWhereInput | ProductsWhereInput[]
    storeId?: IntFilter<"Products"> | number
    created_at?: DateTimeFilter<"Products"> | Date | string
    updated_at?: DateTimeFilter<"Products"> | Date | string
    name?: StringFilter<"Products"> | string
    price?: DecimalFilter<"Products"> | Decimal | DecimalJsLike | number | string
    store?: XOR<StoresScalarRelationFilter, StoresWhereInput>
    inventory?: XOR<InventoryNullableScalarRelationFilter, InventoryWhereInput> | null
    images?: ProductImagesListRelationFilter
    category?: CategoryListRelationFilter
    avaliations?: ProductAvaliationsListRelationFilter
    promotions?: PromotionListRelationFilter
    cartItem?: CartItemsListRelationFilter
    orderItems?: OrderItemsListRelationFilter
    wishlists?: WishlistListRelationFilter
  }, "id">

  export type ProductsOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    price?: SortOrder
    _count?: ProductsCountOrderByAggregateInput
    _avg?: ProductsAvgOrderByAggregateInput
    _max?: ProductsMaxOrderByAggregateInput
    _min?: ProductsMinOrderByAggregateInput
    _sum?: ProductsSumOrderByAggregateInput
  }

  export type ProductsScalarWhereWithAggregatesInput = {
    AND?: ProductsScalarWhereWithAggregatesInput | ProductsScalarWhereWithAggregatesInput[]
    OR?: ProductsScalarWhereWithAggregatesInput[]
    NOT?: ProductsScalarWhereWithAggregatesInput | ProductsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Products"> | number
    storeId?: IntWithAggregatesFilter<"Products"> | number
    created_at?: DateTimeWithAggregatesFilter<"Products"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Products"> | Date | string
    name?: StringWithAggregatesFilter<"Products"> | string
    price?: DecimalWithAggregatesFilter<"Products"> | Decimal | DecimalJsLike | number | string
  }

  export type ProductImagesWhereInput = {
    AND?: ProductImagesWhereInput | ProductImagesWhereInput[]
    OR?: ProductImagesWhereInput[]
    NOT?: ProductImagesWhereInput | ProductImagesWhereInput[]
    id?: IntFilter<"ProductImages"> | number
    url?: StringFilter<"ProductImages"> | string
    publicId?: StringFilter<"ProductImages"> | string
    productId?: IntNullableFilter<"ProductImages"> | number | null
    product?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
  }

  export type ProductImagesOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    productId?: SortOrderInput | SortOrder
    product?: ProductsOrderByWithRelationInput
    _relevance?: ProductImagesOrderByRelevanceInput
  }

  export type ProductImagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductImagesWhereInput | ProductImagesWhereInput[]
    OR?: ProductImagesWhereInput[]
    NOT?: ProductImagesWhereInput | ProductImagesWhereInput[]
    url?: StringFilter<"ProductImages"> | string
    publicId?: StringFilter<"ProductImages"> | string
    productId?: IntNullableFilter<"ProductImages"> | number | null
    product?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
  }, "id">

  export type ProductImagesOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    productId?: SortOrderInput | SortOrder
    _count?: ProductImagesCountOrderByAggregateInput
    _avg?: ProductImagesAvgOrderByAggregateInput
    _max?: ProductImagesMaxOrderByAggregateInput
    _min?: ProductImagesMinOrderByAggregateInput
    _sum?: ProductImagesSumOrderByAggregateInput
  }

  export type ProductImagesScalarWhereWithAggregatesInput = {
    AND?: ProductImagesScalarWhereWithAggregatesInput | ProductImagesScalarWhereWithAggregatesInput[]
    OR?: ProductImagesScalarWhereWithAggregatesInput[]
    NOT?: ProductImagesScalarWhereWithAggregatesInput | ProductImagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductImages"> | number
    url?: StringWithAggregatesFilter<"ProductImages"> | string
    publicId?: StringWithAggregatesFilter<"ProductImages"> | string
    productId?: IntNullableWithAggregatesFilter<"ProductImages"> | number | null
  }

  export type WishlistWhereInput = {
    AND?: WishlistWhereInput | WishlistWhereInput[]
    OR?: WishlistWhereInput[]
    NOT?: WishlistWhereInput | WishlistWhereInput[]
    id?: IntFilter<"Wishlist"> | number
    userId?: IntFilter<"Wishlist"> | number
    createdAt?: DateTimeFilter<"Wishlist"> | Date | string
    updatedAt?: DateTimeFilter<"Wishlist"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    products?: ProductsListRelationFilter
  }

  export type WishlistOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    products?: ProductsOrderByRelationAggregateInput
  }

  export type WishlistWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WishlistWhereInput | WishlistWhereInput[]
    OR?: WishlistWhereInput[]
    NOT?: WishlistWhereInput | WishlistWhereInput[]
    userId?: IntFilter<"Wishlist"> | number
    createdAt?: DateTimeFilter<"Wishlist"> | Date | string
    updatedAt?: DateTimeFilter<"Wishlist"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    products?: ProductsListRelationFilter
  }, "id">

  export type WishlistOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WishlistCountOrderByAggregateInput
    _avg?: WishlistAvgOrderByAggregateInput
    _max?: WishlistMaxOrderByAggregateInput
    _min?: WishlistMinOrderByAggregateInput
    _sum?: WishlistSumOrderByAggregateInput
  }

  export type WishlistScalarWhereWithAggregatesInput = {
    AND?: WishlistScalarWhereWithAggregatesInput | WishlistScalarWhereWithAggregatesInput[]
    OR?: WishlistScalarWhereWithAggregatesInput[]
    NOT?: WishlistScalarWhereWithAggregatesInput | WishlistScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Wishlist"> | number
    userId?: IntWithAggregatesFilter<"Wishlist"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Wishlist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Wishlist"> | Date | string
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: IntFilter<"Inventory"> | number
    productId?: IntFilter<"Inventory"> | number
    quantity?: IntFilter<"Inventory"> | number
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    product?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductsOrderByWithRelationInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    productId?: number
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    quantity?: IntFilter<"Inventory"> | number
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    product?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
  }, "id" | "productId">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inventory"> | number
    productId?: IntWithAggregatesFilter<"Inventory"> | number
    quantity?: IntWithAggregatesFilter<"Inventory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
  }

  export type PromotionWhereInput = {
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    id?: IntFilter<"Promotion"> | number
    code?: StringFilter<"Promotion"> | string
    description?: StringFilter<"Promotion"> | string
    discountType?: StringFilter<"Promotion"> | string
    discountValue?: DecimalFilter<"Promotion"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    storeId?: IntFilter<"Promotion"> | number
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    store?: XOR<StoresScalarRelationFilter, StoresWhereInput>
    products?: ProductsListRelationFilter
  }

  export type PromotionOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoresOrderByWithRelationInput
    products?: ProductsOrderByRelationAggregateInput
    _relevance?: PromotionOrderByRelevanceInput
  }

  export type PromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    description?: StringFilter<"Promotion"> | string
    discountType?: StringFilter<"Promotion"> | string
    discountValue?: DecimalFilter<"Promotion"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    storeId?: IntFilter<"Promotion"> | number
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    store?: XOR<StoresScalarRelationFilter, StoresWhereInput>
    products?: ProductsListRelationFilter
  }, "id" | "code">

  export type PromotionOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromotionCountOrderByAggregateInput
    _avg?: PromotionAvgOrderByAggregateInput
    _max?: PromotionMaxOrderByAggregateInput
    _min?: PromotionMinOrderByAggregateInput
    _sum?: PromotionSumOrderByAggregateInput
  }

  export type PromotionScalarWhereWithAggregatesInput = {
    AND?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    OR?: PromotionScalarWhereWithAggregatesInput[]
    NOT?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Promotion"> | number
    code?: StringWithAggregatesFilter<"Promotion"> | string
    description?: StringWithAggregatesFilter<"Promotion"> | string
    discountType?: StringWithAggregatesFilter<"Promotion"> | string
    discountValue?: DecimalWithAggregatesFilter<"Promotion"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    storeId?: IntWithAggregatesFilter<"Promotion"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    product?: ProductsListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    product?: ProductsOrderByRelationAggregateInput
    _relevance?: CategoryOrderByRelevanceInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    product?: ProductsListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    name?: StringWithAggregatesFilter<"Category"> | string
  }

  export type ProductAvaliationsWhereInput = {
    AND?: ProductAvaliationsWhereInput | ProductAvaliationsWhereInput[]
    OR?: ProductAvaliationsWhereInput[]
    NOT?: ProductAvaliationsWhereInput | ProductAvaliationsWhereInput[]
    id?: IntFilter<"ProductAvaliations"> | number
    userId?: IntFilter<"ProductAvaliations"> | number
    productId?: IntFilter<"ProductAvaliations"> | number
    note?: IntFilter<"ProductAvaliations"> | number
    avaliationDate?: DateTimeFilter<"ProductAvaliations"> | Date | string
    comment?: StringNullableFilter<"ProductAvaliations"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
    images?: ProductAvaliationImagesListRelationFilter
  }

  export type ProductAvaliationsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    note?: SortOrder
    avaliationDate?: SortOrder
    comment?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    product?: ProductsOrderByWithRelationInput
    images?: ProductAvaliationImagesOrderByRelationAggregateInput
    _relevance?: ProductAvaliationsOrderByRelevanceInput
  }

  export type ProductAvaliationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductAvaliationsWhereInput | ProductAvaliationsWhereInput[]
    OR?: ProductAvaliationsWhereInput[]
    NOT?: ProductAvaliationsWhereInput | ProductAvaliationsWhereInput[]
    userId?: IntFilter<"ProductAvaliations"> | number
    productId?: IntFilter<"ProductAvaliations"> | number
    note?: IntFilter<"ProductAvaliations"> | number
    avaliationDate?: DateTimeFilter<"ProductAvaliations"> | Date | string
    comment?: StringNullableFilter<"ProductAvaliations"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
    images?: ProductAvaliationImagesListRelationFilter
  }, "id">

  export type ProductAvaliationsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    note?: SortOrder
    avaliationDate?: SortOrder
    comment?: SortOrderInput | SortOrder
    _count?: ProductAvaliationsCountOrderByAggregateInput
    _avg?: ProductAvaliationsAvgOrderByAggregateInput
    _max?: ProductAvaliationsMaxOrderByAggregateInput
    _min?: ProductAvaliationsMinOrderByAggregateInput
    _sum?: ProductAvaliationsSumOrderByAggregateInput
  }

  export type ProductAvaliationsScalarWhereWithAggregatesInput = {
    AND?: ProductAvaliationsScalarWhereWithAggregatesInput | ProductAvaliationsScalarWhereWithAggregatesInput[]
    OR?: ProductAvaliationsScalarWhereWithAggregatesInput[]
    NOT?: ProductAvaliationsScalarWhereWithAggregatesInput | ProductAvaliationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductAvaliations"> | number
    userId?: IntWithAggregatesFilter<"ProductAvaliations"> | number
    productId?: IntWithAggregatesFilter<"ProductAvaliations"> | number
    note?: IntWithAggregatesFilter<"ProductAvaliations"> | number
    avaliationDate?: DateTimeWithAggregatesFilter<"ProductAvaliations"> | Date | string
    comment?: StringNullableWithAggregatesFilter<"ProductAvaliations"> | string | null
  }

  export type ProductAvaliationImagesWhereInput = {
    AND?: ProductAvaliationImagesWhereInput | ProductAvaliationImagesWhereInput[]
    OR?: ProductAvaliationImagesWhereInput[]
    NOT?: ProductAvaliationImagesWhereInput | ProductAvaliationImagesWhereInput[]
    id?: IntFilter<"ProductAvaliationImages"> | number
    url?: StringFilter<"ProductAvaliationImages"> | string
    publicId?: StringFilter<"ProductAvaliationImages"> | string
    productAvaliationId?: IntNullableFilter<"ProductAvaliationImages"> | number | null
    productAvaliation?: XOR<ProductAvaliationsNullableScalarRelationFilter, ProductAvaliationsWhereInput> | null
  }

  export type ProductAvaliationImagesOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    productAvaliationId?: SortOrderInput | SortOrder
    productAvaliation?: ProductAvaliationsOrderByWithRelationInput
    _relevance?: ProductAvaliationImagesOrderByRelevanceInput
  }

  export type ProductAvaliationImagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductAvaliationImagesWhereInput | ProductAvaliationImagesWhereInput[]
    OR?: ProductAvaliationImagesWhereInput[]
    NOT?: ProductAvaliationImagesWhereInput | ProductAvaliationImagesWhereInput[]
    url?: StringFilter<"ProductAvaliationImages"> | string
    publicId?: StringFilter<"ProductAvaliationImages"> | string
    productAvaliationId?: IntNullableFilter<"ProductAvaliationImages"> | number | null
    productAvaliation?: XOR<ProductAvaliationsNullableScalarRelationFilter, ProductAvaliationsWhereInput> | null
  }, "id">

  export type ProductAvaliationImagesOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    productAvaliationId?: SortOrderInput | SortOrder
    _count?: ProductAvaliationImagesCountOrderByAggregateInput
    _avg?: ProductAvaliationImagesAvgOrderByAggregateInput
    _max?: ProductAvaliationImagesMaxOrderByAggregateInput
    _min?: ProductAvaliationImagesMinOrderByAggregateInput
    _sum?: ProductAvaliationImagesSumOrderByAggregateInput
  }

  export type ProductAvaliationImagesScalarWhereWithAggregatesInput = {
    AND?: ProductAvaliationImagesScalarWhereWithAggregatesInput | ProductAvaliationImagesScalarWhereWithAggregatesInput[]
    OR?: ProductAvaliationImagesScalarWhereWithAggregatesInput[]
    NOT?: ProductAvaliationImagesScalarWhereWithAggregatesInput | ProductAvaliationImagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductAvaliationImages"> | number
    url?: StringWithAggregatesFilter<"ProductAvaliationImages"> | string
    publicId?: StringWithAggregatesFilter<"ProductAvaliationImages"> | string
    productAvaliationId?: IntNullableWithAggregatesFilter<"ProductAvaliationImages"> | number | null
  }

  export type CartWhereInput = {
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    id?: IntFilter<"Cart"> | number
    userCart?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    cartItems?: CartItemsListRelationFilter
  }

  export type CartOrderByWithRelationInput = {
    id?: SortOrder
    userCart?: UserOrderByWithRelationInput
    cartItems?: CartItemsOrderByRelationAggregateInput
  }

  export type CartWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    userCart?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    cartItems?: CartItemsListRelationFilter
  }, "id">

  export type CartOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: CartCountOrderByAggregateInput
    _avg?: CartAvgOrderByAggregateInput
    _max?: CartMaxOrderByAggregateInput
    _min?: CartMinOrderByAggregateInput
    _sum?: CartSumOrderByAggregateInput
  }

  export type CartScalarWhereWithAggregatesInput = {
    AND?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    OR?: CartScalarWhereWithAggregatesInput[]
    NOT?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cart"> | number
  }

  export type CartItemsWhereInput = {
    AND?: CartItemsWhereInput | CartItemsWhereInput[]
    OR?: CartItemsWhereInput[]
    NOT?: CartItemsWhereInput | CartItemsWhereInput[]
    id?: IntFilter<"CartItems"> | number
    cartId?: IntFilter<"CartItems"> | number
    productId?: IntFilter<"CartItems"> | number
    quantidade?: IntFilter<"CartItems"> | number
    abandonedCartId?: IntNullableFilter<"CartItems"> | number | null
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
    AbandonedCart?: XOR<AbandonedCartNullableScalarRelationFilter, AbandonedCartWhereInput> | null
  }

  export type CartItemsOrderByWithRelationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantidade?: SortOrder
    abandonedCartId?: SortOrderInput | SortOrder
    cart?: CartOrderByWithRelationInput
    product?: ProductsOrderByWithRelationInput
    AbandonedCart?: AbandonedCartOrderByWithRelationInput
  }

  export type CartItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CartItemsWhereInput | CartItemsWhereInput[]
    OR?: CartItemsWhereInput[]
    NOT?: CartItemsWhereInput | CartItemsWhereInput[]
    cartId?: IntFilter<"CartItems"> | number
    productId?: IntFilter<"CartItems"> | number
    quantidade?: IntFilter<"CartItems"> | number
    abandonedCartId?: IntNullableFilter<"CartItems"> | number | null
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
    AbandonedCart?: XOR<AbandonedCartNullableScalarRelationFilter, AbandonedCartWhereInput> | null
  }, "id">

  export type CartItemsOrderByWithAggregationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantidade?: SortOrder
    abandonedCartId?: SortOrderInput | SortOrder
    _count?: CartItemsCountOrderByAggregateInput
    _avg?: CartItemsAvgOrderByAggregateInput
    _max?: CartItemsMaxOrderByAggregateInput
    _min?: CartItemsMinOrderByAggregateInput
    _sum?: CartItemsSumOrderByAggregateInput
  }

  export type CartItemsScalarWhereWithAggregatesInput = {
    AND?: CartItemsScalarWhereWithAggregatesInput | CartItemsScalarWhereWithAggregatesInput[]
    OR?: CartItemsScalarWhereWithAggregatesInput[]
    NOT?: CartItemsScalarWhereWithAggregatesInput | CartItemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CartItems"> | number
    cartId?: IntWithAggregatesFilter<"CartItems"> | number
    productId?: IntWithAggregatesFilter<"CartItems"> | number
    quantidade?: IntWithAggregatesFilter<"CartItems"> | number
    abandonedCartId?: IntNullableWithAggregatesFilter<"CartItems"> | number | null
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: IntFilter<"PaymentMethod"> | number
    method?: EnumPaymentMethodTypeFilter<"PaymentMethod"> | $Enums.PaymentMethodType
    payments?: PaymentListRelationFilter
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    method?: SortOrder
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    method?: EnumPaymentMethodTypeFilter<"PaymentMethod"> | $Enums.PaymentMethodType
    payments?: PaymentListRelationFilter
  }, "id">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    method?: SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _avg?: PaymentMethodAvgOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
    _sum?: PaymentMethodSumOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaymentMethod"> | number
    method?: EnumPaymentMethodTypeWithAggregatesFilter<"PaymentMethod"> | $Enums.PaymentMethodType
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    valor?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethodId?: IntFilter<"Payment"> | number
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    valor?: SortOrder
    paymentDate?: SortOrder
    paymentMethodId?: SortOrder
    paymentMethod?: PaymentMethodOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    valor?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethodId?: IntFilter<"Payment"> | number
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    valor?: SortOrder
    paymentDate?: SortOrder
    paymentMethodId?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    valor?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    paymentMethodId?: IntWithAggregatesFilter<"Payment"> | number
  }

  export type OrderStatusWhereInput = {
    AND?: OrderStatusWhereInput | OrderStatusWhereInput[]
    OR?: OrderStatusWhereInput[]
    NOT?: OrderStatusWhereInput | OrderStatusWhereInput[]
    id?: IntFilter<"OrderStatus"> | number
    Status?: EnumOrderStatusTypeFilter<"OrderStatus"> | $Enums.OrderStatusType
    orders?: OrdersListRelationFilter
  }

  export type OrderStatusOrderByWithRelationInput = {
    id?: SortOrder
    Status?: SortOrder
    orders?: OrdersOrderByRelationAggregateInput
  }

  export type OrderStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderStatusWhereInput | OrderStatusWhereInput[]
    OR?: OrderStatusWhereInput[]
    NOT?: OrderStatusWhereInput | OrderStatusWhereInput[]
    Status?: EnumOrderStatusTypeFilter<"OrderStatus"> | $Enums.OrderStatusType
    orders?: OrdersListRelationFilter
  }, "id">

  export type OrderStatusOrderByWithAggregationInput = {
    id?: SortOrder
    Status?: SortOrder
    _count?: OrderStatusCountOrderByAggregateInput
    _avg?: OrderStatusAvgOrderByAggregateInput
    _max?: OrderStatusMaxOrderByAggregateInput
    _min?: OrderStatusMinOrderByAggregateInput
    _sum?: OrderStatusSumOrderByAggregateInput
  }

  export type OrderStatusScalarWhereWithAggregatesInput = {
    AND?: OrderStatusScalarWhereWithAggregatesInput | OrderStatusScalarWhereWithAggregatesInput[]
    OR?: OrderStatusScalarWhereWithAggregatesInput[]
    NOT?: OrderStatusScalarWhereWithAggregatesInput | OrderStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderStatus"> | number
    Status?: EnumOrderStatusTypeWithAggregatesFilter<"OrderStatus"> | $Enums.OrderStatusType
  }

  export type OrdersWhereInput = {
    AND?: OrdersWhereInput | OrdersWhereInput[]
    OR?: OrdersWhereInput[]
    NOT?: OrdersWhereInput | OrdersWhereInput[]
    id?: IntFilter<"Orders"> | number
    totalValue?: DecimalFilter<"Orders"> | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFilter<"Orders"> | string
    createdAt?: DateTimeFilter<"Orders"> | Date | string
    updatedAt?: DateTimeFilter<"Orders"> | Date | string
    sendDate?: DateTimeFilter<"Orders"> | Date | string
    deliveryDate?: DateTimeFilter<"Orders"> | Date | string
    minimumDeliveryForeast?: DateTimeFilter<"Orders"> | Date | string
    maximumDeliveryForeast?: DateTimeFilter<"Orders"> | Date | string
    usedCoupon?: BoolFilter<"Orders"> | boolean
    userId?: IntFilter<"Orders"> | number
    orderStatusId?: IntFilter<"Orders"> | number
    deliveryAddressId?: IntFilter<"Orders"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    orderStatus?: XOR<OrderStatusScalarRelationFilter, OrderStatusWhereInput>
    deliveryAddress?: XOR<AddressesScalarRelationFilter, AddressesWhereInput>
    usedCoupons?: UserUsedCouponsListRelationFilter
    orderItems?: OrderItemsListRelationFilter
    orderHistory?: OrderHistoryListRelationFilter
    shipping?: XOR<ShippingNullableScalarRelationFilter, ShippingWhereInput> | null
    ReturnExchange?: ReturnExchangeListRelationFilter
  }

  export type OrdersOrderByWithRelationInput = {
    id?: SortOrder
    totalValue?: SortOrder
    trackingCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sendDate?: SortOrder
    deliveryDate?: SortOrder
    minimumDeliveryForeast?: SortOrder
    maximumDeliveryForeast?: SortOrder
    usedCoupon?: SortOrder
    userId?: SortOrder
    orderStatusId?: SortOrder
    deliveryAddressId?: SortOrder
    user?: UserOrderByWithRelationInput
    orderStatus?: OrderStatusOrderByWithRelationInput
    deliveryAddress?: AddressesOrderByWithRelationInput
    usedCoupons?: UserUsedCouponsOrderByRelationAggregateInput
    orderItems?: OrderItemsOrderByRelationAggregateInput
    orderHistory?: OrderHistoryOrderByRelationAggregateInput
    shipping?: ShippingOrderByWithRelationInput
    ReturnExchange?: ReturnExchangeOrderByRelationAggregateInput
    _relevance?: OrdersOrderByRelevanceInput
  }

  export type OrdersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrdersWhereInput | OrdersWhereInput[]
    OR?: OrdersWhereInput[]
    NOT?: OrdersWhereInput | OrdersWhereInput[]
    totalValue?: DecimalFilter<"Orders"> | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFilter<"Orders"> | string
    createdAt?: DateTimeFilter<"Orders"> | Date | string
    updatedAt?: DateTimeFilter<"Orders"> | Date | string
    sendDate?: DateTimeFilter<"Orders"> | Date | string
    deliveryDate?: DateTimeFilter<"Orders"> | Date | string
    minimumDeliveryForeast?: DateTimeFilter<"Orders"> | Date | string
    maximumDeliveryForeast?: DateTimeFilter<"Orders"> | Date | string
    usedCoupon?: BoolFilter<"Orders"> | boolean
    userId?: IntFilter<"Orders"> | number
    orderStatusId?: IntFilter<"Orders"> | number
    deliveryAddressId?: IntFilter<"Orders"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    orderStatus?: XOR<OrderStatusScalarRelationFilter, OrderStatusWhereInput>
    deliveryAddress?: XOR<AddressesScalarRelationFilter, AddressesWhereInput>
    usedCoupons?: UserUsedCouponsListRelationFilter
    orderItems?: OrderItemsListRelationFilter
    orderHistory?: OrderHistoryListRelationFilter
    shipping?: XOR<ShippingNullableScalarRelationFilter, ShippingWhereInput> | null
    ReturnExchange?: ReturnExchangeListRelationFilter
  }, "id">

  export type OrdersOrderByWithAggregationInput = {
    id?: SortOrder
    totalValue?: SortOrder
    trackingCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sendDate?: SortOrder
    deliveryDate?: SortOrder
    minimumDeliveryForeast?: SortOrder
    maximumDeliveryForeast?: SortOrder
    usedCoupon?: SortOrder
    userId?: SortOrder
    orderStatusId?: SortOrder
    deliveryAddressId?: SortOrder
    _count?: OrdersCountOrderByAggregateInput
    _avg?: OrdersAvgOrderByAggregateInput
    _max?: OrdersMaxOrderByAggregateInput
    _min?: OrdersMinOrderByAggregateInput
    _sum?: OrdersSumOrderByAggregateInput
  }

  export type OrdersScalarWhereWithAggregatesInput = {
    AND?: OrdersScalarWhereWithAggregatesInput | OrdersScalarWhereWithAggregatesInput[]
    OR?: OrdersScalarWhereWithAggregatesInput[]
    NOT?: OrdersScalarWhereWithAggregatesInput | OrdersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Orders"> | number
    totalValue?: DecimalWithAggregatesFilter<"Orders"> | Decimal | DecimalJsLike | number | string
    trackingCode?: StringWithAggregatesFilter<"Orders"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Orders"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Orders"> | Date | string
    sendDate?: DateTimeWithAggregatesFilter<"Orders"> | Date | string
    deliveryDate?: DateTimeWithAggregatesFilter<"Orders"> | Date | string
    minimumDeliveryForeast?: DateTimeWithAggregatesFilter<"Orders"> | Date | string
    maximumDeliveryForeast?: DateTimeWithAggregatesFilter<"Orders"> | Date | string
    usedCoupon?: BoolWithAggregatesFilter<"Orders"> | boolean
    userId?: IntWithAggregatesFilter<"Orders"> | number
    orderStatusId?: IntWithAggregatesFilter<"Orders"> | number
    deliveryAddressId?: IntWithAggregatesFilter<"Orders"> | number
  }

  export type OrderHistoryWhereInput = {
    AND?: OrderHistoryWhereInput | OrderHistoryWhereInput[]
    OR?: OrderHistoryWhereInput[]
    NOT?: OrderHistoryWhereInput | OrderHistoryWhereInput[]
    id?: IntFilter<"OrderHistory"> | number
    orderId?: IntFilter<"OrderHistory"> | number
    action?: StringFilter<"OrderHistory"> | string
    updatedAt?: DateTimeFilter<"OrderHistory"> | Date | string
    order?: XOR<OrdersScalarRelationFilter, OrdersWhereInput>
  }

  export type OrderHistoryOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    action?: SortOrder
    updatedAt?: SortOrder
    order?: OrdersOrderByWithRelationInput
    _relevance?: OrderHistoryOrderByRelevanceInput
  }

  export type OrderHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderHistoryWhereInput | OrderHistoryWhereInput[]
    OR?: OrderHistoryWhereInput[]
    NOT?: OrderHistoryWhereInput | OrderHistoryWhereInput[]
    orderId?: IntFilter<"OrderHistory"> | number
    action?: StringFilter<"OrderHistory"> | string
    updatedAt?: DateTimeFilter<"OrderHistory"> | Date | string
    order?: XOR<OrdersScalarRelationFilter, OrdersWhereInput>
  }, "id">

  export type OrderHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    action?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderHistoryCountOrderByAggregateInput
    _avg?: OrderHistoryAvgOrderByAggregateInput
    _max?: OrderHistoryMaxOrderByAggregateInput
    _min?: OrderHistoryMinOrderByAggregateInput
    _sum?: OrderHistorySumOrderByAggregateInput
  }

  export type OrderHistoryScalarWhereWithAggregatesInput = {
    AND?: OrderHistoryScalarWhereWithAggregatesInput | OrderHistoryScalarWhereWithAggregatesInput[]
    OR?: OrderHistoryScalarWhereWithAggregatesInput[]
    NOT?: OrderHistoryScalarWhereWithAggregatesInput | OrderHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderHistory"> | number
    orderId?: IntWithAggregatesFilter<"OrderHistory"> | number
    action?: StringWithAggregatesFilter<"OrderHistory"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderHistory"> | Date | string
  }

  export type OrderItemsWhereInput = {
    AND?: OrderItemsWhereInput | OrderItemsWhereInput[]
    OR?: OrderItemsWhereInput[]
    NOT?: OrderItemsWhereInput | OrderItemsWhereInput[]
    id?: IntFilter<"OrderItems"> | number
    orderId?: IntFilter<"OrderItems"> | number
    productId?: IntFilter<"OrderItems"> | number
    storeId?: IntFilter<"OrderItems"> | number
    quantity?: IntFilter<"OrderItems"> | number
    price?: DecimalFilter<"OrderItems"> | Decimal | DecimalJsLike | number | string
    order?: XOR<OrdersScalarRelationFilter, OrdersWhereInput>
    product?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
    store?: XOR<StoresScalarRelationFilter, StoresWhereInput>
  }

  export type OrderItemsOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    order?: OrdersOrderByWithRelationInput
    product?: ProductsOrderByWithRelationInput
    store?: StoresOrderByWithRelationInput
  }

  export type OrderItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderItemsWhereInput | OrderItemsWhereInput[]
    OR?: OrderItemsWhereInput[]
    NOT?: OrderItemsWhereInput | OrderItemsWhereInput[]
    orderId?: IntFilter<"OrderItems"> | number
    productId?: IntFilter<"OrderItems"> | number
    storeId?: IntFilter<"OrderItems"> | number
    quantity?: IntFilter<"OrderItems"> | number
    price?: DecimalFilter<"OrderItems"> | Decimal | DecimalJsLike | number | string
    order?: XOR<OrdersScalarRelationFilter, OrdersWhereInput>
    product?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
    store?: XOR<StoresScalarRelationFilter, StoresWhereInput>
  }, "id">

  export type OrderItemsOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    _count?: OrderItemsCountOrderByAggregateInput
    _avg?: OrderItemsAvgOrderByAggregateInput
    _max?: OrderItemsMaxOrderByAggregateInput
    _min?: OrderItemsMinOrderByAggregateInput
    _sum?: OrderItemsSumOrderByAggregateInput
  }

  export type OrderItemsScalarWhereWithAggregatesInput = {
    AND?: OrderItemsScalarWhereWithAggregatesInput | OrderItemsScalarWhereWithAggregatesInput[]
    OR?: OrderItemsScalarWhereWithAggregatesInput[]
    NOT?: OrderItemsScalarWhereWithAggregatesInput | OrderItemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItems"> | number
    orderId?: IntWithAggregatesFilter<"OrderItems"> | number
    productId?: IntWithAggregatesFilter<"OrderItems"> | number
    storeId?: IntWithAggregatesFilter<"OrderItems"> | number
    quantity?: IntWithAggregatesFilter<"OrderItems"> | number
    price?: DecimalWithAggregatesFilter<"OrderItems"> | Decimal | DecimalJsLike | number | string
  }

  export type ShippingWhereInput = {
    AND?: ShippingWhereInput | ShippingWhereInput[]
    OR?: ShippingWhereInput[]
    NOT?: ShippingWhereInput | ShippingWhereInput[]
    id?: IntFilter<"Shipping"> | number
    orderId?: IntFilter<"Shipping"> | number
    shippingMethod?: StringFilter<"Shipping"> | string
    shippingCost?: DecimalFilter<"Shipping"> | Decimal | DecimalJsLike | number | string
    estimatedDelivery?: DateTimeFilter<"Shipping"> | Date | string
    trackingCode?: StringNullableFilter<"Shipping"> | string | null
    createdAt?: DateTimeFilter<"Shipping"> | Date | string
    updatedAt?: DateTimeFilter<"Shipping"> | Date | string
    order?: XOR<OrdersScalarRelationFilter, OrdersWhereInput>
  }

  export type ShippingOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    shippingMethod?: SortOrder
    shippingCost?: SortOrder
    estimatedDelivery?: SortOrder
    trackingCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrdersOrderByWithRelationInput
    _relevance?: ShippingOrderByRelevanceInput
  }

  export type ShippingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderId?: number
    AND?: ShippingWhereInput | ShippingWhereInput[]
    OR?: ShippingWhereInput[]
    NOT?: ShippingWhereInput | ShippingWhereInput[]
    shippingMethod?: StringFilter<"Shipping"> | string
    shippingCost?: DecimalFilter<"Shipping"> | Decimal | DecimalJsLike | number | string
    estimatedDelivery?: DateTimeFilter<"Shipping"> | Date | string
    trackingCode?: StringNullableFilter<"Shipping"> | string | null
    createdAt?: DateTimeFilter<"Shipping"> | Date | string
    updatedAt?: DateTimeFilter<"Shipping"> | Date | string
    order?: XOR<OrdersScalarRelationFilter, OrdersWhereInput>
  }, "id" | "orderId">

  export type ShippingOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    shippingMethod?: SortOrder
    shippingCost?: SortOrder
    estimatedDelivery?: SortOrder
    trackingCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShippingCountOrderByAggregateInput
    _avg?: ShippingAvgOrderByAggregateInput
    _max?: ShippingMaxOrderByAggregateInput
    _min?: ShippingMinOrderByAggregateInput
    _sum?: ShippingSumOrderByAggregateInput
  }

  export type ShippingScalarWhereWithAggregatesInput = {
    AND?: ShippingScalarWhereWithAggregatesInput | ShippingScalarWhereWithAggregatesInput[]
    OR?: ShippingScalarWhereWithAggregatesInput[]
    NOT?: ShippingScalarWhereWithAggregatesInput | ShippingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Shipping"> | number
    orderId?: IntWithAggregatesFilter<"Shipping"> | number
    shippingMethod?: StringWithAggregatesFilter<"Shipping"> | string
    shippingCost?: DecimalWithAggregatesFilter<"Shipping"> | Decimal | DecimalJsLike | number | string
    estimatedDelivery?: DateTimeWithAggregatesFilter<"Shipping"> | Date | string
    trackingCode?: StringNullableWithAggregatesFilter<"Shipping"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Shipping"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shipping"> | Date | string
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: IntFilter<"Chat"> | number
    userId?: IntFilter<"Chat"> | number
    storeId?: IntFilter<"Chat"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    store?: XOR<StoresScalarRelationFilter, StoresWhereInput>
    messages?: ChatMessagesListRelationFilter
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    user?: UserOrderByWithRelationInput
    store?: StoresOrderByWithRelationInput
    messages?: chatMessagesOrderByRelationAggregateInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    userId?: IntFilter<"Chat"> | number
    storeId?: IntFilter<"Chat"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    store?: XOR<StoresScalarRelationFilter, StoresWhereInput>
    messages?: ChatMessagesListRelationFilter
  }, "id">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    _count?: ChatCountOrderByAggregateInput
    _avg?: ChatAvgOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
    _sum?: ChatSumOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Chat"> | number
    userId?: IntWithAggregatesFilter<"Chat"> | number
    storeId?: IntWithAggregatesFilter<"Chat"> | number
  }

  export type chatMessagesWhereInput = {
    AND?: chatMessagesWhereInput | chatMessagesWhereInput[]
    OR?: chatMessagesWhereInput[]
    NOT?: chatMessagesWhereInput | chatMessagesWhereInput[]
    id?: IntFilter<"chatMessages"> | number
    content?: StringFilter<"chatMessages"> | string
    chatId?: IntFilter<"chatMessages"> | number
    senderUserId?: IntNullableFilter<"chatMessages"> | number | null
    senderStoreId?: IntNullableFilter<"chatMessages"> | number | null
    receiverUserId?: IntNullableFilter<"chatMessages"> | number | null
    receiverStoreId?: IntNullableFilter<"chatMessages"> | number | null
    imageId?: IntNullableFilter<"chatMessages"> | number | null
    sentAt?: DateTimeFilter<"chatMessages"> | Date | string
    receivedAt?: DateTimeNullableFilter<"chatMessages"> | Date | string | null
    wasReceived?: BoolFilter<"chatMessages"> | boolean
    readAt?: DateTimeNullableFilter<"chatMessages"> | Date | string | null
    wasRead?: BoolFilter<"chatMessages"> | boolean
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
    senderUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    senderStore?: XOR<StoresNullableScalarRelationFilter, StoresWhereInput> | null
    receiverUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    receiverStore?: XOR<StoresNullableScalarRelationFilter, StoresWhereInput> | null
    image?: XOR<MessageImagesNullableScalarRelationFilter, MessageImagesWhereInput> | null
  }

  export type chatMessagesOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    chatId?: SortOrder
    senderUserId?: SortOrderInput | SortOrder
    senderStoreId?: SortOrderInput | SortOrder
    receiverUserId?: SortOrderInput | SortOrder
    receiverStoreId?: SortOrderInput | SortOrder
    imageId?: SortOrderInput | SortOrder
    sentAt?: SortOrder
    receivedAt?: SortOrderInput | SortOrder
    wasReceived?: SortOrder
    readAt?: SortOrderInput | SortOrder
    wasRead?: SortOrder
    chat?: ChatOrderByWithRelationInput
    senderUser?: UserOrderByWithRelationInput
    senderStore?: StoresOrderByWithRelationInput
    receiverUser?: UserOrderByWithRelationInput
    receiverStore?: StoresOrderByWithRelationInput
    image?: MessageImagesOrderByWithRelationInput
    _relevance?: chatMessagesOrderByRelevanceInput
  }

  export type chatMessagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    imageId?: number
    AND?: chatMessagesWhereInput | chatMessagesWhereInput[]
    OR?: chatMessagesWhereInput[]
    NOT?: chatMessagesWhereInput | chatMessagesWhereInput[]
    content?: StringFilter<"chatMessages"> | string
    chatId?: IntFilter<"chatMessages"> | number
    senderUserId?: IntNullableFilter<"chatMessages"> | number | null
    senderStoreId?: IntNullableFilter<"chatMessages"> | number | null
    receiverUserId?: IntNullableFilter<"chatMessages"> | number | null
    receiverStoreId?: IntNullableFilter<"chatMessages"> | number | null
    sentAt?: DateTimeFilter<"chatMessages"> | Date | string
    receivedAt?: DateTimeNullableFilter<"chatMessages"> | Date | string | null
    wasReceived?: BoolFilter<"chatMessages"> | boolean
    readAt?: DateTimeNullableFilter<"chatMessages"> | Date | string | null
    wasRead?: BoolFilter<"chatMessages"> | boolean
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
    senderUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    senderStore?: XOR<StoresNullableScalarRelationFilter, StoresWhereInput> | null
    receiverUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    receiverStore?: XOR<StoresNullableScalarRelationFilter, StoresWhereInput> | null
    image?: XOR<MessageImagesNullableScalarRelationFilter, MessageImagesWhereInput> | null
  }, "id" | "imageId">

  export type chatMessagesOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    chatId?: SortOrder
    senderUserId?: SortOrderInput | SortOrder
    senderStoreId?: SortOrderInput | SortOrder
    receiverUserId?: SortOrderInput | SortOrder
    receiverStoreId?: SortOrderInput | SortOrder
    imageId?: SortOrderInput | SortOrder
    sentAt?: SortOrder
    receivedAt?: SortOrderInput | SortOrder
    wasReceived?: SortOrder
    readAt?: SortOrderInput | SortOrder
    wasRead?: SortOrder
    _count?: chatMessagesCountOrderByAggregateInput
    _avg?: chatMessagesAvgOrderByAggregateInput
    _max?: chatMessagesMaxOrderByAggregateInput
    _min?: chatMessagesMinOrderByAggregateInput
    _sum?: chatMessagesSumOrderByAggregateInput
  }

  export type chatMessagesScalarWhereWithAggregatesInput = {
    AND?: chatMessagesScalarWhereWithAggregatesInput | chatMessagesScalarWhereWithAggregatesInput[]
    OR?: chatMessagesScalarWhereWithAggregatesInput[]
    NOT?: chatMessagesScalarWhereWithAggregatesInput | chatMessagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"chatMessages"> | number
    content?: StringWithAggregatesFilter<"chatMessages"> | string
    chatId?: IntWithAggregatesFilter<"chatMessages"> | number
    senderUserId?: IntNullableWithAggregatesFilter<"chatMessages"> | number | null
    senderStoreId?: IntNullableWithAggregatesFilter<"chatMessages"> | number | null
    receiverUserId?: IntNullableWithAggregatesFilter<"chatMessages"> | number | null
    receiverStoreId?: IntNullableWithAggregatesFilter<"chatMessages"> | number | null
    imageId?: IntNullableWithAggregatesFilter<"chatMessages"> | number | null
    sentAt?: DateTimeWithAggregatesFilter<"chatMessages"> | Date | string
    receivedAt?: DateTimeNullableWithAggregatesFilter<"chatMessages"> | Date | string | null
    wasReceived?: BoolWithAggregatesFilter<"chatMessages"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"chatMessages"> | Date | string | null
    wasRead?: BoolWithAggregatesFilter<"chatMessages"> | boolean
  }

  export type MessageImagesWhereInput = {
    AND?: MessageImagesWhereInput | MessageImagesWhereInput[]
    OR?: MessageImagesWhereInput[]
    NOT?: MessageImagesWhereInput | MessageImagesWhereInput[]
    id?: IntFilter<"MessageImages"> | number
    url?: StringFilter<"MessageImages"> | string
    publicId?: StringFilter<"MessageImages"> | string
    messageImage?: XOR<ChatMessagesNullableScalarRelationFilter, chatMessagesWhereInput> | null
  }

  export type MessageImagesOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    messageImage?: chatMessagesOrderByWithRelationInput
    _relevance?: MessageImagesOrderByRelevanceInput
  }

  export type MessageImagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MessageImagesWhereInput | MessageImagesWhereInput[]
    OR?: MessageImagesWhereInput[]
    NOT?: MessageImagesWhereInput | MessageImagesWhereInput[]
    url?: StringFilter<"MessageImages"> | string
    publicId?: StringFilter<"MessageImages"> | string
    messageImage?: XOR<ChatMessagesNullableScalarRelationFilter, chatMessagesWhereInput> | null
  }, "id">

  export type MessageImagesOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    _count?: MessageImagesCountOrderByAggregateInput
    _avg?: MessageImagesAvgOrderByAggregateInput
    _max?: MessageImagesMaxOrderByAggregateInput
    _min?: MessageImagesMinOrderByAggregateInput
    _sum?: MessageImagesSumOrderByAggregateInput
  }

  export type MessageImagesScalarWhereWithAggregatesInput = {
    AND?: MessageImagesScalarWhereWithAggregatesInput | MessageImagesScalarWhereWithAggregatesInput[]
    OR?: MessageImagesScalarWhereWithAggregatesInput[]
    NOT?: MessageImagesScalarWhereWithAggregatesInput | MessageImagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MessageImages"> | number
    url?: StringWithAggregatesFilter<"MessageImages"> | string
    publicId?: StringWithAggregatesFilter<"MessageImages"> | string
  }

  export type LoginTokenWhereInput = {
    AND?: LoginTokenWhereInput | LoginTokenWhereInput[]
    OR?: LoginTokenWhereInput[]
    NOT?: LoginTokenWhereInput | LoginTokenWhereInput[]
    id?: IntFilter<"LoginToken"> | number
    userId?: IntFilter<"LoginToken"> | number
    token?: StringFilter<"LoginToken"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LoginTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: LoginTokenOrderByRelevanceInput
  }

  export type LoginTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: LoginTokenWhereInput | LoginTokenWhereInput[]
    OR?: LoginTokenWhereInput[]
    NOT?: LoginTokenWhereInput | LoginTokenWhereInput[]
    token?: StringFilter<"LoginToken"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type LoginTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    _count?: LoginTokenCountOrderByAggregateInput
    _avg?: LoginTokenAvgOrderByAggregateInput
    _max?: LoginTokenMaxOrderByAggregateInput
    _min?: LoginTokenMinOrderByAggregateInput
    _sum?: LoginTokenSumOrderByAggregateInput
  }

  export type LoginTokenScalarWhereWithAggregatesInput = {
    AND?: LoginTokenScalarWhereWithAggregatesInput | LoginTokenScalarWhereWithAggregatesInput[]
    OR?: LoginTokenScalarWhereWithAggregatesInput[]
    NOT?: LoginTokenScalarWhereWithAggregatesInput | LoginTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LoginToken"> | number
    userId?: IntWithAggregatesFilter<"LoginToken"> | number
    token?: StringWithAggregatesFilter<"LoginToken"> | string
  }

  export type ConfirmationTokenWhereInput = {
    AND?: ConfirmationTokenWhereInput | ConfirmationTokenWhereInput[]
    OR?: ConfirmationTokenWhereInput[]
    NOT?: ConfirmationTokenWhereInput | ConfirmationTokenWhereInput[]
    id?: IntFilter<"ConfirmationToken"> | number
    userId?: IntFilter<"ConfirmationToken"> | number
    token?: StringFilter<"ConfirmationToken"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ConfirmationTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: ConfirmationTokenOrderByRelevanceInput
  }

  export type ConfirmationTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: ConfirmationTokenWhereInput | ConfirmationTokenWhereInput[]
    OR?: ConfirmationTokenWhereInput[]
    NOT?: ConfirmationTokenWhereInput | ConfirmationTokenWhereInput[]
    token?: StringFilter<"ConfirmationToken"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ConfirmationTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    _count?: ConfirmationTokenCountOrderByAggregateInput
    _avg?: ConfirmationTokenAvgOrderByAggregateInput
    _max?: ConfirmationTokenMaxOrderByAggregateInput
    _min?: ConfirmationTokenMinOrderByAggregateInput
    _sum?: ConfirmationTokenSumOrderByAggregateInput
  }

  export type ConfirmationTokenScalarWhereWithAggregatesInput = {
    AND?: ConfirmationTokenScalarWhereWithAggregatesInput | ConfirmationTokenScalarWhereWithAggregatesInput[]
    OR?: ConfirmationTokenScalarWhereWithAggregatesInput[]
    NOT?: ConfirmationTokenScalarWhereWithAggregatesInput | ConfirmationTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ConfirmationToken"> | number
    userId?: IntWithAggregatesFilter<"ConfirmationToken"> | number
    token?: StringWithAggregatesFilter<"ConfirmationToken"> | string
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: IntFilter<"Log"> | number
    action?: StringFilter<"Log"> | string
    tableName?: StringFilter<"Log"> | string
    recordId?: IntNullableFilter<"Log"> | number | null
    userId?: IntNullableFilter<"Log"> | number | null
    timestamp?: DateTimeFilter<"Log"> | Date | string
    details?: StringNullableFilter<"Log"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    details?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: LogOrderByRelevanceInput
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    action?: StringFilter<"Log"> | string
    tableName?: StringFilter<"Log"> | string
    recordId?: IntNullableFilter<"Log"> | number | null
    userId?: IntNullableFilter<"Log"> | number | null
    timestamp?: DateTimeFilter<"Log"> | Date | string
    details?: StringNullableFilter<"Log"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    details?: SortOrderInput | SortOrder
    _count?: LogCountOrderByAggregateInput
    _avg?: LogAvgOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
    _sum?: LogSumOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Log"> | number
    action?: StringWithAggregatesFilter<"Log"> | string
    tableName?: StringWithAggregatesFilter<"Log"> | string
    recordId?: IntNullableWithAggregatesFilter<"Log"> | number | null
    userId?: IntNullableWithAggregatesFilter<"Log"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"Log"> | Date | string
    details?: StringNullableWithAggregatesFilter<"Log"> | string | null
  }

  export type TwoFactorAuthWhereInput = {
    AND?: TwoFactorAuthWhereInput | TwoFactorAuthWhereInput[]
    OR?: TwoFactorAuthWhereInput[]
    NOT?: TwoFactorAuthWhereInput | TwoFactorAuthWhereInput[]
    id?: IntFilter<"TwoFactorAuth"> | number
    userId?: IntFilter<"TwoFactorAuth"> | number
    secret?: StringFilter<"TwoFactorAuth"> | string
    isEnabled?: BoolFilter<"TwoFactorAuth"> | boolean
    createdAt?: DateTimeFilter<"TwoFactorAuth"> | Date | string
    updatedAt?: DateTimeFilter<"TwoFactorAuth"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TwoFactorAuthOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    secret?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: TwoFactorAuthOrderByRelevanceInput
  }

  export type TwoFactorAuthWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TwoFactorAuthWhereInput | TwoFactorAuthWhereInput[]
    OR?: TwoFactorAuthWhereInput[]
    NOT?: TwoFactorAuthWhereInput | TwoFactorAuthWhereInput[]
    userId?: IntFilter<"TwoFactorAuth"> | number
    secret?: StringFilter<"TwoFactorAuth"> | string
    isEnabled?: BoolFilter<"TwoFactorAuth"> | boolean
    createdAt?: DateTimeFilter<"TwoFactorAuth"> | Date | string
    updatedAt?: DateTimeFilter<"TwoFactorAuth"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TwoFactorAuthOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    secret?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwoFactorAuthCountOrderByAggregateInput
    _avg?: TwoFactorAuthAvgOrderByAggregateInput
    _max?: TwoFactorAuthMaxOrderByAggregateInput
    _min?: TwoFactorAuthMinOrderByAggregateInput
    _sum?: TwoFactorAuthSumOrderByAggregateInput
  }

  export type TwoFactorAuthScalarWhereWithAggregatesInput = {
    AND?: TwoFactorAuthScalarWhereWithAggregatesInput | TwoFactorAuthScalarWhereWithAggregatesInput[]
    OR?: TwoFactorAuthScalarWhereWithAggregatesInput[]
    NOT?: TwoFactorAuthScalarWhereWithAggregatesInput | TwoFactorAuthScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TwoFactorAuth"> | number
    userId?: IntWithAggregatesFilter<"TwoFactorAuth"> | number
    secret?: StringWithAggregatesFilter<"TwoFactorAuth"> | string
    isEnabled?: BoolWithAggregatesFilter<"TwoFactorAuth"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TwoFactorAuth"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TwoFactorAuth"> | Date | string
  }

  export type AbandonedCartWhereInput = {
    AND?: AbandonedCartWhereInput | AbandonedCartWhereInput[]
    OR?: AbandonedCartWhereInput[]
    NOT?: AbandonedCartWhereInput | AbandonedCartWhereInput[]
    id?: IntFilter<"AbandonedCart"> | number
    userId?: IntFilter<"AbandonedCart"> | number
    abandonedAt?: DateTimeFilter<"AbandonedCart"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    cartItems?: CartItemsListRelationFilter
  }

  export type AbandonedCartOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    abandonedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    cartItems?: CartItemsOrderByRelationAggregateInput
  }

  export type AbandonedCartWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AbandonedCartWhereInput | AbandonedCartWhereInput[]
    OR?: AbandonedCartWhereInput[]
    NOT?: AbandonedCartWhereInput | AbandonedCartWhereInput[]
    userId?: IntFilter<"AbandonedCart"> | number
    abandonedAt?: DateTimeFilter<"AbandonedCart"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    cartItems?: CartItemsListRelationFilter
  }, "id">

  export type AbandonedCartOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    abandonedAt?: SortOrder
    _count?: AbandonedCartCountOrderByAggregateInput
    _avg?: AbandonedCartAvgOrderByAggregateInput
    _max?: AbandonedCartMaxOrderByAggregateInput
    _min?: AbandonedCartMinOrderByAggregateInput
    _sum?: AbandonedCartSumOrderByAggregateInput
  }

  export type AbandonedCartScalarWhereWithAggregatesInput = {
    AND?: AbandonedCartScalarWhereWithAggregatesInput | AbandonedCartScalarWhereWithAggregatesInput[]
    OR?: AbandonedCartScalarWhereWithAggregatesInput[]
    NOT?: AbandonedCartScalarWhereWithAggregatesInput | AbandonedCartScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AbandonedCart"> | number
    userId?: IntWithAggregatesFilter<"AbandonedCart"> | number
    abandonedAt?: DateTimeWithAggregatesFilter<"AbandonedCart"> | Date | string
  }

  export type ReturnExchangeWhereInput = {
    AND?: ReturnExchangeWhereInput | ReturnExchangeWhereInput[]
    OR?: ReturnExchangeWhereInput[]
    NOT?: ReturnExchangeWhereInput | ReturnExchangeWhereInput[]
    id?: IntFilter<"ReturnExchange"> | number
    orderId?: IntFilter<"ReturnExchange"> | number
    reason?: StringFilter<"ReturnExchange"> | string
    status?: EnumReturnExchangeStatusFilter<"ReturnExchange"> | $Enums.ReturnExchangeStatus
    requestedAt?: DateTimeFilter<"ReturnExchange"> | Date | string
    completedAt?: DateTimeNullableFilter<"ReturnExchange"> | Date | string | null
    order?: XOR<OrdersScalarRelationFilter, OrdersWhereInput>
  }

  export type ReturnExchangeOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    order?: OrdersOrderByWithRelationInput
    _relevance?: ReturnExchangeOrderByRelevanceInput
  }

  export type ReturnExchangeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReturnExchangeWhereInput | ReturnExchangeWhereInput[]
    OR?: ReturnExchangeWhereInput[]
    NOT?: ReturnExchangeWhereInput | ReturnExchangeWhereInput[]
    orderId?: IntFilter<"ReturnExchange"> | number
    reason?: StringFilter<"ReturnExchange"> | string
    status?: EnumReturnExchangeStatusFilter<"ReturnExchange"> | $Enums.ReturnExchangeStatus
    requestedAt?: DateTimeFilter<"ReturnExchange"> | Date | string
    completedAt?: DateTimeNullableFilter<"ReturnExchange"> | Date | string | null
    order?: XOR<OrdersScalarRelationFilter, OrdersWhereInput>
  }, "id">

  export type ReturnExchangeOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: ReturnExchangeCountOrderByAggregateInput
    _avg?: ReturnExchangeAvgOrderByAggregateInput
    _max?: ReturnExchangeMaxOrderByAggregateInput
    _min?: ReturnExchangeMinOrderByAggregateInput
    _sum?: ReturnExchangeSumOrderByAggregateInput
  }

  export type ReturnExchangeScalarWhereWithAggregatesInput = {
    AND?: ReturnExchangeScalarWhereWithAggregatesInput | ReturnExchangeScalarWhereWithAggregatesInput[]
    OR?: ReturnExchangeScalarWhereWithAggregatesInput[]
    NOT?: ReturnExchangeScalarWhereWithAggregatesInput | ReturnExchangeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReturnExchange"> | number
    orderId?: IntWithAggregatesFilter<"ReturnExchange"> | number
    reason?: StringWithAggregatesFilter<"ReturnExchange"> | string
    status?: EnumReturnExchangeStatusWithAggregatesFilter<"ReturnExchange"> | $Enums.ReturnExchangeStatus
    requestedAt?: DateTimeWithAggregatesFilter<"ReturnExchange"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ReturnExchange"> | Date | string | null
  }

  export type AdminCreateInput = {
    user: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    userId: number
  }

  export type AdminUpdateInput = {
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type AdminCreateManyInput = {
    id?: number
    userId: number
  }

  export type AdminUpdateManyMutationInput = {

  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
  }

  export type UserUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
  }

  export type AvatarUserCreateInput = {
    url: string
    publicId: string
    user: UserCreateNestedOneWithoutAvatarInput
  }

  export type AvatarUserUncheckedCreateInput = {
    id?: number
    url: string
    publicId: string
    userId: number
  }

  export type AvatarUserUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAvatarNestedInput
  }

  export type AvatarUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type AvatarUserCreateManyInput = {
    id?: number
    url: string
    publicId: string
    userId: number
  }

  export type AvatarUserUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type AvatarUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type AddressesCreateInput = {
    cep: string
    road: string
    number: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    country?: string
    type?: string | null
    reference?: string | null
    user: UserCreateNestedOneWithoutAddressesInput
    principalOf?: UserCreateNestedOneWithoutPrincipalAddressInput
    order?: OrdersCreateNestedManyWithoutDeliveryAddressInput
  }

  export type AddressesUncheckedCreateInput = {
    id?: number
    userId: number
    cep: string
    road: string
    number: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    country?: string
    type?: string | null
    reference?: string | null
    principalOf?: UserUncheckedCreateNestedOneWithoutPrincipalAddressInput
    order?: OrdersUncheckedCreateNestedManyWithoutDeliveryAddressInput
  }

  export type AddressesUpdateInput = {
    cep?: StringFieldUpdateOperationsInput | string
    road?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAddressesNestedInput
    principalOf?: UserUpdateOneWithoutPrincipalAddressNestedInput
    order?: OrdersUpdateManyWithoutDeliveryAddressNestedInput
  }

  export type AddressesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    road?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    principalOf?: UserUncheckedUpdateOneWithoutPrincipalAddressNestedInput
    order?: OrdersUncheckedUpdateManyWithoutDeliveryAddressNestedInput
  }

  export type AddressesCreateManyInput = {
    id?: number
    userId: number
    cep: string
    road: string
    number: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    country?: string
    type?: string | null
    reference?: string | null
  }

  export type AddressesUpdateManyMutationInput = {
    cep?: StringFieldUpdateOperationsInput | string
    road?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    road?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUsedCouponsCreateInput = {
    usedAt?: Date | string
    user: UserCreateNestedOneWithoutUsedCouponsInput
    coupon: CouponsCreateNestedOneWithoutUsedCouponsInput
    order?: OrdersCreateNestedOneWithoutUsedCouponsInput
  }

  export type UserUsedCouponsUncheckedCreateInput = {
    id?: number
    userId: number
    couponId: number
    usedAt?: Date | string
    orderId?: number | null
  }

  export type UserUsedCouponsUpdateInput = {
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUsedCouponsNestedInput
    coupon?: CouponsUpdateOneRequiredWithoutUsedCouponsNestedInput
    order?: OrdersUpdateOneWithoutUsedCouponsNestedInput
  }

  export type UserUsedCouponsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    couponId?: IntFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUsedCouponsCreateManyInput = {
    id?: number
    userId: number
    couponId: number
    usedAt?: Date | string
    orderId?: number | null
  }

  export type UserUsedCouponsUpdateManyMutationInput = {
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUsedCouponsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    couponId?: IntFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StoresCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    user: UserCreateNestedOneWithoutStoreInput
    avatar?: AvatarStoreCreateNestedOneWithoutStoreAvatarInput
    product?: ProductsCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsCreateNestedManyWithoutStoreInput
    coupons?: CouponsCreateNestedManyWithoutStoreInput
    chat?: ChatCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoreInput
    promotions?: PromotionCreateNestedManyWithoutStoreInput
  }

  export type StoresUncheckedCreateInput = {
    id?: number
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    avatarId?: number | null
    product?: ProductsUncheckedCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutStoreInput
    coupons?: CouponsUncheckedCreateNestedManyWithoutStoreInput
    chat?: ChatUncheckedCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoreInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoresUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStoreNestedInput
    avatar?: AvatarStoreUpdateOneWithoutStoreAvatarNestedInput
    product?: ProductsUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUpdateManyWithoutStoreNestedInput
    chat?: ChatUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUpdateManyWithoutStoreNestedInput
  }

  export type StoresUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    product?: ProductsUncheckedUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUncheckedUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUncheckedUpdateManyWithoutStoreNestedInput
    chat?: ChatUncheckedUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoresCreateManyInput = {
    id?: number
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    avatarId?: number | null
  }

  export type StoresUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoresUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AvatarStoreCreateInput = {
    url: string
    publicId: string
    storeAvatar?: StoresCreateNestedOneWithoutAvatarInput
  }

  export type AvatarStoreUncheckedCreateInput = {
    id?: number
    url: string
    publicId: string
    storeAvatar?: StoresUncheckedCreateNestedOneWithoutAvatarInput
  }

  export type AvatarStoreUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    storeAvatar?: StoresUpdateOneWithoutAvatarNestedInput
  }

  export type AvatarStoreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    storeAvatar?: StoresUncheckedUpdateOneWithoutAvatarNestedInput
  }

  export type AvatarStoreCreateManyInput = {
    id?: number
    url: string
    publicId: string
  }

  export type AvatarStoreUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type AvatarStoreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type StoreAvaliationsCreateInput = {
    note: number
    avaliationDate?: Date | string
    comment?: string | null
    user: UserCreateNestedOneWithoutStoreAvaliationsInput
    store: StoresCreateNestedOneWithoutAvaliationsInput
    images?: StoreAvaliationImagesCreateNestedManyWithoutStoreAvaliationInput
  }

  export type StoreAvaliationsUncheckedCreateInput = {
    id?: number
    userId: number
    storeId: number
    note: number
    avaliationDate?: Date | string
    comment?: string | null
    images?: StoreAvaliationImagesUncheckedCreateNestedManyWithoutStoreAvaliationInput
  }

  export type StoreAvaliationsUpdateInput = {
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStoreAvaliationsNestedInput
    store?: StoresUpdateOneRequiredWithoutAvaliationsNestedInput
    images?: StoreAvaliationImagesUpdateManyWithoutStoreAvaliationNestedInput
  }

  export type StoreAvaliationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: StoreAvaliationImagesUncheckedUpdateManyWithoutStoreAvaliationNestedInput
  }

  export type StoreAvaliationsCreateManyInput = {
    id?: number
    userId: number
    storeId: number
    note: number
    avaliationDate?: Date | string
    comment?: string | null
  }

  export type StoreAvaliationsUpdateManyMutationInput = {
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreAvaliationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreAvaliationImagesCreateInput = {
    url: string
    publicId: string
    storeAvaliation?: StoreAvaliationsCreateNestedOneWithoutImagesInput
  }

  export type StoreAvaliationImagesUncheckedCreateInput = {
    id?: number
    url: string
    publicId: string
    storeAvaliationId?: number | null
  }

  export type StoreAvaliationImagesUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    storeAvaliation?: StoreAvaliationsUpdateOneWithoutImagesNestedInput
  }

  export type StoreAvaliationImagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    storeAvaliationId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StoreAvaliationImagesCreateManyInput = {
    id?: number
    url: string
    publicId: string
    storeAvaliationId?: number | null
  }

  export type StoreAvaliationImagesUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type StoreAvaliationImagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    storeAvaliationId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CouponsCreateInput = {
    code: string
    expirationDate: Date | string
    percentageDiscount: number
    discountValue: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoresCreateNestedOneWithoutCouponsInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutCouponInput
  }

  export type CouponsUncheckedCreateInput = {
    id?: number
    code: string
    expirationDate: Date | string
    percentageDiscount: number
    discountValue: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: number
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponsUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentageDiscount?: IntFieldUpdateOperationsInput | number
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoresUpdateOneRequiredWithoutCouponsNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutCouponNestedInput
  }

  export type CouponsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentageDiscount?: IntFieldUpdateOperationsInput | number
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: IntFieldUpdateOperationsInput | number
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type CouponsCreateManyInput = {
    id?: number
    code: string
    expirationDate: Date | string
    percentageDiscount: number
    discountValue: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: number
  }

  export type CouponsUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentageDiscount?: IntFieldUpdateOperationsInput | number
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentageDiscount?: IntFieldUpdateOperationsInput | number
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductsCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    store: StoresCreateNestedOneWithoutProductInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    images?: ProductImagesCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsCreateNestedManyWithoutProductInput
    promotions?: PromotionCreateNestedManyWithoutProductsInput
    cartItem?: CartItemsCreateNestedManyWithoutProductInput
    orderItems?: OrderItemsCreateNestedManyWithoutProductInput
    wishlists?: WishlistCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateInput = {
    id?: number
    storeId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    images?: ProductImagesUncheckedCreateNestedManyWithoutProductInput
    category?: CategoryUncheckedCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutProductInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutProductsInput
    cartItem?: CartItemsUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutProductInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    store?: StoresUpdateOneRequiredWithoutProductNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    images?: ProductImagesUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUpdateManyWithoutProductNestedInput
    promotions?: PromotionUpdateManyWithoutProductsNestedInput
    cartItem?: CartItemsUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemsUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    images?: ProductImagesUncheckedUpdateManyWithoutProductNestedInput
    category?: CategoryUncheckedUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUncheckedUpdateManyWithoutProductNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutProductsNestedInput
    cartItem?: CartItemsUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductsCreateManyInput = {
    id?: number
    storeId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
  }

  export type ProductsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProductsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProductImagesCreateInput = {
    url: string
    publicId: string
    product?: ProductsCreateNestedOneWithoutImagesInput
  }

  export type ProductImagesUncheckedCreateInput = {
    id?: number
    url: string
    publicId: string
    productId?: number | null
  }

  export type ProductImagesUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    product?: ProductsUpdateOneWithoutImagesNestedInput
  }

  export type ProductImagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductImagesCreateManyInput = {
    id?: number
    url: string
    publicId: string
    productId?: number | null
  }

  export type ProductImagesUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductImagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WishlistCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWishlistInput
    products?: ProductsCreateNestedManyWithoutWishlistsInput
  }

  export type WishlistUncheckedCreateInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductsUncheckedCreateNestedManyWithoutWishlistsInput
  }

  export type WishlistUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWishlistNestedInput
    products?: ProductsUpdateManyWithoutWishlistsNestedInput
  }

  export type WishlistUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductsUncheckedUpdateManyWithoutWishlistsNestedInput
  }

  export type WishlistCreateManyInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateInput = {
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductsCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: number
    productId: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductsUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateManyInput = {
    id?: number
    productId: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionCreateInput = {
    code: string
    description: string
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoresCreateNestedOneWithoutPromotionsInput
    products?: ProductsCreateNestedManyWithoutPromotionsInput
  }

  export type PromotionUncheckedCreateInput = {
    id?: number
    code: string
    description: string
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    storeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductsUncheckedCreateNestedManyWithoutPromotionsInput
  }

  export type PromotionUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoresUpdateOneRequiredWithoutPromotionsNestedInput
    products?: ProductsUpdateManyWithoutPromotionsNestedInput
  }

  export type PromotionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductsUncheckedUpdateManyWithoutPromotionsNestedInput
  }

  export type PromotionCreateManyInput = {
    id?: number
    code: string
    description: string
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    storeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    name: string
    product?: ProductsCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    product?: ProductsUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    product?: ProductsUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    product?: ProductsUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProductAvaliationsCreateInput = {
    note: number
    avaliationDate?: Date | string
    comment?: string | null
    user: UserCreateNestedOneWithoutProductAvaliationsInput
    product: ProductsCreateNestedOneWithoutAvaliationsInput
    images?: ProductAvaliationImagesCreateNestedManyWithoutProductAvaliationInput
  }

  export type ProductAvaliationsUncheckedCreateInput = {
    id?: number
    userId: number
    productId: number
    note: number
    avaliationDate?: Date | string
    comment?: string | null
    images?: ProductAvaliationImagesUncheckedCreateNestedManyWithoutProductAvaliationInput
  }

  export type ProductAvaliationsUpdateInput = {
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutProductAvaliationsNestedInput
    product?: ProductsUpdateOneRequiredWithoutAvaliationsNestedInput
    images?: ProductAvaliationImagesUpdateManyWithoutProductAvaliationNestedInput
  }

  export type ProductAvaliationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductAvaliationImagesUncheckedUpdateManyWithoutProductAvaliationNestedInput
  }

  export type ProductAvaliationsCreateManyInput = {
    id?: number
    userId: number
    productId: number
    note: number
    avaliationDate?: Date | string
    comment?: string | null
  }

  export type ProductAvaliationsUpdateManyMutationInput = {
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductAvaliationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductAvaliationImagesCreateInput = {
    url: string
    publicId: string
    productAvaliation?: ProductAvaliationsCreateNestedOneWithoutImagesInput
  }

  export type ProductAvaliationImagesUncheckedCreateInput = {
    id?: number
    url: string
    publicId: string
    productAvaliationId?: number | null
  }

  export type ProductAvaliationImagesUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    productAvaliation?: ProductAvaliationsUpdateOneWithoutImagesNestedInput
  }

  export type ProductAvaliationImagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    productAvaliationId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductAvaliationImagesCreateManyInput = {
    id?: number
    url: string
    publicId: string
    productAvaliationId?: number | null
  }

  export type ProductAvaliationImagesUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductAvaliationImagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    productAvaliationId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CartCreateInput = {
    userCart?: UserCreateNestedOneWithoutCartInput
    cartItems?: CartItemsCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateInput = {
    id?: number
    userCart?: UserUncheckedCreateNestedOneWithoutCartInput
    cartItems?: CartItemsUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartUpdateInput = {
    userCart?: UserUpdateOneWithoutCartNestedInput
    cartItems?: CartItemsUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCart?: UserUncheckedUpdateOneWithoutCartNestedInput
    cartItems?: CartItemsUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartCreateManyInput = {
    id?: number
  }

  export type CartUpdateManyMutationInput = {

  }

  export type CartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type CartItemsCreateInput = {
    quantidade: number
    cart: CartCreateNestedOneWithoutCartItemsInput
    product: ProductsCreateNestedOneWithoutCartItemInput
    AbandonedCart?: AbandonedCartCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemsUncheckedCreateInput = {
    id?: number
    cartId: number
    productId: number
    quantidade: number
    abandonedCartId?: number | null
  }

  export type CartItemsUpdateInput = {
    quantidade?: IntFieldUpdateOperationsInput | number
    cart?: CartUpdateOneRequiredWithoutCartItemsNestedInput
    product?: ProductsUpdateOneRequiredWithoutCartItemNestedInput
    AbandonedCart?: AbandonedCartUpdateOneWithoutCartItemsNestedInput
  }

  export type CartItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cartId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    abandonedCartId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CartItemsCreateManyInput = {
    id?: number
    cartId: number
    productId: number
    quantidade: number
    abandonedCartId?: number | null
  }

  export type CartItemsUpdateManyMutationInput = {
    quantidade?: IntFieldUpdateOperationsInput | number
  }

  export type CartItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cartId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    abandonedCartId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentMethodCreateInput = {
    method: $Enums.PaymentMethodType
    payments?: PaymentCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUncheckedCreateInput = {
    id?: number
    method: $Enums.PaymentMethodType
    payments?: PaymentUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUpdateInput = {
    method?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    payments?: PaymentUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    payments?: PaymentUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodCreateManyInput = {
    id?: number
    method: $Enums.PaymentMethodType
  }

  export type PaymentMethodUpdateManyMutationInput = {
    method?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
  }

  export type PaymentCreateInput = {
    valor: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod: PaymentMethodCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    valor: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethodId: number
  }

  export type PaymentUpdateInput = {
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethodId?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentCreateManyInput = {
    id?: number
    valor: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethodId: number
  }

  export type PaymentUpdateManyMutationInput = {
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethodId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderStatusCreateInput = {
    Status: $Enums.OrderStatusType
    orders?: OrdersCreateNestedManyWithoutOrderStatusInput
  }

  export type OrderStatusUncheckedCreateInput = {
    id?: number
    Status: $Enums.OrderStatusType
    orders?: OrdersUncheckedCreateNestedManyWithoutOrderStatusInput
  }

  export type OrderStatusUpdateInput = {
    Status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    orders?: OrdersUpdateManyWithoutOrderStatusNestedInput
  }

  export type OrderStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    Status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    orders?: OrdersUncheckedUpdateManyWithoutOrderStatusNestedInput
  }

  export type OrderStatusCreateManyInput = {
    id?: number
    Status: $Enums.OrderStatusType
  }

  export type OrderStatusUpdateManyMutationInput = {
    Status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
  }

  export type OrderStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    Status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
  }

  export type OrdersCreateInput = {
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    user: UserCreateNestedOneWithoutOrdersInput
    orderStatus: OrderStatusCreateNestedOneWithoutOrdersInput
    deliveryAddress: AddressesCreateNestedOneWithoutOrderInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemsCreateNestedManyWithoutOrderInput
    orderHistory?: OrderHistoryCreateNestedManyWithoutOrderInput
    shipping?: ShippingCreateNestedOneWithoutOrderInput
    ReturnExchange?: ReturnExchangeCreateNestedManyWithoutOrderInput
  }

  export type OrdersUncheckedCreateInput = {
    id?: number
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    userId: number
    orderStatusId: number
    deliveryAddressId: number
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutOrderInput
    orderHistory?: OrderHistoryUncheckedCreateNestedManyWithoutOrderInput
    shipping?: ShippingUncheckedCreateNestedOneWithoutOrderInput
    ReturnExchange?: ReturnExchangeUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrdersUpdateInput = {
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    orderStatus?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    deliveryAddress?: AddressesUpdateOneRequiredWithoutOrderNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemsUpdateManyWithoutOrderNestedInput
    orderHistory?: OrderHistoryUpdateManyWithoutOrderNestedInput
    shipping?: ShippingUpdateOneWithoutOrderNestedInput
    ReturnExchange?: ReturnExchangeUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    orderStatusId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: IntFieldUpdateOperationsInput | number
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutOrderNestedInput
    orderHistory?: OrderHistoryUncheckedUpdateManyWithoutOrderNestedInput
    shipping?: ShippingUncheckedUpdateOneWithoutOrderNestedInput
    ReturnExchange?: ReturnExchangeUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrdersCreateManyInput = {
    id?: number
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    userId: number
    orderStatusId: number
    deliveryAddressId: number
  }

  export type OrdersUpdateManyMutationInput = {
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrdersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    orderStatusId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderHistoryCreateInput = {
    action: string
    updatedAt?: Date | string
    order: OrdersCreateNestedOneWithoutOrderHistoryInput
  }

  export type OrderHistoryUncheckedCreateInput = {
    id?: number
    orderId: number
    action: string
    updatedAt?: Date | string
  }

  export type OrderHistoryUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrdersUpdateOneRequiredWithoutOrderHistoryNestedInput
  }

  export type OrderHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderHistoryCreateManyInput = {
    id?: number
    orderId: number
    action: string
    updatedAt?: Date | string
  }

  export type OrderHistoryUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemsCreateInput = {
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    order: OrdersCreateNestedOneWithoutOrderItemsInput
    product: ProductsCreateNestedOneWithoutOrderItemsInput
    store: StoresCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemsUncheckedCreateInput = {
    id?: number
    orderId: number
    productId: number
    storeId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
  }

  export type OrderItemsUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: OrdersUpdateOneRequiredWithoutOrderItemsNestedInput
    product?: ProductsUpdateOneRequiredWithoutOrderItemsNestedInput
    store?: StoresUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type OrderItemsCreateManyInput = {
    id?: number
    orderId: number
    productId: number
    storeId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
  }

  export type OrderItemsUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type OrderItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ShippingCreateInput = {
    shippingMethod: string
    shippingCost: Decimal | DecimalJsLike | number | string
    estimatedDelivery: Date | string
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrdersCreateNestedOneWithoutShippingInput
  }

  export type ShippingUncheckedCreateInput = {
    id?: number
    orderId: number
    shippingMethod: string
    shippingCost: Decimal | DecimalJsLike | number | string
    estimatedDelivery: Date | string
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingUpdateInput = {
    shippingMethod?: StringFieldUpdateOperationsInput | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedDelivery?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrdersUpdateOneRequiredWithoutShippingNestedInput
  }

  export type ShippingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    shippingMethod?: StringFieldUpdateOperationsInput | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedDelivery?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingCreateManyInput = {
    id?: number
    orderId: number
    shippingMethod: string
    shippingCost: Decimal | DecimalJsLike | number | string
    estimatedDelivery: Date | string
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingUpdateManyMutationInput = {
    shippingMethod?: StringFieldUpdateOperationsInput | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedDelivery?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    shippingMethod?: StringFieldUpdateOperationsInput | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedDelivery?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatCreateInput = {
    user: UserCreateNestedOneWithoutChatInput
    store: StoresCreateNestedOneWithoutChatInput
    messages?: chatMessagesCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateInput = {
    id?: number
    userId: number
    storeId: number
    messages?: chatMessagesUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatUpdateInput = {
    user?: UserUpdateOneRequiredWithoutChatNestedInput
    store?: StoresUpdateOneRequiredWithoutChatNestedInput
    messages?: chatMessagesUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    messages?: chatMessagesUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatCreateManyInput = {
    id?: number
    userId: number
    storeId: number
  }

  export type ChatUpdateManyMutationInput = {

  }

  export type ChatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type chatMessagesCreateInput = {
    content: string
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
    chat: ChatCreateNestedOneWithoutMessagesInput
    senderUser?: UserCreateNestedOneWithoutSentMessagesInput
    senderStore?: StoresCreateNestedOneWithoutSentMessagesInput
    receiverUser?: UserCreateNestedOneWithoutReceivedMessagesInput
    receiverStore?: StoresCreateNestedOneWithoutReceivedMessagesInput
    image?: MessageImagesCreateNestedOneWithoutMessageImageInput
  }

  export type chatMessagesUncheckedCreateInput = {
    id?: number
    content: string
    chatId: number
    senderUserId?: number | null
    senderStoreId?: number | null
    receiverUserId?: number | null
    receiverStoreId?: number | null
    imageId?: number | null
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
  }

  export type chatMessagesUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
    senderUser?: UserUpdateOneWithoutSentMessagesNestedInput
    senderStore?: StoresUpdateOneWithoutSentMessagesNestedInput
    receiverUser?: UserUpdateOneWithoutReceivedMessagesNestedInput
    receiverStore?: StoresUpdateOneWithoutReceivedMessagesNestedInput
    image?: MessageImagesUpdateOneWithoutMessageImageNestedInput
  }

  export type chatMessagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    chatId?: IntFieldUpdateOperationsInput | number
    senderUserId?: NullableIntFieldUpdateOperationsInput | number | null
    senderStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chatMessagesCreateManyInput = {
    id?: number
    content: string
    chatId: number
    senderUserId?: number | null
    senderStoreId?: number | null
    receiverUserId?: number | null
    receiverStoreId?: number | null
    imageId?: number | null
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
  }

  export type chatMessagesUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chatMessagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    chatId?: IntFieldUpdateOperationsInput | number
    senderUserId?: NullableIntFieldUpdateOperationsInput | number | null
    senderStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageImagesCreateInput = {
    url: string
    publicId: string
    messageImage?: chatMessagesCreateNestedOneWithoutImageInput
  }

  export type MessageImagesUncheckedCreateInput = {
    id?: number
    url: string
    publicId: string
    messageImage?: chatMessagesUncheckedCreateNestedOneWithoutImageInput
  }

  export type MessageImagesUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    messageImage?: chatMessagesUpdateOneWithoutImageNestedInput
  }

  export type MessageImagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    messageImage?: chatMessagesUncheckedUpdateOneWithoutImageNestedInput
  }

  export type MessageImagesCreateManyInput = {
    id?: number
    url: string
    publicId: string
  }

  export type MessageImagesUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageImagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type LoginTokenCreateInput = {
    token: string
    user: UserCreateNestedOneWithoutTokenLoginInput
  }

  export type LoginTokenUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
  }

  export type LoginTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutTokenLoginNestedInput
  }

  export type LoginTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
  }

  export type LoginTokenCreateManyInput = {
    id?: number
    userId: number
    token: string
  }

  export type LoginTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
  }

  export type LoginTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
  }

  export type ConfirmationTokenCreateInput = {
    token: string
    user: UserCreateNestedOneWithoutConfirmationTokenInput
  }

  export type ConfirmationTokenUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
  }

  export type ConfirmationTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutConfirmationTokenNestedInput
  }

  export type ConfirmationTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
  }

  export type ConfirmationTokenCreateManyInput = {
    id?: number
    userId: number
    token: string
  }

  export type ConfirmationTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
  }

  export type ConfirmationTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
  }

  export type LogCreateInput = {
    action: string
    tableName: string
    recordId?: number | null
    timestamp?: Date | string
    details?: string | null
    user?: UserCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateInput = {
    id?: number
    action: string
    tableName: string
    recordId?: number | null
    userId?: number | null
    timestamp?: Date | string
    details?: string | null
  }

  export type LogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogCreateManyInput = {
    id?: number
    action: string
    tableName: string
    recordId?: number | null
    userId?: number | null
    timestamp?: Date | string
    details?: string | null
  }

  export type LogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TwoFactorAuthCreateInput = {
    secret: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTwoFactorAuthInput
  }

  export type TwoFactorAuthUncheckedCreateInput = {
    id?: number
    userId: number
    secret: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorAuthUpdateInput = {
    secret?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTwoFactorAuthNestedInput
  }

  export type TwoFactorAuthUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    secret?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAuthCreateManyInput = {
    id?: number
    userId: number
    secret: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorAuthUpdateManyMutationInput = {
    secret?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAuthUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    secret?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AbandonedCartCreateInput = {
    abandonedAt?: Date | string
    user: UserCreateNestedOneWithoutAbandonedCartInput
    cartItems?: CartItemsCreateNestedManyWithoutAbandonedCartInput
  }

  export type AbandonedCartUncheckedCreateInput = {
    id?: number
    userId: number
    abandonedAt?: Date | string
    cartItems?: CartItemsUncheckedCreateNestedManyWithoutAbandonedCartInput
  }

  export type AbandonedCartUpdateInput = {
    abandonedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAbandonedCartNestedInput
    cartItems?: CartItemsUpdateManyWithoutAbandonedCartNestedInput
  }

  export type AbandonedCartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    abandonedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemsUncheckedUpdateManyWithoutAbandonedCartNestedInput
  }

  export type AbandonedCartCreateManyInput = {
    id?: number
    userId: number
    abandonedAt?: Date | string
  }

  export type AbandonedCartUpdateManyMutationInput = {
    abandonedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AbandonedCartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    abandonedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnExchangeCreateInput = {
    reason: string
    status: $Enums.ReturnExchangeStatus
    requestedAt?: Date | string
    completedAt?: Date | string | null
    order: OrdersCreateNestedOneWithoutReturnExchangeInput
  }

  export type ReturnExchangeUncheckedCreateInput = {
    id?: number
    orderId: number
    reason: string
    status: $Enums.ReturnExchangeStatus
    requestedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ReturnExchangeUpdateInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReturnExchangeStatusFieldUpdateOperationsInput | $Enums.ReturnExchangeStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrdersUpdateOneRequiredWithoutReturnExchangeNestedInput
  }

  export type ReturnExchangeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReturnExchangeStatusFieldUpdateOperationsInput | $Enums.ReturnExchangeStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReturnExchangeCreateManyInput = {
    id?: number
    orderId: number
    reason: string
    status: $Enums.ReturnExchangeStatus
    requestedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ReturnExchangeUpdateManyMutationInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReturnExchangeStatusFieldUpdateOperationsInput | $Enums.ReturnExchangeStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReturnExchangeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReturnExchangeStatusFieldUpdateOperationsInput | $Enums.ReturnExchangeStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AvatarUserNullableScalarRelationFilter = {
    is?: AvatarUserWhereInput | null
    isNot?: AvatarUserWhereInput | null
  }

  export type LoginTokenNullableScalarRelationFilter = {
    is?: LoginTokenWhereInput | null
    isNot?: LoginTokenWhereInput | null
  }

  export type ConfirmationTokenNullableScalarRelationFilter = {
    is?: ConfirmationTokenWhereInput | null
    isNot?: ConfirmationTokenWhereInput | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type AddressesNullableScalarRelationFilter = {
    is?: AddressesWhereInput | null
    isNot?: AddressesWhereInput | null
  }

  export type AddressesListRelationFilter = {
    every?: AddressesWhereInput
    some?: AddressesWhereInput
    none?: AddressesWhereInput
  }

  export type StoresNullableScalarRelationFilter = {
    is?: StoresWhereInput | null
    isNot?: StoresWhereInput | null
  }

  export type ProductAvaliationsListRelationFilter = {
    every?: ProductAvaliationsWhereInput
    some?: ProductAvaliationsWhereInput
    none?: ProductAvaliationsWhereInput
  }

  export type StoreAvaliationsListRelationFilter = {
    every?: StoreAvaliationsWhereInput
    some?: StoreAvaliationsWhereInput
    none?: StoreAvaliationsWhereInput
  }

  export type CartScalarRelationFilter = {
    is?: CartWhereInput
    isNot?: CartWhereInput
  }

  export type OrdersListRelationFilter = {
    every?: OrdersWhereInput
    some?: OrdersWhereInput
    none?: OrdersWhereInput
  }

  export type UserUsedCouponsListRelationFilter = {
    every?: UserUsedCouponsWhereInput
    some?: UserUsedCouponsWhereInput
    none?: UserUsedCouponsWhereInput
  }

  export type ChatListRelationFilter = {
    every?: ChatWhereInput
    some?: ChatWhereInput
    none?: ChatWhereInput
  }

  export type ChatMessagesListRelationFilter = {
    every?: chatMessagesWhereInput
    some?: chatMessagesWhereInput
    none?: chatMessagesWhereInput
  }

  export type LogListRelationFilter = {
    every?: LogWhereInput
    some?: LogWhereInput
    none?: LogWhereInput
  }

  export type TwoFactorAuthListRelationFilter = {
    every?: TwoFactorAuthWhereInput
    some?: TwoFactorAuthWhereInput
    none?: TwoFactorAuthWhereInput
  }

  export type WishlistListRelationFilter = {
    every?: WishlistWhereInput
    some?: WishlistWhereInput
    none?: WishlistWhereInput
  }

  export type AbandonedCartListRelationFilter = {
    every?: AbandonedCartWhereInput
    some?: AbandonedCartWhereInput
    none?: AbandonedCartWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AddressesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductAvaliationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreAvaliationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrdersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserUsedCouponsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chatMessagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwoFactorAuthOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WishlistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AbandonedCartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    cpf?: SortOrder
    email?: SortOrder
    password?: SortOrder
    bornDate?: SortOrder
    avatarId?: SortOrder
    principalAddressId?: SortOrder
    cartId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    avatarId?: SortOrder
    principalAddressId?: SortOrder
    cartId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    cpf?: SortOrder
    email?: SortOrder
    password?: SortOrder
    bornDate?: SortOrder
    avatarId?: SortOrder
    principalAddressId?: SortOrder
    cartId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    cpf?: SortOrder
    email?: SortOrder
    password?: SortOrder
    bornDate?: SortOrder
    avatarId?: SortOrder
    principalAddressId?: SortOrder
    cartId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    avatarId?: SortOrder
    principalAddressId?: SortOrder
    cartId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AvatarUserOrderByRelevanceInput = {
    fields: AvatarUserOrderByRelevanceFieldEnum | AvatarUserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AvatarUserCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    userId?: SortOrder
  }

  export type AvatarUserAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AvatarUserMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    userId?: SortOrder
  }

  export type AvatarUserMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    userId?: SortOrder
  }

  export type AvatarUserSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AddressesOrderByRelevanceInput = {
    fields: AddressesOrderByRelevanceFieldEnum | AddressesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AddressesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cep?: SortOrder
    road?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    type?: SortOrder
    reference?: SortOrder
  }

  export type AddressesAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AddressesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cep?: SortOrder
    road?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    type?: SortOrder
    reference?: SortOrder
  }

  export type AddressesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cep?: SortOrder
    road?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    type?: SortOrder
    reference?: SortOrder
  }

  export type AddressesSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type CouponsScalarRelationFilter = {
    is?: CouponsWhereInput
    isNot?: CouponsWhereInput
  }

  export type OrdersNullableScalarRelationFilter = {
    is?: OrdersWhereInput | null
    isNot?: OrdersWhereInput | null
  }

  export type UserUsedCouponsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    couponId?: SortOrder
    usedAt?: SortOrder
    orderId?: SortOrder
  }

  export type UserUsedCouponsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    couponId?: SortOrder
    orderId?: SortOrder
  }

  export type UserUsedCouponsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    couponId?: SortOrder
    usedAt?: SortOrder
    orderId?: SortOrder
  }

  export type UserUsedCouponsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    couponId?: SortOrder
    usedAt?: SortOrder
    orderId?: SortOrder
  }

  export type UserUsedCouponsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    couponId?: SortOrder
    orderId?: SortOrder
  }

  export type AvatarStoreNullableScalarRelationFilter = {
    is?: AvatarStoreWhereInput | null
    isNot?: AvatarStoreWhereInput | null
  }

  export type ProductsListRelationFilter = {
    every?: ProductsWhereInput
    some?: ProductsWhereInput
    none?: ProductsWhereInput
  }

  export type CouponsListRelationFilter = {
    every?: CouponsWhereInput
    some?: CouponsWhereInput
    none?: CouponsWhereInput
  }

  export type OrderItemsListRelationFilter = {
    every?: OrderItemsWhereInput
    some?: OrderItemsWhereInput
    none?: OrderItemsWhereInput
  }

  export type PromotionListRelationFilter = {
    every?: PromotionWhereInput
    some?: PromotionWhereInput
    none?: PromotionWhereInput
  }

  export type ProductsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CouponsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromotionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoresOrderByRelevanceInput = {
    fields: StoresOrderByRelevanceFieldEnum | StoresOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StoresCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    avatarId?: SortOrder
  }

  export type StoresAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    avatarId?: SortOrder
  }

  export type StoresMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    avatarId?: SortOrder
  }

  export type StoresMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    avatarId?: SortOrder
  }

  export type StoresSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    avatarId?: SortOrder
  }

  export type AvatarStoreOrderByRelevanceInput = {
    fields: AvatarStoreOrderByRelevanceFieldEnum | AvatarStoreOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AvatarStoreCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
  }

  export type AvatarStoreAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AvatarStoreMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
  }

  export type AvatarStoreMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
  }

  export type AvatarStoreSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StoresScalarRelationFilter = {
    is?: StoresWhereInput
    isNot?: StoresWhereInput
  }

  export type StoreAvaliationImagesListRelationFilter = {
    every?: StoreAvaliationImagesWhereInput
    some?: StoreAvaliationImagesWhereInput
    none?: StoreAvaliationImagesWhereInput
  }

  export type StoreAvaliationImagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreAvaliationsOrderByRelevanceInput = {
    fields: StoreAvaliationsOrderByRelevanceFieldEnum | StoreAvaliationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StoreAvaliationsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    note?: SortOrder
    avaliationDate?: SortOrder
    comment?: SortOrder
  }

  export type StoreAvaliationsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    note?: SortOrder
  }

  export type StoreAvaliationsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    note?: SortOrder
    avaliationDate?: SortOrder
    comment?: SortOrder
  }

  export type StoreAvaliationsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    note?: SortOrder
    avaliationDate?: SortOrder
    comment?: SortOrder
  }

  export type StoreAvaliationsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    note?: SortOrder
  }

  export type StoreAvaliationsNullableScalarRelationFilter = {
    is?: StoreAvaliationsWhereInput | null
    isNot?: StoreAvaliationsWhereInput | null
  }

  export type StoreAvaliationImagesOrderByRelevanceInput = {
    fields: StoreAvaliationImagesOrderByRelevanceFieldEnum | StoreAvaliationImagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StoreAvaliationImagesCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    storeAvaliationId?: SortOrder
  }

  export type StoreAvaliationImagesAvgOrderByAggregateInput = {
    id?: SortOrder
    storeAvaliationId?: SortOrder
  }

  export type StoreAvaliationImagesMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    storeAvaliationId?: SortOrder
  }

  export type StoreAvaliationImagesMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    storeAvaliationId?: SortOrder
  }

  export type StoreAvaliationImagesSumOrderByAggregateInput = {
    id?: SortOrder
    storeAvaliationId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type CouponsOrderByRelevanceInput = {
    fields: CouponsOrderByRelevanceFieldEnum | CouponsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CouponsCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expirationDate?: SortOrder
    percentageDiscount?: SortOrder
    discountValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
  }

  export type CouponsAvgOrderByAggregateInput = {
    id?: SortOrder
    percentageDiscount?: SortOrder
    discountValue?: SortOrder
    storeId?: SortOrder
  }

  export type CouponsMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expirationDate?: SortOrder
    percentageDiscount?: SortOrder
    discountValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
  }

  export type CouponsMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expirationDate?: SortOrder
    percentageDiscount?: SortOrder
    discountValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
  }

  export type CouponsSumOrderByAggregateInput = {
    id?: SortOrder
    percentageDiscount?: SortOrder
    discountValue?: SortOrder
    storeId?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type InventoryNullableScalarRelationFilter = {
    is?: InventoryWhereInput | null
    isNot?: InventoryWhereInput | null
  }

  export type ProductImagesListRelationFilter = {
    every?: ProductImagesWhereInput
    some?: ProductImagesWhereInput
    none?: ProductImagesWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type CartItemsListRelationFilter = {
    every?: CartItemsWhereInput
    some?: CartItemsWhereInput
    none?: CartItemsWhereInput
  }

  export type ProductImagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductsOrderByRelevanceInput = {
    fields: ProductsOrderByRelevanceFieldEnum | ProductsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductsCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ProductsAvgOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    price?: SortOrder
  }

  export type ProductsMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ProductsMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ProductsSumOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    price?: SortOrder
  }

  export type ProductsNullableScalarRelationFilter = {
    is?: ProductsWhereInput | null
    isNot?: ProductsWhereInput | null
  }

  export type ProductImagesOrderByRelevanceInput = {
    fields: ProductImagesOrderByRelevanceFieldEnum | ProductImagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductImagesCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    productId?: SortOrder
  }

  export type ProductImagesAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ProductImagesMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    productId?: SortOrder
  }

  export type ProductImagesMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    productId?: SortOrder
  }

  export type ProductImagesSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type WishlistCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WishlistAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type WishlistMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WishlistMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WishlistSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProductsScalarRelationFilter = {
    is?: ProductsWhereInput
    isNot?: ProductsWhereInput
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type PromotionOrderByRelevanceInput = {
    fields: PromotionOrderByRelevanceFieldEnum | PromotionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PromotionCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionAvgOrderByAggregateInput = {
    id?: SortOrder
    discountValue?: SortOrder
    storeId?: SortOrder
  }

  export type PromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionSumOrderByAggregateInput = {
    id?: SortOrder
    discountValue?: SortOrder
    storeId?: SortOrder
  }

  export type CategoryOrderByRelevanceInput = {
    fields: CategoryOrderByRelevanceFieldEnum | CategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductAvaliationImagesListRelationFilter = {
    every?: ProductAvaliationImagesWhereInput
    some?: ProductAvaliationImagesWhereInput
    none?: ProductAvaliationImagesWhereInput
  }

  export type ProductAvaliationImagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductAvaliationsOrderByRelevanceInput = {
    fields: ProductAvaliationsOrderByRelevanceFieldEnum | ProductAvaliationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductAvaliationsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    note?: SortOrder
    avaliationDate?: SortOrder
    comment?: SortOrder
  }

  export type ProductAvaliationsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    note?: SortOrder
  }

  export type ProductAvaliationsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    note?: SortOrder
    avaliationDate?: SortOrder
    comment?: SortOrder
  }

  export type ProductAvaliationsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    note?: SortOrder
    avaliationDate?: SortOrder
    comment?: SortOrder
  }

  export type ProductAvaliationsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    note?: SortOrder
  }

  export type ProductAvaliationsNullableScalarRelationFilter = {
    is?: ProductAvaliationsWhereInput | null
    isNot?: ProductAvaliationsWhereInput | null
  }

  export type ProductAvaliationImagesOrderByRelevanceInput = {
    fields: ProductAvaliationImagesOrderByRelevanceFieldEnum | ProductAvaliationImagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductAvaliationImagesCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    productAvaliationId?: SortOrder
  }

  export type ProductAvaliationImagesAvgOrderByAggregateInput = {
    id?: SortOrder
    productAvaliationId?: SortOrder
  }

  export type ProductAvaliationImagesMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    productAvaliationId?: SortOrder
  }

  export type ProductAvaliationImagesMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    productAvaliationId?: SortOrder
  }

  export type ProductAvaliationImagesSumOrderByAggregateInput = {
    id?: SortOrder
    productAvaliationId?: SortOrder
  }

  export type CartCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CartAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CartMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CartMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CartSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AbandonedCartNullableScalarRelationFilter = {
    is?: AbandonedCartWhereInput | null
    isNot?: AbandonedCartWhereInput | null
  }

  export type CartItemsCountOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantidade?: SortOrder
    abandonedCartId?: SortOrder
  }

  export type CartItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantidade?: SortOrder
    abandonedCartId?: SortOrder
  }

  export type CartItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantidade?: SortOrder
    abandonedCartId?: SortOrder
  }

  export type CartItemsMinOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantidade?: SortOrder
    abandonedCartId?: SortOrder
  }

  export type CartItemsSumOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantidade?: SortOrder
    abandonedCartId?: SortOrder
  }

  export type EnumPaymentMethodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodType | EnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodType[]
    notIn?: $Enums.PaymentMethodType[]
    not?: NestedEnumPaymentMethodTypeFilter<$PrismaModel> | $Enums.PaymentMethodType
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
  }

  export type PaymentMethodAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
  }

  export type PaymentMethodSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumPaymentMethodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodType | EnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodType[]
    notIn?: $Enums.PaymentMethodType[]
    not?: NestedEnumPaymentMethodTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodTypeFilter<$PrismaModel>
  }

  export type PaymentMethodScalarRelationFilter = {
    is?: PaymentMethodWhereInput
    isNot?: PaymentMethodWhereInput
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    paymentDate?: SortOrder
    paymentMethodId?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    paymentMethodId?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    paymentDate?: SortOrder
    paymentMethodId?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    paymentDate?: SortOrder
    paymentMethodId?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    paymentMethodId?: SortOrder
  }

  export type EnumOrderStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatusType | EnumOrderStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatusType[]
    notIn?: $Enums.OrderStatusType[]
    not?: NestedEnumOrderStatusTypeFilter<$PrismaModel> | $Enums.OrderStatusType
  }

  export type OrderStatusCountOrderByAggregateInput = {
    id?: SortOrder
    Status?: SortOrder
  }

  export type OrderStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrderStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    Status?: SortOrder
  }

  export type OrderStatusMinOrderByAggregateInput = {
    id?: SortOrder
    Status?: SortOrder
  }

  export type OrderStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumOrderStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatusType | EnumOrderStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatusType[]
    notIn?: $Enums.OrderStatusType[]
    not?: NestedEnumOrderStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusTypeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type OrderStatusScalarRelationFilter = {
    is?: OrderStatusWhereInput
    isNot?: OrderStatusWhereInput
  }

  export type AddressesScalarRelationFilter = {
    is?: AddressesWhereInput
    isNot?: AddressesWhereInput
  }

  export type OrderHistoryListRelationFilter = {
    every?: OrderHistoryWhereInput
    some?: OrderHistoryWhereInput
    none?: OrderHistoryWhereInput
  }

  export type ShippingNullableScalarRelationFilter = {
    is?: ShippingWhereInput | null
    isNot?: ShippingWhereInput | null
  }

  export type ReturnExchangeListRelationFilter = {
    every?: ReturnExchangeWhereInput
    some?: ReturnExchangeWhereInput
    none?: ReturnExchangeWhereInput
  }

  export type OrderHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReturnExchangeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrdersOrderByRelevanceInput = {
    fields: OrdersOrderByRelevanceFieldEnum | OrdersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrdersCountOrderByAggregateInput = {
    id?: SortOrder
    totalValue?: SortOrder
    trackingCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sendDate?: SortOrder
    deliveryDate?: SortOrder
    minimumDeliveryForeast?: SortOrder
    maximumDeliveryForeast?: SortOrder
    usedCoupon?: SortOrder
    userId?: SortOrder
    orderStatusId?: SortOrder
    deliveryAddressId?: SortOrder
  }

  export type OrdersAvgOrderByAggregateInput = {
    id?: SortOrder
    totalValue?: SortOrder
    userId?: SortOrder
    orderStatusId?: SortOrder
    deliveryAddressId?: SortOrder
  }

  export type OrdersMaxOrderByAggregateInput = {
    id?: SortOrder
    totalValue?: SortOrder
    trackingCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sendDate?: SortOrder
    deliveryDate?: SortOrder
    minimumDeliveryForeast?: SortOrder
    maximumDeliveryForeast?: SortOrder
    usedCoupon?: SortOrder
    userId?: SortOrder
    orderStatusId?: SortOrder
    deliveryAddressId?: SortOrder
  }

  export type OrdersMinOrderByAggregateInput = {
    id?: SortOrder
    totalValue?: SortOrder
    trackingCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sendDate?: SortOrder
    deliveryDate?: SortOrder
    minimumDeliveryForeast?: SortOrder
    maximumDeliveryForeast?: SortOrder
    usedCoupon?: SortOrder
    userId?: SortOrder
    orderStatusId?: SortOrder
    deliveryAddressId?: SortOrder
  }

  export type OrdersSumOrderByAggregateInput = {
    id?: SortOrder
    totalValue?: SortOrder
    userId?: SortOrder
    orderStatusId?: SortOrder
    deliveryAddressId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type OrdersScalarRelationFilter = {
    is?: OrdersWhereInput
    isNot?: OrdersWhereInput
  }

  export type OrderHistoryOrderByRelevanceInput = {
    fields: OrderHistoryOrderByRelevanceFieldEnum | OrderHistoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrderHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    action?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
  }

  export type OrderHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    action?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    action?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderHistorySumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
  }

  export type OrderItemsCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OrderItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OrderItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OrderItemsMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OrderItemsSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type ShippingOrderByRelevanceInput = {
    fields: ShippingOrderByRelevanceFieldEnum | ShippingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShippingCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    shippingMethod?: SortOrder
    shippingCost?: SortOrder
    estimatedDelivery?: SortOrder
    trackingCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    shippingCost?: SortOrder
  }

  export type ShippingMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    shippingMethod?: SortOrder
    shippingCost?: SortOrder
    estimatedDelivery?: SortOrder
    trackingCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    shippingMethod?: SortOrder
    shippingCost?: SortOrder
    estimatedDelivery?: SortOrder
    trackingCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    shippingCost?: SortOrder
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
  }

  export type ChatAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
  }

  export type ChatSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ChatScalarRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type MessageImagesNullableScalarRelationFilter = {
    is?: MessageImagesWhereInput | null
    isNot?: MessageImagesWhereInput | null
  }

  export type chatMessagesOrderByRelevanceInput = {
    fields: chatMessagesOrderByRelevanceFieldEnum | chatMessagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type chatMessagesCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    chatId?: SortOrder
    senderUserId?: SortOrder
    senderStoreId?: SortOrder
    receiverUserId?: SortOrder
    receiverStoreId?: SortOrder
    imageId?: SortOrder
    sentAt?: SortOrder
    receivedAt?: SortOrder
    wasReceived?: SortOrder
    readAt?: SortOrder
    wasRead?: SortOrder
  }

  export type chatMessagesAvgOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderUserId?: SortOrder
    senderStoreId?: SortOrder
    receiverUserId?: SortOrder
    receiverStoreId?: SortOrder
    imageId?: SortOrder
  }

  export type chatMessagesMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    chatId?: SortOrder
    senderUserId?: SortOrder
    senderStoreId?: SortOrder
    receiverUserId?: SortOrder
    receiverStoreId?: SortOrder
    imageId?: SortOrder
    sentAt?: SortOrder
    receivedAt?: SortOrder
    wasReceived?: SortOrder
    readAt?: SortOrder
    wasRead?: SortOrder
  }

  export type chatMessagesMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    chatId?: SortOrder
    senderUserId?: SortOrder
    senderStoreId?: SortOrder
    receiverUserId?: SortOrder
    receiverStoreId?: SortOrder
    imageId?: SortOrder
    sentAt?: SortOrder
    receivedAt?: SortOrder
    wasReceived?: SortOrder
    readAt?: SortOrder
    wasRead?: SortOrder
  }

  export type chatMessagesSumOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderUserId?: SortOrder
    senderStoreId?: SortOrder
    receiverUserId?: SortOrder
    receiverStoreId?: SortOrder
    imageId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ChatMessagesNullableScalarRelationFilter = {
    is?: chatMessagesWhereInput | null
    isNot?: chatMessagesWhereInput | null
  }

  export type MessageImagesOrderByRelevanceInput = {
    fields: MessageImagesOrderByRelevanceFieldEnum | MessageImagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MessageImagesCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
  }

  export type MessageImagesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MessageImagesMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
  }

  export type MessageImagesMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
  }

  export type MessageImagesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LoginTokenOrderByRelevanceInput = {
    fields: LoginTokenOrderByRelevanceFieldEnum | LoginTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LoginTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
  }

  export type LoginTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LoginTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
  }

  export type LoginTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
  }

  export type LoginTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ConfirmationTokenOrderByRelevanceInput = {
    fields: ConfirmationTokenOrderByRelevanceFieldEnum | ConfirmationTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ConfirmationTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
  }

  export type ConfirmationTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ConfirmationTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
  }

  export type ConfirmationTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
  }

  export type ConfirmationTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LogOrderByRelevanceInput = {
    fields: LogOrderByRelevanceFieldEnum | LogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    details?: SortOrder
  }

  export type LogAvgOrderByAggregateInput = {
    id?: SortOrder
    recordId?: SortOrder
    userId?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    details?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    details?: SortOrder
  }

  export type LogSumOrderByAggregateInput = {
    id?: SortOrder
    recordId?: SortOrder
    userId?: SortOrder
  }

  export type TwoFactorAuthOrderByRelevanceInput = {
    fields: TwoFactorAuthOrderByRelevanceFieldEnum | TwoFactorAuthOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TwoFactorAuthCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    secret?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwoFactorAuthAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TwoFactorAuthMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    secret?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwoFactorAuthMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    secret?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwoFactorAuthSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AbandonedCartCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    abandonedAt?: SortOrder
  }

  export type AbandonedCartAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AbandonedCartMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    abandonedAt?: SortOrder
  }

  export type AbandonedCartMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    abandonedAt?: SortOrder
  }

  export type AbandonedCartSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumReturnExchangeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnExchangeStatus | EnumReturnExchangeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnExchangeStatus[]
    notIn?: $Enums.ReturnExchangeStatus[]
    not?: NestedEnumReturnExchangeStatusFilter<$PrismaModel> | $Enums.ReturnExchangeStatus
  }

  export type ReturnExchangeOrderByRelevanceInput = {
    fields: ReturnExchangeOrderByRelevanceFieldEnum | ReturnExchangeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReturnExchangeCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ReturnExchangeAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
  }

  export type ReturnExchangeMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ReturnExchangeMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ReturnExchangeSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
  }

  export type EnumReturnExchangeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnExchangeStatus | EnumReturnExchangeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnExchangeStatus[]
    notIn?: $Enums.ReturnExchangeStatus[]
    not?: NestedEnumReturnExchangeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReturnExchangeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReturnExchangeStatusFilter<$PrismaModel>
    _max?: NestedEnumReturnExchangeStatusFilter<$PrismaModel>
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AvatarUserCreateNestedOneWithoutUserInput = {
    create?: XOR<AvatarUserCreateWithoutUserInput, AvatarUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: AvatarUserCreateOrConnectWithoutUserInput
    connect?: AvatarUserWhereUniqueInput
  }

  export type LoginTokenCreateNestedOneWithoutUserInput = {
    create?: XOR<LoginTokenCreateWithoutUserInput, LoginTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: LoginTokenCreateOrConnectWithoutUserInput
    connect?: LoginTokenWhereUniqueInput
  }

  export type ConfirmationTokenCreateNestedOneWithoutUserInput = {
    create?: XOR<ConfirmationTokenCreateWithoutUserInput, ConfirmationTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: ConfirmationTokenCreateOrConnectWithoutUserInput
    connect?: ConfirmationTokenWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type AddressesCreateNestedOneWithoutPrincipalOfInput = {
    create?: XOR<AddressesCreateWithoutPrincipalOfInput, AddressesUncheckedCreateWithoutPrincipalOfInput>
    connectOrCreate?: AddressesCreateOrConnectWithoutPrincipalOfInput
    connect?: AddressesWhereUniqueInput
  }

  export type AddressesCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressesCreateWithoutUserInput, AddressesUncheckedCreateWithoutUserInput> | AddressesCreateWithoutUserInput[] | AddressesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressesCreateOrConnectWithoutUserInput | AddressesCreateOrConnectWithoutUserInput[]
    createMany?: AddressesCreateManyUserInputEnvelope
    connect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
  }

  export type StoresCreateNestedOneWithoutUserInput = {
    create?: XOR<StoresCreateWithoutUserInput, StoresUncheckedCreateWithoutUserInput>
    connectOrCreate?: StoresCreateOrConnectWithoutUserInput
    connect?: StoresWhereUniqueInput
  }

  export type ProductAvaliationsCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductAvaliationsCreateWithoutUserInput, ProductAvaliationsUncheckedCreateWithoutUserInput> | ProductAvaliationsCreateWithoutUserInput[] | ProductAvaliationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductAvaliationsCreateOrConnectWithoutUserInput | ProductAvaliationsCreateOrConnectWithoutUserInput[]
    createMany?: ProductAvaliationsCreateManyUserInputEnvelope
    connect?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
  }

  export type StoreAvaliationsCreateNestedManyWithoutUserInput = {
    create?: XOR<StoreAvaliationsCreateWithoutUserInput, StoreAvaliationsUncheckedCreateWithoutUserInput> | StoreAvaliationsCreateWithoutUserInput[] | StoreAvaliationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoreAvaliationsCreateOrConnectWithoutUserInput | StoreAvaliationsCreateOrConnectWithoutUserInput[]
    createMany?: StoreAvaliationsCreateManyUserInputEnvelope
    connect?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
  }

  export type CartCreateNestedOneWithoutUserCartInput = {
    create?: XOR<CartCreateWithoutUserCartInput, CartUncheckedCreateWithoutUserCartInput>
    connectOrCreate?: CartCreateOrConnectWithoutUserCartInput
    connect?: CartWhereUniqueInput
  }

  export type OrdersCreateNestedManyWithoutUserInput = {
    create?: XOR<OrdersCreateWithoutUserInput, OrdersUncheckedCreateWithoutUserInput> | OrdersCreateWithoutUserInput[] | OrdersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutUserInput | OrdersCreateOrConnectWithoutUserInput[]
    createMany?: OrdersCreateManyUserInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type UserUsedCouponsCreateNestedManyWithoutUserInput = {
    create?: XOR<UserUsedCouponsCreateWithoutUserInput, UserUsedCouponsUncheckedCreateWithoutUserInput> | UserUsedCouponsCreateWithoutUserInput[] | UserUsedCouponsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserUsedCouponsCreateOrConnectWithoutUserInput | UserUsedCouponsCreateOrConnectWithoutUserInput[]
    createMany?: UserUsedCouponsCreateManyUserInputEnvelope
    connect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type chatMessagesCreateNestedManyWithoutSenderUserInput = {
    create?: XOR<chatMessagesCreateWithoutSenderUserInput, chatMessagesUncheckedCreateWithoutSenderUserInput> | chatMessagesCreateWithoutSenderUserInput[] | chatMessagesUncheckedCreateWithoutSenderUserInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutSenderUserInput | chatMessagesCreateOrConnectWithoutSenderUserInput[]
    createMany?: chatMessagesCreateManySenderUserInputEnvelope
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
  }

  export type chatMessagesCreateNestedManyWithoutReceiverUserInput = {
    create?: XOR<chatMessagesCreateWithoutReceiverUserInput, chatMessagesUncheckedCreateWithoutReceiverUserInput> | chatMessagesCreateWithoutReceiverUserInput[] | chatMessagesUncheckedCreateWithoutReceiverUserInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutReceiverUserInput | chatMessagesCreateOrConnectWithoutReceiverUserInput[]
    createMany?: chatMessagesCreateManyReceiverUserInputEnvelope
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutUserInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type TwoFactorAuthCreateNestedManyWithoutUserInput = {
    create?: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput> | TwoFactorAuthCreateWithoutUserInput[] | TwoFactorAuthUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorAuthCreateOrConnectWithoutUserInput | TwoFactorAuthCreateOrConnectWithoutUserInput[]
    createMany?: TwoFactorAuthCreateManyUserInputEnvelope
    connect?: TwoFactorAuthWhereUniqueInput | TwoFactorAuthWhereUniqueInput[]
  }

  export type WishlistCreateNestedManyWithoutUserInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput> | WishlistCreateWithoutUserInput[] | WishlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput | WishlistCreateOrConnectWithoutUserInput[]
    createMany?: WishlistCreateManyUserInputEnvelope
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
  }

  export type AbandonedCartCreateNestedManyWithoutUserInput = {
    create?: XOR<AbandonedCartCreateWithoutUserInput, AbandonedCartUncheckedCreateWithoutUserInput> | AbandonedCartCreateWithoutUserInput[] | AbandonedCartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AbandonedCartCreateOrConnectWithoutUserInput | AbandonedCartCreateOrConnectWithoutUserInput[]
    createMany?: AbandonedCartCreateManyUserInputEnvelope
    connect?: AbandonedCartWhereUniqueInput | AbandonedCartWhereUniqueInput[]
  }

  export type AvatarUserUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AvatarUserCreateWithoutUserInput, AvatarUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: AvatarUserCreateOrConnectWithoutUserInput
    connect?: AvatarUserWhereUniqueInput
  }

  export type LoginTokenUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<LoginTokenCreateWithoutUserInput, LoginTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: LoginTokenCreateOrConnectWithoutUserInput
    connect?: LoginTokenWhereUniqueInput
  }

  export type ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ConfirmationTokenCreateWithoutUserInput, ConfirmationTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: ConfirmationTokenCreateOrConnectWithoutUserInput
    connect?: ConfirmationTokenWhereUniqueInput
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type AddressesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressesCreateWithoutUserInput, AddressesUncheckedCreateWithoutUserInput> | AddressesCreateWithoutUserInput[] | AddressesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressesCreateOrConnectWithoutUserInput | AddressesCreateOrConnectWithoutUserInput[]
    createMany?: AddressesCreateManyUserInputEnvelope
    connect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
  }

  export type StoresUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StoresCreateWithoutUserInput, StoresUncheckedCreateWithoutUserInput>
    connectOrCreate?: StoresCreateOrConnectWithoutUserInput
    connect?: StoresWhereUniqueInput
  }

  export type ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductAvaliationsCreateWithoutUserInput, ProductAvaliationsUncheckedCreateWithoutUserInput> | ProductAvaliationsCreateWithoutUserInput[] | ProductAvaliationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductAvaliationsCreateOrConnectWithoutUserInput | ProductAvaliationsCreateOrConnectWithoutUserInput[]
    createMany?: ProductAvaliationsCreateManyUserInputEnvelope
    connect?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
  }

  export type StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StoreAvaliationsCreateWithoutUserInput, StoreAvaliationsUncheckedCreateWithoutUserInput> | StoreAvaliationsCreateWithoutUserInput[] | StoreAvaliationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoreAvaliationsCreateOrConnectWithoutUserInput | StoreAvaliationsCreateOrConnectWithoutUserInput[]
    createMany?: StoreAvaliationsCreateManyUserInputEnvelope
    connect?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
  }

  export type OrdersUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrdersCreateWithoutUserInput, OrdersUncheckedCreateWithoutUserInput> | OrdersCreateWithoutUserInput[] | OrdersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutUserInput | OrdersCreateOrConnectWithoutUserInput[]
    createMany?: OrdersCreateManyUserInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserUsedCouponsCreateWithoutUserInput, UserUsedCouponsUncheckedCreateWithoutUserInput> | UserUsedCouponsCreateWithoutUserInput[] | UserUsedCouponsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserUsedCouponsCreateOrConnectWithoutUserInput | UserUsedCouponsCreateOrConnectWithoutUserInput[]
    createMany?: UserUsedCouponsCreateManyUserInputEnvelope
    connect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput = {
    create?: XOR<chatMessagesCreateWithoutSenderUserInput, chatMessagesUncheckedCreateWithoutSenderUserInput> | chatMessagesCreateWithoutSenderUserInput[] | chatMessagesUncheckedCreateWithoutSenderUserInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutSenderUserInput | chatMessagesCreateOrConnectWithoutSenderUserInput[]
    createMany?: chatMessagesCreateManySenderUserInputEnvelope
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
  }

  export type chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput = {
    create?: XOR<chatMessagesCreateWithoutReceiverUserInput, chatMessagesUncheckedCreateWithoutReceiverUserInput> | chatMessagesCreateWithoutReceiverUserInput[] | chatMessagesUncheckedCreateWithoutReceiverUserInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutReceiverUserInput | chatMessagesCreateOrConnectWithoutReceiverUserInput[]
    createMany?: chatMessagesCreateManyReceiverUserInputEnvelope
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput> | TwoFactorAuthCreateWithoutUserInput[] | TwoFactorAuthUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorAuthCreateOrConnectWithoutUserInput | TwoFactorAuthCreateOrConnectWithoutUserInput[]
    createMany?: TwoFactorAuthCreateManyUserInputEnvelope
    connect?: TwoFactorAuthWhereUniqueInput | TwoFactorAuthWhereUniqueInput[]
  }

  export type WishlistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput> | WishlistCreateWithoutUserInput[] | WishlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput | WishlistCreateOrConnectWithoutUserInput[]
    createMany?: WishlistCreateManyUserInputEnvelope
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
  }

  export type AbandonedCartUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AbandonedCartCreateWithoutUserInput, AbandonedCartUncheckedCreateWithoutUserInput> | AbandonedCartCreateWithoutUserInput[] | AbandonedCartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AbandonedCartCreateOrConnectWithoutUserInput | AbandonedCartCreateOrConnectWithoutUserInput[]
    createMany?: AbandonedCartCreateManyUserInputEnvelope
    connect?: AbandonedCartWhereUniqueInput | AbandonedCartWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AvatarUserUpdateOneWithoutUserNestedInput = {
    create?: XOR<AvatarUserCreateWithoutUserInput, AvatarUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: AvatarUserCreateOrConnectWithoutUserInput
    upsert?: AvatarUserUpsertWithoutUserInput
    disconnect?: AvatarUserWhereInput | boolean
    delete?: AvatarUserWhereInput | boolean
    connect?: AvatarUserWhereUniqueInput
    update?: XOR<XOR<AvatarUserUpdateToOneWithWhereWithoutUserInput, AvatarUserUpdateWithoutUserInput>, AvatarUserUncheckedUpdateWithoutUserInput>
  }

  export type LoginTokenUpdateOneWithoutUserNestedInput = {
    create?: XOR<LoginTokenCreateWithoutUserInput, LoginTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: LoginTokenCreateOrConnectWithoutUserInput
    upsert?: LoginTokenUpsertWithoutUserInput
    disconnect?: LoginTokenWhereInput | boolean
    delete?: LoginTokenWhereInput | boolean
    connect?: LoginTokenWhereUniqueInput
    update?: XOR<XOR<LoginTokenUpdateToOneWithWhereWithoutUserInput, LoginTokenUpdateWithoutUserInput>, LoginTokenUncheckedUpdateWithoutUserInput>
  }

  export type ConfirmationTokenUpdateOneWithoutUserNestedInput = {
    create?: XOR<ConfirmationTokenCreateWithoutUserInput, ConfirmationTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: ConfirmationTokenCreateOrConnectWithoutUserInput
    upsert?: ConfirmationTokenUpsertWithoutUserInput
    disconnect?: ConfirmationTokenWhereInput | boolean
    delete?: ConfirmationTokenWhereInput | boolean
    connect?: ConfirmationTokenWhereUniqueInput
    update?: XOR<XOR<ConfirmationTokenUpdateToOneWithWhereWithoutUserInput, ConfirmationTokenUpdateWithoutUserInput>, ConfirmationTokenUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AddressesUpdateOneWithoutPrincipalOfNestedInput = {
    create?: XOR<AddressesCreateWithoutPrincipalOfInput, AddressesUncheckedCreateWithoutPrincipalOfInput>
    connectOrCreate?: AddressesCreateOrConnectWithoutPrincipalOfInput
    upsert?: AddressesUpsertWithoutPrincipalOfInput
    disconnect?: AddressesWhereInput | boolean
    delete?: AddressesWhereInput | boolean
    connect?: AddressesWhereUniqueInput
    update?: XOR<XOR<AddressesUpdateToOneWithWhereWithoutPrincipalOfInput, AddressesUpdateWithoutPrincipalOfInput>, AddressesUncheckedUpdateWithoutPrincipalOfInput>
  }

  export type AddressesUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressesCreateWithoutUserInput, AddressesUncheckedCreateWithoutUserInput> | AddressesCreateWithoutUserInput[] | AddressesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressesCreateOrConnectWithoutUserInput | AddressesCreateOrConnectWithoutUserInput[]
    upsert?: AddressesUpsertWithWhereUniqueWithoutUserInput | AddressesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressesCreateManyUserInputEnvelope
    set?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    disconnect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    delete?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    connect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    update?: AddressesUpdateWithWhereUniqueWithoutUserInput | AddressesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressesUpdateManyWithWhereWithoutUserInput | AddressesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressesScalarWhereInput | AddressesScalarWhereInput[]
  }

  export type StoresUpdateOneWithoutUserNestedInput = {
    create?: XOR<StoresCreateWithoutUserInput, StoresUncheckedCreateWithoutUserInput>
    connectOrCreate?: StoresCreateOrConnectWithoutUserInput
    upsert?: StoresUpsertWithoutUserInput
    disconnect?: StoresWhereInput | boolean
    delete?: StoresWhereInput | boolean
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutUserInput, StoresUpdateWithoutUserInput>, StoresUncheckedUpdateWithoutUserInput>
  }

  export type ProductAvaliationsUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductAvaliationsCreateWithoutUserInput, ProductAvaliationsUncheckedCreateWithoutUserInput> | ProductAvaliationsCreateWithoutUserInput[] | ProductAvaliationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductAvaliationsCreateOrConnectWithoutUserInput | ProductAvaliationsCreateOrConnectWithoutUserInput[]
    upsert?: ProductAvaliationsUpsertWithWhereUniqueWithoutUserInput | ProductAvaliationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductAvaliationsCreateManyUserInputEnvelope
    set?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
    disconnect?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
    delete?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
    connect?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
    update?: ProductAvaliationsUpdateWithWhereUniqueWithoutUserInput | ProductAvaliationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductAvaliationsUpdateManyWithWhereWithoutUserInput | ProductAvaliationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductAvaliationsScalarWhereInput | ProductAvaliationsScalarWhereInput[]
  }

  export type StoreAvaliationsUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoreAvaliationsCreateWithoutUserInput, StoreAvaliationsUncheckedCreateWithoutUserInput> | StoreAvaliationsCreateWithoutUserInput[] | StoreAvaliationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoreAvaliationsCreateOrConnectWithoutUserInput | StoreAvaliationsCreateOrConnectWithoutUserInput[]
    upsert?: StoreAvaliationsUpsertWithWhereUniqueWithoutUserInput | StoreAvaliationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StoreAvaliationsCreateManyUserInputEnvelope
    set?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
    disconnect?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
    delete?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
    connect?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
    update?: StoreAvaliationsUpdateWithWhereUniqueWithoutUserInput | StoreAvaliationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoreAvaliationsUpdateManyWithWhereWithoutUserInput | StoreAvaliationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoreAvaliationsScalarWhereInput | StoreAvaliationsScalarWhereInput[]
  }

  export type CartUpdateOneRequiredWithoutUserCartNestedInput = {
    create?: XOR<CartCreateWithoutUserCartInput, CartUncheckedCreateWithoutUserCartInput>
    connectOrCreate?: CartCreateOrConnectWithoutUserCartInput
    upsert?: CartUpsertWithoutUserCartInput
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutUserCartInput, CartUpdateWithoutUserCartInput>, CartUncheckedUpdateWithoutUserCartInput>
  }

  export type OrdersUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrdersCreateWithoutUserInput, OrdersUncheckedCreateWithoutUserInput> | OrdersCreateWithoutUserInput[] | OrdersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutUserInput | OrdersCreateOrConnectWithoutUserInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutUserInput | OrdersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrdersCreateManyUserInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutUserInput | OrdersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutUserInput | OrdersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type UserUsedCouponsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserUsedCouponsCreateWithoutUserInput, UserUsedCouponsUncheckedCreateWithoutUserInput> | UserUsedCouponsCreateWithoutUserInput[] | UserUsedCouponsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserUsedCouponsCreateOrConnectWithoutUserInput | UserUsedCouponsCreateOrConnectWithoutUserInput[]
    upsert?: UserUsedCouponsUpsertWithWhereUniqueWithoutUserInput | UserUsedCouponsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserUsedCouponsCreateManyUserInputEnvelope
    set?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    disconnect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    delete?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    connect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    update?: UserUsedCouponsUpdateWithWhereUniqueWithoutUserInput | UserUsedCouponsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserUsedCouponsUpdateManyWithWhereWithoutUserInput | UserUsedCouponsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserUsedCouponsScalarWhereInput | UserUsedCouponsScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUserInput | ChatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUserInput | ChatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutUserInput | ChatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type chatMessagesUpdateManyWithoutSenderUserNestedInput = {
    create?: XOR<chatMessagesCreateWithoutSenderUserInput, chatMessagesUncheckedCreateWithoutSenderUserInput> | chatMessagesCreateWithoutSenderUserInput[] | chatMessagesUncheckedCreateWithoutSenderUserInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutSenderUserInput | chatMessagesCreateOrConnectWithoutSenderUserInput[]
    upsert?: chatMessagesUpsertWithWhereUniqueWithoutSenderUserInput | chatMessagesUpsertWithWhereUniqueWithoutSenderUserInput[]
    createMany?: chatMessagesCreateManySenderUserInputEnvelope
    set?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    disconnect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    delete?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    update?: chatMessagesUpdateWithWhereUniqueWithoutSenderUserInput | chatMessagesUpdateWithWhereUniqueWithoutSenderUserInput[]
    updateMany?: chatMessagesUpdateManyWithWhereWithoutSenderUserInput | chatMessagesUpdateManyWithWhereWithoutSenderUserInput[]
    deleteMany?: chatMessagesScalarWhereInput | chatMessagesScalarWhereInput[]
  }

  export type chatMessagesUpdateManyWithoutReceiverUserNestedInput = {
    create?: XOR<chatMessagesCreateWithoutReceiverUserInput, chatMessagesUncheckedCreateWithoutReceiverUserInput> | chatMessagesCreateWithoutReceiverUserInput[] | chatMessagesUncheckedCreateWithoutReceiverUserInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutReceiverUserInput | chatMessagesCreateOrConnectWithoutReceiverUserInput[]
    upsert?: chatMessagesUpsertWithWhereUniqueWithoutReceiverUserInput | chatMessagesUpsertWithWhereUniqueWithoutReceiverUserInput[]
    createMany?: chatMessagesCreateManyReceiverUserInputEnvelope
    set?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    disconnect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    delete?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    update?: chatMessagesUpdateWithWhereUniqueWithoutReceiverUserInput | chatMessagesUpdateWithWhereUniqueWithoutReceiverUserInput[]
    updateMany?: chatMessagesUpdateManyWithWhereWithoutReceiverUserInput | chatMessagesUpdateManyWithWhereWithoutReceiverUserInput[]
    deleteMany?: chatMessagesScalarWhereInput | chatMessagesScalarWhereInput[]
  }

  export type LogUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUserInput | LogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUserInput | LogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUserInput | LogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type TwoFactorAuthUpdateManyWithoutUserNestedInput = {
    create?: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput> | TwoFactorAuthCreateWithoutUserInput[] | TwoFactorAuthUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorAuthCreateOrConnectWithoutUserInput | TwoFactorAuthCreateOrConnectWithoutUserInput[]
    upsert?: TwoFactorAuthUpsertWithWhereUniqueWithoutUserInput | TwoFactorAuthUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TwoFactorAuthCreateManyUserInputEnvelope
    set?: TwoFactorAuthWhereUniqueInput | TwoFactorAuthWhereUniqueInput[]
    disconnect?: TwoFactorAuthWhereUniqueInput | TwoFactorAuthWhereUniqueInput[]
    delete?: TwoFactorAuthWhereUniqueInput | TwoFactorAuthWhereUniqueInput[]
    connect?: TwoFactorAuthWhereUniqueInput | TwoFactorAuthWhereUniqueInput[]
    update?: TwoFactorAuthUpdateWithWhereUniqueWithoutUserInput | TwoFactorAuthUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TwoFactorAuthUpdateManyWithWhereWithoutUserInput | TwoFactorAuthUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TwoFactorAuthScalarWhereInput | TwoFactorAuthScalarWhereInput[]
  }

  export type WishlistUpdateManyWithoutUserNestedInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput> | WishlistCreateWithoutUserInput[] | WishlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput | WishlistCreateOrConnectWithoutUserInput[]
    upsert?: WishlistUpsertWithWhereUniqueWithoutUserInput | WishlistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WishlistCreateManyUserInputEnvelope
    set?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    disconnect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    delete?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    update?: WishlistUpdateWithWhereUniqueWithoutUserInput | WishlistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WishlistUpdateManyWithWhereWithoutUserInput | WishlistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
  }

  export type AbandonedCartUpdateManyWithoutUserNestedInput = {
    create?: XOR<AbandonedCartCreateWithoutUserInput, AbandonedCartUncheckedCreateWithoutUserInput> | AbandonedCartCreateWithoutUserInput[] | AbandonedCartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AbandonedCartCreateOrConnectWithoutUserInput | AbandonedCartCreateOrConnectWithoutUserInput[]
    upsert?: AbandonedCartUpsertWithWhereUniqueWithoutUserInput | AbandonedCartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AbandonedCartCreateManyUserInputEnvelope
    set?: AbandonedCartWhereUniqueInput | AbandonedCartWhereUniqueInput[]
    disconnect?: AbandonedCartWhereUniqueInput | AbandonedCartWhereUniqueInput[]
    delete?: AbandonedCartWhereUniqueInput | AbandonedCartWhereUniqueInput[]
    connect?: AbandonedCartWhereUniqueInput | AbandonedCartWhereUniqueInput[]
    update?: AbandonedCartUpdateWithWhereUniqueWithoutUserInput | AbandonedCartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AbandonedCartUpdateManyWithWhereWithoutUserInput | AbandonedCartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AbandonedCartScalarWhereInput | AbandonedCartScalarWhereInput[]
  }

  export type AvatarUserUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AvatarUserCreateWithoutUserInput, AvatarUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: AvatarUserCreateOrConnectWithoutUserInput
    upsert?: AvatarUserUpsertWithoutUserInput
    disconnect?: AvatarUserWhereInput | boolean
    delete?: AvatarUserWhereInput | boolean
    connect?: AvatarUserWhereUniqueInput
    update?: XOR<XOR<AvatarUserUpdateToOneWithWhereWithoutUserInput, AvatarUserUpdateWithoutUserInput>, AvatarUserUncheckedUpdateWithoutUserInput>
  }

  export type LoginTokenUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<LoginTokenCreateWithoutUserInput, LoginTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: LoginTokenCreateOrConnectWithoutUserInput
    upsert?: LoginTokenUpsertWithoutUserInput
    disconnect?: LoginTokenWhereInput | boolean
    delete?: LoginTokenWhereInput | boolean
    connect?: LoginTokenWhereUniqueInput
    update?: XOR<XOR<LoginTokenUpdateToOneWithWhereWithoutUserInput, LoginTokenUpdateWithoutUserInput>, LoginTokenUncheckedUpdateWithoutUserInput>
  }

  export type ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ConfirmationTokenCreateWithoutUserInput, ConfirmationTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: ConfirmationTokenCreateOrConnectWithoutUserInput
    upsert?: ConfirmationTokenUpsertWithoutUserInput
    disconnect?: ConfirmationTokenWhereInput | boolean
    delete?: ConfirmationTokenWhereInput | boolean
    connect?: ConfirmationTokenWhereUniqueInput
    update?: XOR<XOR<ConfirmationTokenUpdateToOneWithWhereWithoutUserInput, ConfirmationTokenUpdateWithoutUserInput>, ConfirmationTokenUncheckedUpdateWithoutUserInput>
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AddressesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressesCreateWithoutUserInput, AddressesUncheckedCreateWithoutUserInput> | AddressesCreateWithoutUserInput[] | AddressesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressesCreateOrConnectWithoutUserInput | AddressesCreateOrConnectWithoutUserInput[]
    upsert?: AddressesUpsertWithWhereUniqueWithoutUserInput | AddressesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressesCreateManyUserInputEnvelope
    set?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    disconnect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    delete?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    connect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    update?: AddressesUpdateWithWhereUniqueWithoutUserInput | AddressesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressesUpdateManyWithWhereWithoutUserInput | AddressesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressesScalarWhereInput | AddressesScalarWhereInput[]
  }

  export type StoresUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StoresCreateWithoutUserInput, StoresUncheckedCreateWithoutUserInput>
    connectOrCreate?: StoresCreateOrConnectWithoutUserInput
    upsert?: StoresUpsertWithoutUserInput
    disconnect?: StoresWhereInput | boolean
    delete?: StoresWhereInput | boolean
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutUserInput, StoresUpdateWithoutUserInput>, StoresUncheckedUpdateWithoutUserInput>
  }

  export type ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductAvaliationsCreateWithoutUserInput, ProductAvaliationsUncheckedCreateWithoutUserInput> | ProductAvaliationsCreateWithoutUserInput[] | ProductAvaliationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductAvaliationsCreateOrConnectWithoutUserInput | ProductAvaliationsCreateOrConnectWithoutUserInput[]
    upsert?: ProductAvaliationsUpsertWithWhereUniqueWithoutUserInput | ProductAvaliationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductAvaliationsCreateManyUserInputEnvelope
    set?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
    disconnect?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
    delete?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
    connect?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
    update?: ProductAvaliationsUpdateWithWhereUniqueWithoutUserInput | ProductAvaliationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductAvaliationsUpdateManyWithWhereWithoutUserInput | ProductAvaliationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductAvaliationsScalarWhereInput | ProductAvaliationsScalarWhereInput[]
  }

  export type StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StoreAvaliationsCreateWithoutUserInput, StoreAvaliationsUncheckedCreateWithoutUserInput> | StoreAvaliationsCreateWithoutUserInput[] | StoreAvaliationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StoreAvaliationsCreateOrConnectWithoutUserInput | StoreAvaliationsCreateOrConnectWithoutUserInput[]
    upsert?: StoreAvaliationsUpsertWithWhereUniqueWithoutUserInput | StoreAvaliationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StoreAvaliationsCreateManyUserInputEnvelope
    set?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
    disconnect?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
    delete?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
    connect?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
    update?: StoreAvaliationsUpdateWithWhereUniqueWithoutUserInput | StoreAvaliationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StoreAvaliationsUpdateManyWithWhereWithoutUserInput | StoreAvaliationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StoreAvaliationsScalarWhereInput | StoreAvaliationsScalarWhereInput[]
  }

  export type OrdersUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrdersCreateWithoutUserInput, OrdersUncheckedCreateWithoutUserInput> | OrdersCreateWithoutUserInput[] | OrdersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutUserInput | OrdersCreateOrConnectWithoutUserInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutUserInput | OrdersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrdersCreateManyUserInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutUserInput | OrdersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutUserInput | OrdersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserUsedCouponsCreateWithoutUserInput, UserUsedCouponsUncheckedCreateWithoutUserInput> | UserUsedCouponsCreateWithoutUserInput[] | UserUsedCouponsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserUsedCouponsCreateOrConnectWithoutUserInput | UserUsedCouponsCreateOrConnectWithoutUserInput[]
    upsert?: UserUsedCouponsUpsertWithWhereUniqueWithoutUserInput | UserUsedCouponsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserUsedCouponsCreateManyUserInputEnvelope
    set?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    disconnect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    delete?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    connect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    update?: UserUsedCouponsUpdateWithWhereUniqueWithoutUserInput | UserUsedCouponsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserUsedCouponsUpdateManyWithWhereWithoutUserInput | UserUsedCouponsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserUsedCouponsScalarWhereInput | UserUsedCouponsScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUserInput | ChatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUserInput | ChatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutUserInput | ChatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput = {
    create?: XOR<chatMessagesCreateWithoutSenderUserInput, chatMessagesUncheckedCreateWithoutSenderUserInput> | chatMessagesCreateWithoutSenderUserInput[] | chatMessagesUncheckedCreateWithoutSenderUserInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutSenderUserInput | chatMessagesCreateOrConnectWithoutSenderUserInput[]
    upsert?: chatMessagesUpsertWithWhereUniqueWithoutSenderUserInput | chatMessagesUpsertWithWhereUniqueWithoutSenderUserInput[]
    createMany?: chatMessagesCreateManySenderUserInputEnvelope
    set?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    disconnect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    delete?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    update?: chatMessagesUpdateWithWhereUniqueWithoutSenderUserInput | chatMessagesUpdateWithWhereUniqueWithoutSenderUserInput[]
    updateMany?: chatMessagesUpdateManyWithWhereWithoutSenderUserInput | chatMessagesUpdateManyWithWhereWithoutSenderUserInput[]
    deleteMany?: chatMessagesScalarWhereInput | chatMessagesScalarWhereInput[]
  }

  export type chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput = {
    create?: XOR<chatMessagesCreateWithoutReceiverUserInput, chatMessagesUncheckedCreateWithoutReceiverUserInput> | chatMessagesCreateWithoutReceiverUserInput[] | chatMessagesUncheckedCreateWithoutReceiverUserInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutReceiverUserInput | chatMessagesCreateOrConnectWithoutReceiverUserInput[]
    upsert?: chatMessagesUpsertWithWhereUniqueWithoutReceiverUserInput | chatMessagesUpsertWithWhereUniqueWithoutReceiverUserInput[]
    createMany?: chatMessagesCreateManyReceiverUserInputEnvelope
    set?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    disconnect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    delete?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    update?: chatMessagesUpdateWithWhereUniqueWithoutReceiverUserInput | chatMessagesUpdateWithWhereUniqueWithoutReceiverUserInput[]
    updateMany?: chatMessagesUpdateManyWithWhereWithoutReceiverUserInput | chatMessagesUpdateManyWithWhereWithoutReceiverUserInput[]
    deleteMany?: chatMessagesScalarWhereInput | chatMessagesScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUserInput | LogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUserInput | LogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUserInput | LogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput> | TwoFactorAuthCreateWithoutUserInput[] | TwoFactorAuthUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorAuthCreateOrConnectWithoutUserInput | TwoFactorAuthCreateOrConnectWithoutUserInput[]
    upsert?: TwoFactorAuthUpsertWithWhereUniqueWithoutUserInput | TwoFactorAuthUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TwoFactorAuthCreateManyUserInputEnvelope
    set?: TwoFactorAuthWhereUniqueInput | TwoFactorAuthWhereUniqueInput[]
    disconnect?: TwoFactorAuthWhereUniqueInput | TwoFactorAuthWhereUniqueInput[]
    delete?: TwoFactorAuthWhereUniqueInput | TwoFactorAuthWhereUniqueInput[]
    connect?: TwoFactorAuthWhereUniqueInput | TwoFactorAuthWhereUniqueInput[]
    update?: TwoFactorAuthUpdateWithWhereUniqueWithoutUserInput | TwoFactorAuthUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TwoFactorAuthUpdateManyWithWhereWithoutUserInput | TwoFactorAuthUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TwoFactorAuthScalarWhereInput | TwoFactorAuthScalarWhereInput[]
  }

  export type WishlistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput> | WishlistCreateWithoutUserInput[] | WishlistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutUserInput | WishlistCreateOrConnectWithoutUserInput[]
    upsert?: WishlistUpsertWithWhereUniqueWithoutUserInput | WishlistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WishlistCreateManyUserInputEnvelope
    set?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    disconnect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    delete?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    update?: WishlistUpdateWithWhereUniqueWithoutUserInput | WishlistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WishlistUpdateManyWithWhereWithoutUserInput | WishlistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
  }

  export type AbandonedCartUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AbandonedCartCreateWithoutUserInput, AbandonedCartUncheckedCreateWithoutUserInput> | AbandonedCartCreateWithoutUserInput[] | AbandonedCartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AbandonedCartCreateOrConnectWithoutUserInput | AbandonedCartCreateOrConnectWithoutUserInput[]
    upsert?: AbandonedCartUpsertWithWhereUniqueWithoutUserInput | AbandonedCartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AbandonedCartCreateManyUserInputEnvelope
    set?: AbandonedCartWhereUniqueInput | AbandonedCartWhereUniqueInput[]
    disconnect?: AbandonedCartWhereUniqueInput | AbandonedCartWhereUniqueInput[]
    delete?: AbandonedCartWhereUniqueInput | AbandonedCartWhereUniqueInput[]
    connect?: AbandonedCartWhereUniqueInput | AbandonedCartWhereUniqueInput[]
    update?: AbandonedCartUpdateWithWhereUniqueWithoutUserInput | AbandonedCartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AbandonedCartUpdateManyWithWhereWithoutUserInput | AbandonedCartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AbandonedCartScalarWhereInput | AbandonedCartScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAvatarInput = {
    create?: XOR<UserCreateWithoutAvatarInput, UserUncheckedCreateWithoutAvatarInput>
    connectOrCreate?: UserCreateOrConnectWithoutAvatarInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAvatarNestedInput = {
    create?: XOR<UserCreateWithoutAvatarInput, UserUncheckedCreateWithoutAvatarInput>
    connectOrCreate?: UserCreateOrConnectWithoutAvatarInput
    upsert?: UserUpsertWithoutAvatarInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAvatarInput, UserUpdateWithoutAvatarInput>, UserUncheckedUpdateWithoutAvatarInput>
  }

  export type UserCreateNestedOneWithoutAddressesInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPrincipalAddressInput = {
    create?: XOR<UserCreateWithoutPrincipalAddressInput, UserUncheckedCreateWithoutPrincipalAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrincipalAddressInput
    connect?: UserWhereUniqueInput
  }

  export type OrdersCreateNestedManyWithoutDeliveryAddressInput = {
    create?: XOR<OrdersCreateWithoutDeliveryAddressInput, OrdersUncheckedCreateWithoutDeliveryAddressInput> | OrdersCreateWithoutDeliveryAddressInput[] | OrdersUncheckedCreateWithoutDeliveryAddressInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutDeliveryAddressInput | OrdersCreateOrConnectWithoutDeliveryAddressInput[]
    createMany?: OrdersCreateManyDeliveryAddressInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedOneWithoutPrincipalAddressInput = {
    create?: XOR<UserCreateWithoutPrincipalAddressInput, UserUncheckedCreateWithoutPrincipalAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrincipalAddressInput
    connect?: UserWhereUniqueInput
  }

  export type OrdersUncheckedCreateNestedManyWithoutDeliveryAddressInput = {
    create?: XOR<OrdersCreateWithoutDeliveryAddressInput, OrdersUncheckedCreateWithoutDeliveryAddressInput> | OrdersCreateWithoutDeliveryAddressInput[] | OrdersUncheckedCreateWithoutDeliveryAddressInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutDeliveryAddressInput | OrdersCreateOrConnectWithoutDeliveryAddressInput[]
    createMany?: OrdersCreateManyDeliveryAddressInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput
    upsert?: UserUpsertWithoutAddressesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddressesInput, UserUpdateWithoutAddressesInput>, UserUncheckedUpdateWithoutAddressesInput>
  }

  export type UserUpdateOneWithoutPrincipalAddressNestedInput = {
    create?: XOR<UserCreateWithoutPrincipalAddressInput, UserUncheckedCreateWithoutPrincipalAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrincipalAddressInput
    upsert?: UserUpsertWithoutPrincipalAddressInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPrincipalAddressInput, UserUpdateWithoutPrincipalAddressInput>, UserUncheckedUpdateWithoutPrincipalAddressInput>
  }

  export type OrdersUpdateManyWithoutDeliveryAddressNestedInput = {
    create?: XOR<OrdersCreateWithoutDeliveryAddressInput, OrdersUncheckedCreateWithoutDeliveryAddressInput> | OrdersCreateWithoutDeliveryAddressInput[] | OrdersUncheckedCreateWithoutDeliveryAddressInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutDeliveryAddressInput | OrdersCreateOrConnectWithoutDeliveryAddressInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutDeliveryAddressInput | OrdersUpsertWithWhereUniqueWithoutDeliveryAddressInput[]
    createMany?: OrdersCreateManyDeliveryAddressInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutDeliveryAddressInput | OrdersUpdateWithWhereUniqueWithoutDeliveryAddressInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutDeliveryAddressInput | OrdersUpdateManyWithWhereWithoutDeliveryAddressInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type UserUncheckedUpdateOneWithoutPrincipalAddressNestedInput = {
    create?: XOR<UserCreateWithoutPrincipalAddressInput, UserUncheckedCreateWithoutPrincipalAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrincipalAddressInput
    upsert?: UserUpsertWithoutPrincipalAddressInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPrincipalAddressInput, UserUpdateWithoutPrincipalAddressInput>, UserUncheckedUpdateWithoutPrincipalAddressInput>
  }

  export type OrdersUncheckedUpdateManyWithoutDeliveryAddressNestedInput = {
    create?: XOR<OrdersCreateWithoutDeliveryAddressInput, OrdersUncheckedCreateWithoutDeliveryAddressInput> | OrdersCreateWithoutDeliveryAddressInput[] | OrdersUncheckedCreateWithoutDeliveryAddressInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutDeliveryAddressInput | OrdersCreateOrConnectWithoutDeliveryAddressInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutDeliveryAddressInput | OrdersUpsertWithWhereUniqueWithoutDeliveryAddressInput[]
    createMany?: OrdersCreateManyDeliveryAddressInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutDeliveryAddressInput | OrdersUpdateWithWhereUniqueWithoutDeliveryAddressInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutDeliveryAddressInput | OrdersUpdateManyWithWhereWithoutDeliveryAddressInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUsedCouponsInput = {
    create?: XOR<UserCreateWithoutUsedCouponsInput, UserUncheckedCreateWithoutUsedCouponsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsedCouponsInput
    connect?: UserWhereUniqueInput
  }

  export type CouponsCreateNestedOneWithoutUsedCouponsInput = {
    create?: XOR<CouponsCreateWithoutUsedCouponsInput, CouponsUncheckedCreateWithoutUsedCouponsInput>
    connectOrCreate?: CouponsCreateOrConnectWithoutUsedCouponsInput
    connect?: CouponsWhereUniqueInput
  }

  export type OrdersCreateNestedOneWithoutUsedCouponsInput = {
    create?: XOR<OrdersCreateWithoutUsedCouponsInput, OrdersUncheckedCreateWithoutUsedCouponsInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutUsedCouponsInput
    connect?: OrdersWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUsedCouponsNestedInput = {
    create?: XOR<UserCreateWithoutUsedCouponsInput, UserUncheckedCreateWithoutUsedCouponsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsedCouponsInput
    upsert?: UserUpsertWithoutUsedCouponsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUsedCouponsInput, UserUpdateWithoutUsedCouponsInput>, UserUncheckedUpdateWithoutUsedCouponsInput>
  }

  export type CouponsUpdateOneRequiredWithoutUsedCouponsNestedInput = {
    create?: XOR<CouponsCreateWithoutUsedCouponsInput, CouponsUncheckedCreateWithoutUsedCouponsInput>
    connectOrCreate?: CouponsCreateOrConnectWithoutUsedCouponsInput
    upsert?: CouponsUpsertWithoutUsedCouponsInput
    connect?: CouponsWhereUniqueInput
    update?: XOR<XOR<CouponsUpdateToOneWithWhereWithoutUsedCouponsInput, CouponsUpdateWithoutUsedCouponsInput>, CouponsUncheckedUpdateWithoutUsedCouponsInput>
  }

  export type OrdersUpdateOneWithoutUsedCouponsNestedInput = {
    create?: XOR<OrdersCreateWithoutUsedCouponsInput, OrdersUncheckedCreateWithoutUsedCouponsInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutUsedCouponsInput
    upsert?: OrdersUpsertWithoutUsedCouponsInput
    disconnect?: OrdersWhereInput | boolean
    delete?: OrdersWhereInput | boolean
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutUsedCouponsInput, OrdersUpdateWithoutUsedCouponsInput>, OrdersUncheckedUpdateWithoutUsedCouponsInput>
  }

  export type UserCreateNestedOneWithoutStoreInput = {
    create?: XOR<UserCreateWithoutStoreInput, UserUncheckedCreateWithoutStoreInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoreInput
    connect?: UserWhereUniqueInput
  }

  export type AvatarStoreCreateNestedOneWithoutStoreAvatarInput = {
    create?: XOR<AvatarStoreCreateWithoutStoreAvatarInput, AvatarStoreUncheckedCreateWithoutStoreAvatarInput>
    connectOrCreate?: AvatarStoreCreateOrConnectWithoutStoreAvatarInput
    connect?: AvatarStoreWhereUniqueInput
  }

  export type ProductsCreateNestedManyWithoutStoreInput = {
    create?: XOR<ProductsCreateWithoutStoreInput, ProductsUncheckedCreateWithoutStoreInput> | ProductsCreateWithoutStoreInput[] | ProductsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutStoreInput | ProductsCreateOrConnectWithoutStoreInput[]
    createMany?: ProductsCreateManyStoreInputEnvelope
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type StoreAvaliationsCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreAvaliationsCreateWithoutStoreInput, StoreAvaliationsUncheckedCreateWithoutStoreInput> | StoreAvaliationsCreateWithoutStoreInput[] | StoreAvaliationsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreAvaliationsCreateOrConnectWithoutStoreInput | StoreAvaliationsCreateOrConnectWithoutStoreInput[]
    createMany?: StoreAvaliationsCreateManyStoreInputEnvelope
    connect?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
  }

  export type CouponsCreateNestedManyWithoutStoreInput = {
    create?: XOR<CouponsCreateWithoutStoreInput, CouponsUncheckedCreateWithoutStoreInput> | CouponsCreateWithoutStoreInput[] | CouponsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: CouponsCreateOrConnectWithoutStoreInput | CouponsCreateOrConnectWithoutStoreInput[]
    createMany?: CouponsCreateManyStoreInputEnvelope
    connect?: CouponsWhereUniqueInput | CouponsWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutStoreInput = {
    create?: XOR<ChatCreateWithoutStoreInput, ChatUncheckedCreateWithoutStoreInput> | ChatCreateWithoutStoreInput[] | ChatUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutStoreInput | ChatCreateOrConnectWithoutStoreInput[]
    createMany?: ChatCreateManyStoreInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type chatMessagesCreateNestedManyWithoutSenderStoreInput = {
    create?: XOR<chatMessagesCreateWithoutSenderStoreInput, chatMessagesUncheckedCreateWithoutSenderStoreInput> | chatMessagesCreateWithoutSenderStoreInput[] | chatMessagesUncheckedCreateWithoutSenderStoreInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutSenderStoreInput | chatMessagesCreateOrConnectWithoutSenderStoreInput[]
    createMany?: chatMessagesCreateManySenderStoreInputEnvelope
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
  }

  export type chatMessagesCreateNestedManyWithoutReceiverStoreInput = {
    create?: XOR<chatMessagesCreateWithoutReceiverStoreInput, chatMessagesUncheckedCreateWithoutReceiverStoreInput> | chatMessagesCreateWithoutReceiverStoreInput[] | chatMessagesUncheckedCreateWithoutReceiverStoreInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutReceiverStoreInput | chatMessagesCreateOrConnectWithoutReceiverStoreInput[]
    createMany?: chatMessagesCreateManyReceiverStoreInputEnvelope
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
  }

  export type OrderItemsCreateNestedManyWithoutStoreInput = {
    create?: XOR<OrderItemsCreateWithoutStoreInput, OrderItemsUncheckedCreateWithoutStoreInput> | OrderItemsCreateWithoutStoreInput[] | OrderItemsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutStoreInput | OrderItemsCreateOrConnectWithoutStoreInput[]
    createMany?: OrderItemsCreateManyStoreInputEnvelope
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
  }

  export type PromotionCreateNestedManyWithoutStoreInput = {
    create?: XOR<PromotionCreateWithoutStoreInput, PromotionUncheckedCreateWithoutStoreInput> | PromotionCreateWithoutStoreInput[] | PromotionUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutStoreInput | PromotionCreateOrConnectWithoutStoreInput[]
    createMany?: PromotionCreateManyStoreInputEnvelope
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type ProductsUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<ProductsCreateWithoutStoreInput, ProductsUncheckedCreateWithoutStoreInput> | ProductsCreateWithoutStoreInput[] | ProductsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutStoreInput | ProductsCreateOrConnectWithoutStoreInput[]
    createMany?: ProductsCreateManyStoreInputEnvelope
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type StoreAvaliationsUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreAvaliationsCreateWithoutStoreInput, StoreAvaliationsUncheckedCreateWithoutStoreInput> | StoreAvaliationsCreateWithoutStoreInput[] | StoreAvaliationsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreAvaliationsCreateOrConnectWithoutStoreInput | StoreAvaliationsCreateOrConnectWithoutStoreInput[]
    createMany?: StoreAvaliationsCreateManyStoreInputEnvelope
    connect?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
  }

  export type CouponsUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<CouponsCreateWithoutStoreInput, CouponsUncheckedCreateWithoutStoreInput> | CouponsCreateWithoutStoreInput[] | CouponsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: CouponsCreateOrConnectWithoutStoreInput | CouponsCreateOrConnectWithoutStoreInput[]
    createMany?: CouponsCreateManyStoreInputEnvelope
    connect?: CouponsWhereUniqueInput | CouponsWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<ChatCreateWithoutStoreInput, ChatUncheckedCreateWithoutStoreInput> | ChatCreateWithoutStoreInput[] | ChatUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutStoreInput | ChatCreateOrConnectWithoutStoreInput[]
    createMany?: ChatCreateManyStoreInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type chatMessagesUncheckedCreateNestedManyWithoutSenderStoreInput = {
    create?: XOR<chatMessagesCreateWithoutSenderStoreInput, chatMessagesUncheckedCreateWithoutSenderStoreInput> | chatMessagesCreateWithoutSenderStoreInput[] | chatMessagesUncheckedCreateWithoutSenderStoreInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutSenderStoreInput | chatMessagesCreateOrConnectWithoutSenderStoreInput[]
    createMany?: chatMessagesCreateManySenderStoreInputEnvelope
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
  }

  export type chatMessagesUncheckedCreateNestedManyWithoutReceiverStoreInput = {
    create?: XOR<chatMessagesCreateWithoutReceiverStoreInput, chatMessagesUncheckedCreateWithoutReceiverStoreInput> | chatMessagesCreateWithoutReceiverStoreInput[] | chatMessagesUncheckedCreateWithoutReceiverStoreInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutReceiverStoreInput | chatMessagesCreateOrConnectWithoutReceiverStoreInput[]
    createMany?: chatMessagesCreateManyReceiverStoreInputEnvelope
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
  }

  export type OrderItemsUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<OrderItemsCreateWithoutStoreInput, OrderItemsUncheckedCreateWithoutStoreInput> | OrderItemsCreateWithoutStoreInput[] | OrderItemsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutStoreInput | OrderItemsCreateOrConnectWithoutStoreInput[]
    createMany?: OrderItemsCreateManyStoreInputEnvelope
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
  }

  export type PromotionUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<PromotionCreateWithoutStoreInput, PromotionUncheckedCreateWithoutStoreInput> | PromotionCreateWithoutStoreInput[] | PromotionUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutStoreInput | PromotionCreateOrConnectWithoutStoreInput[]
    createMany?: PromotionCreateManyStoreInputEnvelope
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutStoreNestedInput = {
    create?: XOR<UserCreateWithoutStoreInput, UserUncheckedCreateWithoutStoreInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoreInput
    upsert?: UserUpsertWithoutStoreInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStoreInput, UserUpdateWithoutStoreInput>, UserUncheckedUpdateWithoutStoreInput>
  }

  export type AvatarStoreUpdateOneWithoutStoreAvatarNestedInput = {
    create?: XOR<AvatarStoreCreateWithoutStoreAvatarInput, AvatarStoreUncheckedCreateWithoutStoreAvatarInput>
    connectOrCreate?: AvatarStoreCreateOrConnectWithoutStoreAvatarInput
    upsert?: AvatarStoreUpsertWithoutStoreAvatarInput
    disconnect?: AvatarStoreWhereInput | boolean
    delete?: AvatarStoreWhereInput | boolean
    connect?: AvatarStoreWhereUniqueInput
    update?: XOR<XOR<AvatarStoreUpdateToOneWithWhereWithoutStoreAvatarInput, AvatarStoreUpdateWithoutStoreAvatarInput>, AvatarStoreUncheckedUpdateWithoutStoreAvatarInput>
  }

  export type ProductsUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ProductsCreateWithoutStoreInput, ProductsUncheckedCreateWithoutStoreInput> | ProductsCreateWithoutStoreInput[] | ProductsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutStoreInput | ProductsCreateOrConnectWithoutStoreInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutStoreInput | ProductsUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ProductsCreateManyStoreInputEnvelope
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutStoreInput | ProductsUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutStoreInput | ProductsUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type StoreAvaliationsUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreAvaliationsCreateWithoutStoreInput, StoreAvaliationsUncheckedCreateWithoutStoreInput> | StoreAvaliationsCreateWithoutStoreInput[] | StoreAvaliationsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreAvaliationsCreateOrConnectWithoutStoreInput | StoreAvaliationsCreateOrConnectWithoutStoreInput[]
    upsert?: StoreAvaliationsUpsertWithWhereUniqueWithoutStoreInput | StoreAvaliationsUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreAvaliationsCreateManyStoreInputEnvelope
    set?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
    disconnect?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
    delete?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
    connect?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
    update?: StoreAvaliationsUpdateWithWhereUniqueWithoutStoreInput | StoreAvaliationsUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreAvaliationsUpdateManyWithWhereWithoutStoreInput | StoreAvaliationsUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreAvaliationsScalarWhereInput | StoreAvaliationsScalarWhereInput[]
  }

  export type CouponsUpdateManyWithoutStoreNestedInput = {
    create?: XOR<CouponsCreateWithoutStoreInput, CouponsUncheckedCreateWithoutStoreInput> | CouponsCreateWithoutStoreInput[] | CouponsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: CouponsCreateOrConnectWithoutStoreInput | CouponsCreateOrConnectWithoutStoreInput[]
    upsert?: CouponsUpsertWithWhereUniqueWithoutStoreInput | CouponsUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: CouponsCreateManyStoreInputEnvelope
    set?: CouponsWhereUniqueInput | CouponsWhereUniqueInput[]
    disconnect?: CouponsWhereUniqueInput | CouponsWhereUniqueInput[]
    delete?: CouponsWhereUniqueInput | CouponsWhereUniqueInput[]
    connect?: CouponsWhereUniqueInput | CouponsWhereUniqueInput[]
    update?: CouponsUpdateWithWhereUniqueWithoutStoreInput | CouponsUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: CouponsUpdateManyWithWhereWithoutStoreInput | CouponsUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: CouponsScalarWhereInput | CouponsScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ChatCreateWithoutStoreInput, ChatUncheckedCreateWithoutStoreInput> | ChatCreateWithoutStoreInput[] | ChatUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutStoreInput | ChatCreateOrConnectWithoutStoreInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutStoreInput | ChatUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ChatCreateManyStoreInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutStoreInput | ChatUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutStoreInput | ChatUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type chatMessagesUpdateManyWithoutSenderStoreNestedInput = {
    create?: XOR<chatMessagesCreateWithoutSenderStoreInput, chatMessagesUncheckedCreateWithoutSenderStoreInput> | chatMessagesCreateWithoutSenderStoreInput[] | chatMessagesUncheckedCreateWithoutSenderStoreInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutSenderStoreInput | chatMessagesCreateOrConnectWithoutSenderStoreInput[]
    upsert?: chatMessagesUpsertWithWhereUniqueWithoutSenderStoreInput | chatMessagesUpsertWithWhereUniqueWithoutSenderStoreInput[]
    createMany?: chatMessagesCreateManySenderStoreInputEnvelope
    set?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    disconnect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    delete?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    update?: chatMessagesUpdateWithWhereUniqueWithoutSenderStoreInput | chatMessagesUpdateWithWhereUniqueWithoutSenderStoreInput[]
    updateMany?: chatMessagesUpdateManyWithWhereWithoutSenderStoreInput | chatMessagesUpdateManyWithWhereWithoutSenderStoreInput[]
    deleteMany?: chatMessagesScalarWhereInput | chatMessagesScalarWhereInput[]
  }

  export type chatMessagesUpdateManyWithoutReceiverStoreNestedInput = {
    create?: XOR<chatMessagesCreateWithoutReceiverStoreInput, chatMessagesUncheckedCreateWithoutReceiverStoreInput> | chatMessagesCreateWithoutReceiverStoreInput[] | chatMessagesUncheckedCreateWithoutReceiverStoreInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutReceiverStoreInput | chatMessagesCreateOrConnectWithoutReceiverStoreInput[]
    upsert?: chatMessagesUpsertWithWhereUniqueWithoutReceiverStoreInput | chatMessagesUpsertWithWhereUniqueWithoutReceiverStoreInput[]
    createMany?: chatMessagesCreateManyReceiverStoreInputEnvelope
    set?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    disconnect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    delete?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    update?: chatMessagesUpdateWithWhereUniqueWithoutReceiverStoreInput | chatMessagesUpdateWithWhereUniqueWithoutReceiverStoreInput[]
    updateMany?: chatMessagesUpdateManyWithWhereWithoutReceiverStoreInput | chatMessagesUpdateManyWithWhereWithoutReceiverStoreInput[]
    deleteMany?: chatMessagesScalarWhereInput | chatMessagesScalarWhereInput[]
  }

  export type OrderItemsUpdateManyWithoutStoreNestedInput = {
    create?: XOR<OrderItemsCreateWithoutStoreInput, OrderItemsUncheckedCreateWithoutStoreInput> | OrderItemsCreateWithoutStoreInput[] | OrderItemsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutStoreInput | OrderItemsCreateOrConnectWithoutStoreInput[]
    upsert?: OrderItemsUpsertWithWhereUniqueWithoutStoreInput | OrderItemsUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: OrderItemsCreateManyStoreInputEnvelope
    set?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    disconnect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    delete?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    update?: OrderItemsUpdateWithWhereUniqueWithoutStoreInput | OrderItemsUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: OrderItemsUpdateManyWithWhereWithoutStoreInput | OrderItemsUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
  }

  export type PromotionUpdateManyWithoutStoreNestedInput = {
    create?: XOR<PromotionCreateWithoutStoreInput, PromotionUncheckedCreateWithoutStoreInput> | PromotionCreateWithoutStoreInput[] | PromotionUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutStoreInput | PromotionCreateOrConnectWithoutStoreInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutStoreInput | PromotionUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: PromotionCreateManyStoreInputEnvelope
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutStoreInput | PromotionUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutStoreInput | PromotionUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type ProductsUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ProductsCreateWithoutStoreInput, ProductsUncheckedCreateWithoutStoreInput> | ProductsCreateWithoutStoreInput[] | ProductsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutStoreInput | ProductsCreateOrConnectWithoutStoreInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutStoreInput | ProductsUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ProductsCreateManyStoreInputEnvelope
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutStoreInput | ProductsUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutStoreInput | ProductsUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type StoreAvaliationsUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreAvaliationsCreateWithoutStoreInput, StoreAvaliationsUncheckedCreateWithoutStoreInput> | StoreAvaliationsCreateWithoutStoreInput[] | StoreAvaliationsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreAvaliationsCreateOrConnectWithoutStoreInput | StoreAvaliationsCreateOrConnectWithoutStoreInput[]
    upsert?: StoreAvaliationsUpsertWithWhereUniqueWithoutStoreInput | StoreAvaliationsUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreAvaliationsCreateManyStoreInputEnvelope
    set?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
    disconnect?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
    delete?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
    connect?: StoreAvaliationsWhereUniqueInput | StoreAvaliationsWhereUniqueInput[]
    update?: StoreAvaliationsUpdateWithWhereUniqueWithoutStoreInput | StoreAvaliationsUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreAvaliationsUpdateManyWithWhereWithoutStoreInput | StoreAvaliationsUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreAvaliationsScalarWhereInput | StoreAvaliationsScalarWhereInput[]
  }

  export type CouponsUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<CouponsCreateWithoutStoreInput, CouponsUncheckedCreateWithoutStoreInput> | CouponsCreateWithoutStoreInput[] | CouponsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: CouponsCreateOrConnectWithoutStoreInput | CouponsCreateOrConnectWithoutStoreInput[]
    upsert?: CouponsUpsertWithWhereUniqueWithoutStoreInput | CouponsUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: CouponsCreateManyStoreInputEnvelope
    set?: CouponsWhereUniqueInput | CouponsWhereUniqueInput[]
    disconnect?: CouponsWhereUniqueInput | CouponsWhereUniqueInput[]
    delete?: CouponsWhereUniqueInput | CouponsWhereUniqueInput[]
    connect?: CouponsWhereUniqueInput | CouponsWhereUniqueInput[]
    update?: CouponsUpdateWithWhereUniqueWithoutStoreInput | CouponsUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: CouponsUpdateManyWithWhereWithoutStoreInput | CouponsUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: CouponsScalarWhereInput | CouponsScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ChatCreateWithoutStoreInput, ChatUncheckedCreateWithoutStoreInput> | ChatCreateWithoutStoreInput[] | ChatUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutStoreInput | ChatCreateOrConnectWithoutStoreInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutStoreInput | ChatUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ChatCreateManyStoreInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutStoreInput | ChatUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutStoreInput | ChatUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type chatMessagesUncheckedUpdateManyWithoutSenderStoreNestedInput = {
    create?: XOR<chatMessagesCreateWithoutSenderStoreInput, chatMessagesUncheckedCreateWithoutSenderStoreInput> | chatMessagesCreateWithoutSenderStoreInput[] | chatMessagesUncheckedCreateWithoutSenderStoreInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutSenderStoreInput | chatMessagesCreateOrConnectWithoutSenderStoreInput[]
    upsert?: chatMessagesUpsertWithWhereUniqueWithoutSenderStoreInput | chatMessagesUpsertWithWhereUniqueWithoutSenderStoreInput[]
    createMany?: chatMessagesCreateManySenderStoreInputEnvelope
    set?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    disconnect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    delete?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    update?: chatMessagesUpdateWithWhereUniqueWithoutSenderStoreInput | chatMessagesUpdateWithWhereUniqueWithoutSenderStoreInput[]
    updateMany?: chatMessagesUpdateManyWithWhereWithoutSenderStoreInput | chatMessagesUpdateManyWithWhereWithoutSenderStoreInput[]
    deleteMany?: chatMessagesScalarWhereInput | chatMessagesScalarWhereInput[]
  }

  export type chatMessagesUncheckedUpdateManyWithoutReceiverStoreNestedInput = {
    create?: XOR<chatMessagesCreateWithoutReceiverStoreInput, chatMessagesUncheckedCreateWithoutReceiverStoreInput> | chatMessagesCreateWithoutReceiverStoreInput[] | chatMessagesUncheckedCreateWithoutReceiverStoreInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutReceiverStoreInput | chatMessagesCreateOrConnectWithoutReceiverStoreInput[]
    upsert?: chatMessagesUpsertWithWhereUniqueWithoutReceiverStoreInput | chatMessagesUpsertWithWhereUniqueWithoutReceiverStoreInput[]
    createMany?: chatMessagesCreateManyReceiverStoreInputEnvelope
    set?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    disconnect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    delete?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    update?: chatMessagesUpdateWithWhereUniqueWithoutReceiverStoreInput | chatMessagesUpdateWithWhereUniqueWithoutReceiverStoreInput[]
    updateMany?: chatMessagesUpdateManyWithWhereWithoutReceiverStoreInput | chatMessagesUpdateManyWithWhereWithoutReceiverStoreInput[]
    deleteMany?: chatMessagesScalarWhereInput | chatMessagesScalarWhereInput[]
  }

  export type OrderItemsUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<OrderItemsCreateWithoutStoreInput, OrderItemsUncheckedCreateWithoutStoreInput> | OrderItemsCreateWithoutStoreInput[] | OrderItemsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutStoreInput | OrderItemsCreateOrConnectWithoutStoreInput[]
    upsert?: OrderItemsUpsertWithWhereUniqueWithoutStoreInput | OrderItemsUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: OrderItemsCreateManyStoreInputEnvelope
    set?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    disconnect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    delete?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    update?: OrderItemsUpdateWithWhereUniqueWithoutStoreInput | OrderItemsUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: OrderItemsUpdateManyWithWhereWithoutStoreInput | OrderItemsUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
  }

  export type PromotionUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<PromotionCreateWithoutStoreInput, PromotionUncheckedCreateWithoutStoreInput> | PromotionCreateWithoutStoreInput[] | PromotionUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutStoreInput | PromotionCreateOrConnectWithoutStoreInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutStoreInput | PromotionUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: PromotionCreateManyStoreInputEnvelope
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutStoreInput | PromotionUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutStoreInput | PromotionUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type StoresCreateNestedOneWithoutAvatarInput = {
    create?: XOR<StoresCreateWithoutAvatarInput, StoresUncheckedCreateWithoutAvatarInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAvatarInput
    connect?: StoresWhereUniqueInput
  }

  export type StoresUncheckedCreateNestedOneWithoutAvatarInput = {
    create?: XOR<StoresCreateWithoutAvatarInput, StoresUncheckedCreateWithoutAvatarInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAvatarInput
    connect?: StoresWhereUniqueInput
  }

  export type StoresUpdateOneWithoutAvatarNestedInput = {
    create?: XOR<StoresCreateWithoutAvatarInput, StoresUncheckedCreateWithoutAvatarInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAvatarInput
    upsert?: StoresUpsertWithoutAvatarInput
    disconnect?: StoresWhereInput | boolean
    delete?: StoresWhereInput | boolean
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutAvatarInput, StoresUpdateWithoutAvatarInput>, StoresUncheckedUpdateWithoutAvatarInput>
  }

  export type StoresUncheckedUpdateOneWithoutAvatarNestedInput = {
    create?: XOR<StoresCreateWithoutAvatarInput, StoresUncheckedCreateWithoutAvatarInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAvatarInput
    upsert?: StoresUpsertWithoutAvatarInput
    disconnect?: StoresWhereInput | boolean
    delete?: StoresWhereInput | boolean
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutAvatarInput, StoresUpdateWithoutAvatarInput>, StoresUncheckedUpdateWithoutAvatarInput>
  }

  export type UserCreateNestedOneWithoutStoreAvaliationsInput = {
    create?: XOR<UserCreateWithoutStoreAvaliationsInput, UserUncheckedCreateWithoutStoreAvaliationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoreAvaliationsInput
    connect?: UserWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutAvaliationsInput = {
    create?: XOR<StoresCreateWithoutAvaliationsInput, StoresUncheckedCreateWithoutAvaliationsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAvaliationsInput
    connect?: StoresWhereUniqueInput
  }

  export type StoreAvaliationImagesCreateNestedManyWithoutStoreAvaliationInput = {
    create?: XOR<StoreAvaliationImagesCreateWithoutStoreAvaliationInput, StoreAvaliationImagesUncheckedCreateWithoutStoreAvaliationInput> | StoreAvaliationImagesCreateWithoutStoreAvaliationInput[] | StoreAvaliationImagesUncheckedCreateWithoutStoreAvaliationInput[]
    connectOrCreate?: StoreAvaliationImagesCreateOrConnectWithoutStoreAvaliationInput | StoreAvaliationImagesCreateOrConnectWithoutStoreAvaliationInput[]
    createMany?: StoreAvaliationImagesCreateManyStoreAvaliationInputEnvelope
    connect?: StoreAvaliationImagesWhereUniqueInput | StoreAvaliationImagesWhereUniqueInput[]
  }

  export type StoreAvaliationImagesUncheckedCreateNestedManyWithoutStoreAvaliationInput = {
    create?: XOR<StoreAvaliationImagesCreateWithoutStoreAvaliationInput, StoreAvaliationImagesUncheckedCreateWithoutStoreAvaliationInput> | StoreAvaliationImagesCreateWithoutStoreAvaliationInput[] | StoreAvaliationImagesUncheckedCreateWithoutStoreAvaliationInput[]
    connectOrCreate?: StoreAvaliationImagesCreateOrConnectWithoutStoreAvaliationInput | StoreAvaliationImagesCreateOrConnectWithoutStoreAvaliationInput[]
    createMany?: StoreAvaliationImagesCreateManyStoreAvaliationInputEnvelope
    connect?: StoreAvaliationImagesWhereUniqueInput | StoreAvaliationImagesWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutStoreAvaliationsNestedInput = {
    create?: XOR<UserCreateWithoutStoreAvaliationsInput, UserUncheckedCreateWithoutStoreAvaliationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoreAvaliationsInput
    upsert?: UserUpsertWithoutStoreAvaliationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStoreAvaliationsInput, UserUpdateWithoutStoreAvaliationsInput>, UserUncheckedUpdateWithoutStoreAvaliationsInput>
  }

  export type StoresUpdateOneRequiredWithoutAvaliationsNestedInput = {
    create?: XOR<StoresCreateWithoutAvaliationsInput, StoresUncheckedCreateWithoutAvaliationsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAvaliationsInput
    upsert?: StoresUpsertWithoutAvaliationsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutAvaliationsInput, StoresUpdateWithoutAvaliationsInput>, StoresUncheckedUpdateWithoutAvaliationsInput>
  }

  export type StoreAvaliationImagesUpdateManyWithoutStoreAvaliationNestedInput = {
    create?: XOR<StoreAvaliationImagesCreateWithoutStoreAvaliationInput, StoreAvaliationImagesUncheckedCreateWithoutStoreAvaliationInput> | StoreAvaliationImagesCreateWithoutStoreAvaliationInput[] | StoreAvaliationImagesUncheckedCreateWithoutStoreAvaliationInput[]
    connectOrCreate?: StoreAvaliationImagesCreateOrConnectWithoutStoreAvaliationInput | StoreAvaliationImagesCreateOrConnectWithoutStoreAvaliationInput[]
    upsert?: StoreAvaliationImagesUpsertWithWhereUniqueWithoutStoreAvaliationInput | StoreAvaliationImagesUpsertWithWhereUniqueWithoutStoreAvaliationInput[]
    createMany?: StoreAvaliationImagesCreateManyStoreAvaliationInputEnvelope
    set?: StoreAvaliationImagesWhereUniqueInput | StoreAvaliationImagesWhereUniqueInput[]
    disconnect?: StoreAvaliationImagesWhereUniqueInput | StoreAvaliationImagesWhereUniqueInput[]
    delete?: StoreAvaliationImagesWhereUniqueInput | StoreAvaliationImagesWhereUniqueInput[]
    connect?: StoreAvaliationImagesWhereUniqueInput | StoreAvaliationImagesWhereUniqueInput[]
    update?: StoreAvaliationImagesUpdateWithWhereUniqueWithoutStoreAvaliationInput | StoreAvaliationImagesUpdateWithWhereUniqueWithoutStoreAvaliationInput[]
    updateMany?: StoreAvaliationImagesUpdateManyWithWhereWithoutStoreAvaliationInput | StoreAvaliationImagesUpdateManyWithWhereWithoutStoreAvaliationInput[]
    deleteMany?: StoreAvaliationImagesScalarWhereInput | StoreAvaliationImagesScalarWhereInput[]
  }

  export type StoreAvaliationImagesUncheckedUpdateManyWithoutStoreAvaliationNestedInput = {
    create?: XOR<StoreAvaliationImagesCreateWithoutStoreAvaliationInput, StoreAvaliationImagesUncheckedCreateWithoutStoreAvaliationInput> | StoreAvaliationImagesCreateWithoutStoreAvaliationInput[] | StoreAvaliationImagesUncheckedCreateWithoutStoreAvaliationInput[]
    connectOrCreate?: StoreAvaliationImagesCreateOrConnectWithoutStoreAvaliationInput | StoreAvaliationImagesCreateOrConnectWithoutStoreAvaliationInput[]
    upsert?: StoreAvaliationImagesUpsertWithWhereUniqueWithoutStoreAvaliationInput | StoreAvaliationImagesUpsertWithWhereUniqueWithoutStoreAvaliationInput[]
    createMany?: StoreAvaliationImagesCreateManyStoreAvaliationInputEnvelope
    set?: StoreAvaliationImagesWhereUniqueInput | StoreAvaliationImagesWhereUniqueInput[]
    disconnect?: StoreAvaliationImagesWhereUniqueInput | StoreAvaliationImagesWhereUniqueInput[]
    delete?: StoreAvaliationImagesWhereUniqueInput | StoreAvaliationImagesWhereUniqueInput[]
    connect?: StoreAvaliationImagesWhereUniqueInput | StoreAvaliationImagesWhereUniqueInput[]
    update?: StoreAvaliationImagesUpdateWithWhereUniqueWithoutStoreAvaliationInput | StoreAvaliationImagesUpdateWithWhereUniqueWithoutStoreAvaliationInput[]
    updateMany?: StoreAvaliationImagesUpdateManyWithWhereWithoutStoreAvaliationInput | StoreAvaliationImagesUpdateManyWithWhereWithoutStoreAvaliationInput[]
    deleteMany?: StoreAvaliationImagesScalarWhereInput | StoreAvaliationImagesScalarWhereInput[]
  }

  export type StoreAvaliationsCreateNestedOneWithoutImagesInput = {
    create?: XOR<StoreAvaliationsCreateWithoutImagesInput, StoreAvaliationsUncheckedCreateWithoutImagesInput>
    connectOrCreate?: StoreAvaliationsCreateOrConnectWithoutImagesInput
    connect?: StoreAvaliationsWhereUniqueInput
  }

  export type StoreAvaliationsUpdateOneWithoutImagesNestedInput = {
    create?: XOR<StoreAvaliationsCreateWithoutImagesInput, StoreAvaliationsUncheckedCreateWithoutImagesInput>
    connectOrCreate?: StoreAvaliationsCreateOrConnectWithoutImagesInput
    upsert?: StoreAvaliationsUpsertWithoutImagesInput
    disconnect?: StoreAvaliationsWhereInput | boolean
    delete?: StoreAvaliationsWhereInput | boolean
    connect?: StoreAvaliationsWhereUniqueInput
    update?: XOR<XOR<StoreAvaliationsUpdateToOneWithWhereWithoutImagesInput, StoreAvaliationsUpdateWithoutImagesInput>, StoreAvaliationsUncheckedUpdateWithoutImagesInput>
  }

  export type StoresCreateNestedOneWithoutCouponsInput = {
    create?: XOR<StoresCreateWithoutCouponsInput, StoresUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutCouponsInput
    connect?: StoresWhereUniqueInput
  }

  export type UserUsedCouponsCreateNestedManyWithoutCouponInput = {
    create?: XOR<UserUsedCouponsCreateWithoutCouponInput, UserUsedCouponsUncheckedCreateWithoutCouponInput> | UserUsedCouponsCreateWithoutCouponInput[] | UserUsedCouponsUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: UserUsedCouponsCreateOrConnectWithoutCouponInput | UserUsedCouponsCreateOrConnectWithoutCouponInput[]
    createMany?: UserUsedCouponsCreateManyCouponInputEnvelope
    connect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
  }

  export type UserUsedCouponsUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<UserUsedCouponsCreateWithoutCouponInput, UserUsedCouponsUncheckedCreateWithoutCouponInput> | UserUsedCouponsCreateWithoutCouponInput[] | UserUsedCouponsUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: UserUsedCouponsCreateOrConnectWithoutCouponInput | UserUsedCouponsCreateOrConnectWithoutCouponInput[]
    createMany?: UserUsedCouponsCreateManyCouponInputEnvelope
    connect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type StoresUpdateOneRequiredWithoutCouponsNestedInput = {
    create?: XOR<StoresCreateWithoutCouponsInput, StoresUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutCouponsInput
    upsert?: StoresUpsertWithoutCouponsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutCouponsInput, StoresUpdateWithoutCouponsInput>, StoresUncheckedUpdateWithoutCouponsInput>
  }

  export type UserUsedCouponsUpdateManyWithoutCouponNestedInput = {
    create?: XOR<UserUsedCouponsCreateWithoutCouponInput, UserUsedCouponsUncheckedCreateWithoutCouponInput> | UserUsedCouponsCreateWithoutCouponInput[] | UserUsedCouponsUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: UserUsedCouponsCreateOrConnectWithoutCouponInput | UserUsedCouponsCreateOrConnectWithoutCouponInput[]
    upsert?: UserUsedCouponsUpsertWithWhereUniqueWithoutCouponInput | UserUsedCouponsUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: UserUsedCouponsCreateManyCouponInputEnvelope
    set?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    disconnect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    delete?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    connect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    update?: UserUsedCouponsUpdateWithWhereUniqueWithoutCouponInput | UserUsedCouponsUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: UserUsedCouponsUpdateManyWithWhereWithoutCouponInput | UserUsedCouponsUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: UserUsedCouponsScalarWhereInput | UserUsedCouponsScalarWhereInput[]
  }

  export type UserUsedCouponsUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<UserUsedCouponsCreateWithoutCouponInput, UserUsedCouponsUncheckedCreateWithoutCouponInput> | UserUsedCouponsCreateWithoutCouponInput[] | UserUsedCouponsUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: UserUsedCouponsCreateOrConnectWithoutCouponInput | UserUsedCouponsCreateOrConnectWithoutCouponInput[]
    upsert?: UserUsedCouponsUpsertWithWhereUniqueWithoutCouponInput | UserUsedCouponsUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: UserUsedCouponsCreateManyCouponInputEnvelope
    set?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    disconnect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    delete?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    connect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    update?: UserUsedCouponsUpdateWithWhereUniqueWithoutCouponInput | UserUsedCouponsUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: UserUsedCouponsUpdateManyWithWhereWithoutCouponInput | UserUsedCouponsUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: UserUsedCouponsScalarWhereInput | UserUsedCouponsScalarWhereInput[]
  }

  export type StoresCreateNestedOneWithoutProductInput = {
    create?: XOR<StoresCreateWithoutProductInput, StoresUncheckedCreateWithoutProductInput>
    connectOrCreate?: StoresCreateOrConnectWithoutProductInput
    connect?: StoresWhereUniqueInput
  }

  export type InventoryCreateNestedOneWithoutProductInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput
    connect?: InventoryWhereUniqueInput
  }

  export type ProductImagesCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductImagesCreateWithoutProductInput, ProductImagesUncheckedCreateWithoutProductInput> | ProductImagesCreateWithoutProductInput[] | ProductImagesUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImagesCreateOrConnectWithoutProductInput | ProductImagesCreateOrConnectWithoutProductInput[]
    createMany?: ProductImagesCreateManyProductInputEnvelope
    connect?: ProductImagesWhereUniqueInput | ProductImagesWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutProductInput = {
    create?: XOR<CategoryCreateWithoutProductInput, CategoryUncheckedCreateWithoutProductInput> | CategoryCreateWithoutProductInput[] | CategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProductInput | CategoryCreateOrConnectWithoutProductInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductAvaliationsCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductAvaliationsCreateWithoutProductInput, ProductAvaliationsUncheckedCreateWithoutProductInput> | ProductAvaliationsCreateWithoutProductInput[] | ProductAvaliationsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductAvaliationsCreateOrConnectWithoutProductInput | ProductAvaliationsCreateOrConnectWithoutProductInput[]
    createMany?: ProductAvaliationsCreateManyProductInputEnvelope
    connect?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
  }

  export type PromotionCreateNestedManyWithoutProductsInput = {
    create?: XOR<PromotionCreateWithoutProductsInput, PromotionUncheckedCreateWithoutProductsInput> | PromotionCreateWithoutProductsInput[] | PromotionUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutProductsInput | PromotionCreateOrConnectWithoutProductsInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type CartItemsCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemsCreateWithoutProductInput, CartItemsUncheckedCreateWithoutProductInput> | CartItemsCreateWithoutProductInput[] | CartItemsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemsCreateOrConnectWithoutProductInput | CartItemsCreateOrConnectWithoutProductInput[]
    createMany?: CartItemsCreateManyProductInputEnvelope
    connect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
  }

  export type OrderItemsCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemsCreateWithoutProductInput, OrderItemsUncheckedCreateWithoutProductInput> | OrderItemsCreateWithoutProductInput[] | OrderItemsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutProductInput | OrderItemsCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemsCreateManyProductInputEnvelope
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
  }

  export type WishlistCreateNestedManyWithoutProductsInput = {
    create?: XOR<WishlistCreateWithoutProductsInput, WishlistUncheckedCreateWithoutProductsInput> | WishlistCreateWithoutProductsInput[] | WishlistUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutProductsInput | WishlistCreateOrConnectWithoutProductsInput[]
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput
    connect?: InventoryWhereUniqueInput
  }

  export type ProductImagesUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductImagesCreateWithoutProductInput, ProductImagesUncheckedCreateWithoutProductInput> | ProductImagesCreateWithoutProductInput[] | ProductImagesUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImagesCreateOrConnectWithoutProductInput | ProductImagesCreateOrConnectWithoutProductInput[]
    createMany?: ProductImagesCreateManyProductInputEnvelope
    connect?: ProductImagesWhereUniqueInput | ProductImagesWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CategoryCreateWithoutProductInput, CategoryUncheckedCreateWithoutProductInput> | CategoryCreateWithoutProductInput[] | CategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProductInput | CategoryCreateOrConnectWithoutProductInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductAvaliationsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductAvaliationsCreateWithoutProductInput, ProductAvaliationsUncheckedCreateWithoutProductInput> | ProductAvaliationsCreateWithoutProductInput[] | ProductAvaliationsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductAvaliationsCreateOrConnectWithoutProductInput | ProductAvaliationsCreateOrConnectWithoutProductInput[]
    createMany?: ProductAvaliationsCreateManyProductInputEnvelope
    connect?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
  }

  export type PromotionUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<PromotionCreateWithoutProductsInput, PromotionUncheckedCreateWithoutProductsInput> | PromotionCreateWithoutProductsInput[] | PromotionUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutProductsInput | PromotionCreateOrConnectWithoutProductsInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type CartItemsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemsCreateWithoutProductInput, CartItemsUncheckedCreateWithoutProductInput> | CartItemsCreateWithoutProductInput[] | CartItemsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemsCreateOrConnectWithoutProductInput | CartItemsCreateOrConnectWithoutProductInput[]
    createMany?: CartItemsCreateManyProductInputEnvelope
    connect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
  }

  export type OrderItemsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemsCreateWithoutProductInput, OrderItemsUncheckedCreateWithoutProductInput> | OrderItemsCreateWithoutProductInput[] | OrderItemsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutProductInput | OrderItemsCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemsCreateManyProductInputEnvelope
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
  }

  export type WishlistUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<WishlistCreateWithoutProductsInput, WishlistUncheckedCreateWithoutProductsInput> | WishlistCreateWithoutProductsInput[] | WishlistUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutProductsInput | WishlistCreateOrConnectWithoutProductsInput[]
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
  }

  export type StoresUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<StoresCreateWithoutProductInput, StoresUncheckedCreateWithoutProductInput>
    connectOrCreate?: StoresCreateOrConnectWithoutProductInput
    upsert?: StoresUpsertWithoutProductInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutProductInput, StoresUpdateWithoutProductInput>, StoresUncheckedUpdateWithoutProductInput>
  }

  export type InventoryUpdateOneWithoutProductNestedInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput
    upsert?: InventoryUpsertWithoutProductInput
    disconnect?: InventoryWhereInput | boolean
    delete?: InventoryWhereInput | boolean
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutProductInput, InventoryUpdateWithoutProductInput>, InventoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductImagesUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductImagesCreateWithoutProductInput, ProductImagesUncheckedCreateWithoutProductInput> | ProductImagesCreateWithoutProductInput[] | ProductImagesUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImagesCreateOrConnectWithoutProductInput | ProductImagesCreateOrConnectWithoutProductInput[]
    upsert?: ProductImagesUpsertWithWhereUniqueWithoutProductInput | ProductImagesUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductImagesCreateManyProductInputEnvelope
    set?: ProductImagesWhereUniqueInput | ProductImagesWhereUniqueInput[]
    disconnect?: ProductImagesWhereUniqueInput | ProductImagesWhereUniqueInput[]
    delete?: ProductImagesWhereUniqueInput | ProductImagesWhereUniqueInput[]
    connect?: ProductImagesWhereUniqueInput | ProductImagesWhereUniqueInput[]
    update?: ProductImagesUpdateWithWhereUniqueWithoutProductInput | ProductImagesUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImagesUpdateManyWithWhereWithoutProductInput | ProductImagesUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImagesScalarWhereInput | ProductImagesScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<CategoryCreateWithoutProductInput, CategoryUncheckedCreateWithoutProductInput> | CategoryCreateWithoutProductInput[] | CategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProductInput | CategoryCreateOrConnectWithoutProductInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutProductInput | CategoryUpsertWithWhereUniqueWithoutProductInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutProductInput | CategoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutProductInput | CategoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductAvaliationsUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductAvaliationsCreateWithoutProductInput, ProductAvaliationsUncheckedCreateWithoutProductInput> | ProductAvaliationsCreateWithoutProductInput[] | ProductAvaliationsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductAvaliationsCreateOrConnectWithoutProductInput | ProductAvaliationsCreateOrConnectWithoutProductInput[]
    upsert?: ProductAvaliationsUpsertWithWhereUniqueWithoutProductInput | ProductAvaliationsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductAvaliationsCreateManyProductInputEnvelope
    set?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
    disconnect?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
    delete?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
    connect?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
    update?: ProductAvaliationsUpdateWithWhereUniqueWithoutProductInput | ProductAvaliationsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductAvaliationsUpdateManyWithWhereWithoutProductInput | ProductAvaliationsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductAvaliationsScalarWhereInput | ProductAvaliationsScalarWhereInput[]
  }

  export type PromotionUpdateManyWithoutProductsNestedInput = {
    create?: XOR<PromotionCreateWithoutProductsInput, PromotionUncheckedCreateWithoutProductsInput> | PromotionCreateWithoutProductsInput[] | PromotionUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutProductsInput | PromotionCreateOrConnectWithoutProductsInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutProductsInput | PromotionUpsertWithWhereUniqueWithoutProductsInput[]
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutProductsInput | PromotionUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutProductsInput | PromotionUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type CartItemsUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemsCreateWithoutProductInput, CartItemsUncheckedCreateWithoutProductInput> | CartItemsCreateWithoutProductInput[] | CartItemsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemsCreateOrConnectWithoutProductInput | CartItemsCreateOrConnectWithoutProductInput[]
    upsert?: CartItemsUpsertWithWhereUniqueWithoutProductInput | CartItemsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemsCreateManyProductInputEnvelope
    set?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    disconnect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    delete?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    connect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    update?: CartItemsUpdateWithWhereUniqueWithoutProductInput | CartItemsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemsUpdateManyWithWhereWithoutProductInput | CartItemsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemsScalarWhereInput | CartItemsScalarWhereInput[]
  }

  export type OrderItemsUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemsCreateWithoutProductInput, OrderItemsUncheckedCreateWithoutProductInput> | OrderItemsCreateWithoutProductInput[] | OrderItemsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutProductInput | OrderItemsCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemsUpsertWithWhereUniqueWithoutProductInput | OrderItemsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemsCreateManyProductInputEnvelope
    set?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    disconnect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    delete?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    update?: OrderItemsUpdateWithWhereUniqueWithoutProductInput | OrderItemsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemsUpdateManyWithWhereWithoutProductInput | OrderItemsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
  }

  export type WishlistUpdateManyWithoutProductsNestedInput = {
    create?: XOR<WishlistCreateWithoutProductsInput, WishlistUncheckedCreateWithoutProductsInput> | WishlistCreateWithoutProductsInput[] | WishlistUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutProductsInput | WishlistCreateOrConnectWithoutProductsInput[]
    upsert?: WishlistUpsertWithWhereUniqueWithoutProductsInput | WishlistUpsertWithWhereUniqueWithoutProductsInput[]
    set?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    disconnect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    delete?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    update?: WishlistUpdateWithWhereUniqueWithoutProductsInput | WishlistUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: WishlistUpdateManyWithWhereWithoutProductsInput | WishlistUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput
    upsert?: InventoryUpsertWithoutProductInput
    disconnect?: InventoryWhereInput | boolean
    delete?: InventoryWhereInput | boolean
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutProductInput, InventoryUpdateWithoutProductInput>, InventoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductImagesUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductImagesCreateWithoutProductInput, ProductImagesUncheckedCreateWithoutProductInput> | ProductImagesCreateWithoutProductInput[] | ProductImagesUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImagesCreateOrConnectWithoutProductInput | ProductImagesCreateOrConnectWithoutProductInput[]
    upsert?: ProductImagesUpsertWithWhereUniqueWithoutProductInput | ProductImagesUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductImagesCreateManyProductInputEnvelope
    set?: ProductImagesWhereUniqueInput | ProductImagesWhereUniqueInput[]
    disconnect?: ProductImagesWhereUniqueInput | ProductImagesWhereUniqueInput[]
    delete?: ProductImagesWhereUniqueInput | ProductImagesWhereUniqueInput[]
    connect?: ProductImagesWhereUniqueInput | ProductImagesWhereUniqueInput[]
    update?: ProductImagesUpdateWithWhereUniqueWithoutProductInput | ProductImagesUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImagesUpdateManyWithWhereWithoutProductInput | ProductImagesUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImagesScalarWhereInput | ProductImagesScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CategoryCreateWithoutProductInput, CategoryUncheckedCreateWithoutProductInput> | CategoryCreateWithoutProductInput[] | CategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProductInput | CategoryCreateOrConnectWithoutProductInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutProductInput | CategoryUpsertWithWhereUniqueWithoutProductInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutProductInput | CategoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutProductInput | CategoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductAvaliationsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductAvaliationsCreateWithoutProductInput, ProductAvaliationsUncheckedCreateWithoutProductInput> | ProductAvaliationsCreateWithoutProductInput[] | ProductAvaliationsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductAvaliationsCreateOrConnectWithoutProductInput | ProductAvaliationsCreateOrConnectWithoutProductInput[]
    upsert?: ProductAvaliationsUpsertWithWhereUniqueWithoutProductInput | ProductAvaliationsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductAvaliationsCreateManyProductInputEnvelope
    set?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
    disconnect?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
    delete?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
    connect?: ProductAvaliationsWhereUniqueInput | ProductAvaliationsWhereUniqueInput[]
    update?: ProductAvaliationsUpdateWithWhereUniqueWithoutProductInput | ProductAvaliationsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductAvaliationsUpdateManyWithWhereWithoutProductInput | ProductAvaliationsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductAvaliationsScalarWhereInput | ProductAvaliationsScalarWhereInput[]
  }

  export type PromotionUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<PromotionCreateWithoutProductsInput, PromotionUncheckedCreateWithoutProductsInput> | PromotionCreateWithoutProductsInput[] | PromotionUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutProductsInput | PromotionCreateOrConnectWithoutProductsInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutProductsInput | PromotionUpsertWithWhereUniqueWithoutProductsInput[]
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutProductsInput | PromotionUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutProductsInput | PromotionUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type CartItemsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemsCreateWithoutProductInput, CartItemsUncheckedCreateWithoutProductInput> | CartItemsCreateWithoutProductInput[] | CartItemsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemsCreateOrConnectWithoutProductInput | CartItemsCreateOrConnectWithoutProductInput[]
    upsert?: CartItemsUpsertWithWhereUniqueWithoutProductInput | CartItemsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemsCreateManyProductInputEnvelope
    set?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    disconnect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    delete?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    connect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    update?: CartItemsUpdateWithWhereUniqueWithoutProductInput | CartItemsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemsUpdateManyWithWhereWithoutProductInput | CartItemsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemsScalarWhereInput | CartItemsScalarWhereInput[]
  }

  export type OrderItemsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemsCreateWithoutProductInput, OrderItemsUncheckedCreateWithoutProductInput> | OrderItemsCreateWithoutProductInput[] | OrderItemsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutProductInput | OrderItemsCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemsUpsertWithWhereUniqueWithoutProductInput | OrderItemsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemsCreateManyProductInputEnvelope
    set?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    disconnect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    delete?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    update?: OrderItemsUpdateWithWhereUniqueWithoutProductInput | OrderItemsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemsUpdateManyWithWhereWithoutProductInput | OrderItemsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
  }

  export type WishlistUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<WishlistCreateWithoutProductsInput, WishlistUncheckedCreateWithoutProductsInput> | WishlistCreateWithoutProductsInput[] | WishlistUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: WishlistCreateOrConnectWithoutProductsInput | WishlistCreateOrConnectWithoutProductsInput[]
    upsert?: WishlistUpsertWithWhereUniqueWithoutProductsInput | WishlistUpsertWithWhereUniqueWithoutProductsInput[]
    set?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    disconnect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    delete?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    connect?: WishlistWhereUniqueInput | WishlistWhereUniqueInput[]
    update?: WishlistUpdateWithWhereUniqueWithoutProductsInput | WishlistUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: WishlistUpdateManyWithWhereWithoutProductsInput | WishlistUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
  }

  export type ProductsCreateNestedOneWithoutImagesInput = {
    create?: XOR<ProductsCreateWithoutImagesInput, ProductsUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutImagesInput
    connect?: ProductsWhereUniqueInput
  }

  export type ProductsUpdateOneWithoutImagesNestedInput = {
    create?: XOR<ProductsCreateWithoutImagesInput, ProductsUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutImagesInput
    upsert?: ProductsUpsertWithoutImagesInput
    disconnect?: ProductsWhereInput | boolean
    delete?: ProductsWhereInput | boolean
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutImagesInput, ProductsUpdateWithoutImagesInput>, ProductsUncheckedUpdateWithoutImagesInput>
  }

  export type UserCreateNestedOneWithoutWishlistInput = {
    create?: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishlistInput
    connect?: UserWhereUniqueInput
  }

  export type ProductsCreateNestedManyWithoutWishlistsInput = {
    create?: XOR<ProductsCreateWithoutWishlistsInput, ProductsUncheckedCreateWithoutWishlistsInput> | ProductsCreateWithoutWishlistsInput[] | ProductsUncheckedCreateWithoutWishlistsInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutWishlistsInput | ProductsCreateOrConnectWithoutWishlistsInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type ProductsUncheckedCreateNestedManyWithoutWishlistsInput = {
    create?: XOR<ProductsCreateWithoutWishlistsInput, ProductsUncheckedCreateWithoutWishlistsInput> | ProductsCreateWithoutWishlistsInput[] | ProductsUncheckedCreateWithoutWishlistsInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutWishlistsInput | ProductsCreateOrConnectWithoutWishlistsInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutWishlistNestedInput = {
    create?: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishlistInput
    upsert?: UserUpsertWithoutWishlistInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWishlistInput, UserUpdateWithoutWishlistInput>, UserUncheckedUpdateWithoutWishlistInput>
  }

  export type ProductsUpdateManyWithoutWishlistsNestedInput = {
    create?: XOR<ProductsCreateWithoutWishlistsInput, ProductsUncheckedCreateWithoutWishlistsInput> | ProductsCreateWithoutWishlistsInput[] | ProductsUncheckedCreateWithoutWishlistsInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutWishlistsInput | ProductsCreateOrConnectWithoutWishlistsInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutWishlistsInput | ProductsUpsertWithWhereUniqueWithoutWishlistsInput[]
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutWishlistsInput | ProductsUpdateWithWhereUniqueWithoutWishlistsInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutWishlistsInput | ProductsUpdateManyWithWhereWithoutWishlistsInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type ProductsUncheckedUpdateManyWithoutWishlistsNestedInput = {
    create?: XOR<ProductsCreateWithoutWishlistsInput, ProductsUncheckedCreateWithoutWishlistsInput> | ProductsCreateWithoutWishlistsInput[] | ProductsUncheckedCreateWithoutWishlistsInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutWishlistsInput | ProductsCreateOrConnectWithoutWishlistsInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutWishlistsInput | ProductsUpsertWithWhereUniqueWithoutWishlistsInput[]
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutWishlistsInput | ProductsUpdateWithWhereUniqueWithoutWishlistsInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutWishlistsInput | ProductsUpdateManyWithWhereWithoutWishlistsInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type ProductsCreateNestedOneWithoutInventoryInput = {
    create?: XOR<ProductsCreateWithoutInventoryInput, ProductsUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutInventoryInput
    connect?: ProductsWhereUniqueInput
  }

  export type ProductsUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<ProductsCreateWithoutInventoryInput, ProductsUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutInventoryInput
    upsert?: ProductsUpsertWithoutInventoryInput
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutInventoryInput, ProductsUpdateWithoutInventoryInput>, ProductsUncheckedUpdateWithoutInventoryInput>
  }

  export type StoresCreateNestedOneWithoutPromotionsInput = {
    create?: XOR<StoresCreateWithoutPromotionsInput, StoresUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutPromotionsInput
    connect?: StoresWhereUniqueInput
  }

  export type ProductsCreateNestedManyWithoutPromotionsInput = {
    create?: XOR<ProductsCreateWithoutPromotionsInput, ProductsUncheckedCreateWithoutPromotionsInput> | ProductsCreateWithoutPromotionsInput[] | ProductsUncheckedCreateWithoutPromotionsInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutPromotionsInput | ProductsCreateOrConnectWithoutPromotionsInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type ProductsUncheckedCreateNestedManyWithoutPromotionsInput = {
    create?: XOR<ProductsCreateWithoutPromotionsInput, ProductsUncheckedCreateWithoutPromotionsInput> | ProductsCreateWithoutPromotionsInput[] | ProductsUncheckedCreateWithoutPromotionsInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutPromotionsInput | ProductsCreateOrConnectWithoutPromotionsInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type StoresUpdateOneRequiredWithoutPromotionsNestedInput = {
    create?: XOR<StoresCreateWithoutPromotionsInput, StoresUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutPromotionsInput
    upsert?: StoresUpsertWithoutPromotionsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutPromotionsInput, StoresUpdateWithoutPromotionsInput>, StoresUncheckedUpdateWithoutPromotionsInput>
  }

  export type ProductsUpdateManyWithoutPromotionsNestedInput = {
    create?: XOR<ProductsCreateWithoutPromotionsInput, ProductsUncheckedCreateWithoutPromotionsInput> | ProductsCreateWithoutPromotionsInput[] | ProductsUncheckedCreateWithoutPromotionsInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutPromotionsInput | ProductsCreateOrConnectWithoutPromotionsInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutPromotionsInput | ProductsUpsertWithWhereUniqueWithoutPromotionsInput[]
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutPromotionsInput | ProductsUpdateWithWhereUniqueWithoutPromotionsInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutPromotionsInput | ProductsUpdateManyWithWhereWithoutPromotionsInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type ProductsUncheckedUpdateManyWithoutPromotionsNestedInput = {
    create?: XOR<ProductsCreateWithoutPromotionsInput, ProductsUncheckedCreateWithoutPromotionsInput> | ProductsCreateWithoutPromotionsInput[] | ProductsUncheckedCreateWithoutPromotionsInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutPromotionsInput | ProductsCreateOrConnectWithoutPromotionsInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutPromotionsInput | ProductsUpsertWithWhereUniqueWithoutPromotionsInput[]
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutPromotionsInput | ProductsUpdateWithWhereUniqueWithoutPromotionsInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutPromotionsInput | ProductsUpdateManyWithWhereWithoutPromotionsInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type ProductsCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductsCreateWithoutCategoryInput, ProductsUncheckedCreateWithoutCategoryInput> | ProductsCreateWithoutCategoryInput[] | ProductsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutCategoryInput | ProductsCreateOrConnectWithoutCategoryInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type ProductsUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductsCreateWithoutCategoryInput, ProductsUncheckedCreateWithoutCategoryInput> | ProductsCreateWithoutCategoryInput[] | ProductsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutCategoryInput | ProductsCreateOrConnectWithoutCategoryInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type ProductsUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductsCreateWithoutCategoryInput, ProductsUncheckedCreateWithoutCategoryInput> | ProductsCreateWithoutCategoryInput[] | ProductsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutCategoryInput | ProductsCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutCategoryInput | ProductsUpsertWithWhereUniqueWithoutCategoryInput[]
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutCategoryInput | ProductsUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutCategoryInput | ProductsUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type ProductsUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductsCreateWithoutCategoryInput, ProductsUncheckedCreateWithoutCategoryInput> | ProductsCreateWithoutCategoryInput[] | ProductsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutCategoryInput | ProductsCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutCategoryInput | ProductsUpsertWithWhereUniqueWithoutCategoryInput[]
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutCategoryInput | ProductsUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutCategoryInput | ProductsUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProductAvaliationsInput = {
    create?: XOR<UserCreateWithoutProductAvaliationsInput, UserUncheckedCreateWithoutProductAvaliationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductAvaliationsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutAvaliationsInput = {
    create?: XOR<ProductsCreateWithoutAvaliationsInput, ProductsUncheckedCreateWithoutAvaliationsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutAvaliationsInput
    connect?: ProductsWhereUniqueInput
  }

  export type ProductAvaliationImagesCreateNestedManyWithoutProductAvaliationInput = {
    create?: XOR<ProductAvaliationImagesCreateWithoutProductAvaliationInput, ProductAvaliationImagesUncheckedCreateWithoutProductAvaliationInput> | ProductAvaliationImagesCreateWithoutProductAvaliationInput[] | ProductAvaliationImagesUncheckedCreateWithoutProductAvaliationInput[]
    connectOrCreate?: ProductAvaliationImagesCreateOrConnectWithoutProductAvaliationInput | ProductAvaliationImagesCreateOrConnectWithoutProductAvaliationInput[]
    createMany?: ProductAvaliationImagesCreateManyProductAvaliationInputEnvelope
    connect?: ProductAvaliationImagesWhereUniqueInput | ProductAvaliationImagesWhereUniqueInput[]
  }

  export type ProductAvaliationImagesUncheckedCreateNestedManyWithoutProductAvaliationInput = {
    create?: XOR<ProductAvaliationImagesCreateWithoutProductAvaliationInput, ProductAvaliationImagesUncheckedCreateWithoutProductAvaliationInput> | ProductAvaliationImagesCreateWithoutProductAvaliationInput[] | ProductAvaliationImagesUncheckedCreateWithoutProductAvaliationInput[]
    connectOrCreate?: ProductAvaliationImagesCreateOrConnectWithoutProductAvaliationInput | ProductAvaliationImagesCreateOrConnectWithoutProductAvaliationInput[]
    createMany?: ProductAvaliationImagesCreateManyProductAvaliationInputEnvelope
    connect?: ProductAvaliationImagesWhereUniqueInput | ProductAvaliationImagesWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutProductAvaliationsNestedInput = {
    create?: XOR<UserCreateWithoutProductAvaliationsInput, UserUncheckedCreateWithoutProductAvaliationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductAvaliationsInput
    upsert?: UserUpsertWithoutProductAvaliationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductAvaliationsInput, UserUpdateWithoutProductAvaliationsInput>, UserUncheckedUpdateWithoutProductAvaliationsInput>
  }

  export type ProductsUpdateOneRequiredWithoutAvaliationsNestedInput = {
    create?: XOR<ProductsCreateWithoutAvaliationsInput, ProductsUncheckedCreateWithoutAvaliationsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutAvaliationsInput
    upsert?: ProductsUpsertWithoutAvaliationsInput
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutAvaliationsInput, ProductsUpdateWithoutAvaliationsInput>, ProductsUncheckedUpdateWithoutAvaliationsInput>
  }

  export type ProductAvaliationImagesUpdateManyWithoutProductAvaliationNestedInput = {
    create?: XOR<ProductAvaliationImagesCreateWithoutProductAvaliationInput, ProductAvaliationImagesUncheckedCreateWithoutProductAvaliationInput> | ProductAvaliationImagesCreateWithoutProductAvaliationInput[] | ProductAvaliationImagesUncheckedCreateWithoutProductAvaliationInput[]
    connectOrCreate?: ProductAvaliationImagesCreateOrConnectWithoutProductAvaliationInput | ProductAvaliationImagesCreateOrConnectWithoutProductAvaliationInput[]
    upsert?: ProductAvaliationImagesUpsertWithWhereUniqueWithoutProductAvaliationInput | ProductAvaliationImagesUpsertWithWhereUniqueWithoutProductAvaliationInput[]
    createMany?: ProductAvaliationImagesCreateManyProductAvaliationInputEnvelope
    set?: ProductAvaliationImagesWhereUniqueInput | ProductAvaliationImagesWhereUniqueInput[]
    disconnect?: ProductAvaliationImagesWhereUniqueInput | ProductAvaliationImagesWhereUniqueInput[]
    delete?: ProductAvaliationImagesWhereUniqueInput | ProductAvaliationImagesWhereUniqueInput[]
    connect?: ProductAvaliationImagesWhereUniqueInput | ProductAvaliationImagesWhereUniqueInput[]
    update?: ProductAvaliationImagesUpdateWithWhereUniqueWithoutProductAvaliationInput | ProductAvaliationImagesUpdateWithWhereUniqueWithoutProductAvaliationInput[]
    updateMany?: ProductAvaliationImagesUpdateManyWithWhereWithoutProductAvaliationInput | ProductAvaliationImagesUpdateManyWithWhereWithoutProductAvaliationInput[]
    deleteMany?: ProductAvaliationImagesScalarWhereInput | ProductAvaliationImagesScalarWhereInput[]
  }

  export type ProductAvaliationImagesUncheckedUpdateManyWithoutProductAvaliationNestedInput = {
    create?: XOR<ProductAvaliationImagesCreateWithoutProductAvaliationInput, ProductAvaliationImagesUncheckedCreateWithoutProductAvaliationInput> | ProductAvaliationImagesCreateWithoutProductAvaliationInput[] | ProductAvaliationImagesUncheckedCreateWithoutProductAvaliationInput[]
    connectOrCreate?: ProductAvaliationImagesCreateOrConnectWithoutProductAvaliationInput | ProductAvaliationImagesCreateOrConnectWithoutProductAvaliationInput[]
    upsert?: ProductAvaliationImagesUpsertWithWhereUniqueWithoutProductAvaliationInput | ProductAvaliationImagesUpsertWithWhereUniqueWithoutProductAvaliationInput[]
    createMany?: ProductAvaliationImagesCreateManyProductAvaliationInputEnvelope
    set?: ProductAvaliationImagesWhereUniqueInput | ProductAvaliationImagesWhereUniqueInput[]
    disconnect?: ProductAvaliationImagesWhereUniqueInput | ProductAvaliationImagesWhereUniqueInput[]
    delete?: ProductAvaliationImagesWhereUniqueInput | ProductAvaliationImagesWhereUniqueInput[]
    connect?: ProductAvaliationImagesWhereUniqueInput | ProductAvaliationImagesWhereUniqueInput[]
    update?: ProductAvaliationImagesUpdateWithWhereUniqueWithoutProductAvaliationInput | ProductAvaliationImagesUpdateWithWhereUniqueWithoutProductAvaliationInput[]
    updateMany?: ProductAvaliationImagesUpdateManyWithWhereWithoutProductAvaliationInput | ProductAvaliationImagesUpdateManyWithWhereWithoutProductAvaliationInput[]
    deleteMany?: ProductAvaliationImagesScalarWhereInput | ProductAvaliationImagesScalarWhereInput[]
  }

  export type ProductAvaliationsCreateNestedOneWithoutImagesInput = {
    create?: XOR<ProductAvaliationsCreateWithoutImagesInput, ProductAvaliationsUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProductAvaliationsCreateOrConnectWithoutImagesInput
    connect?: ProductAvaliationsWhereUniqueInput
  }

  export type ProductAvaliationsUpdateOneWithoutImagesNestedInput = {
    create?: XOR<ProductAvaliationsCreateWithoutImagesInput, ProductAvaliationsUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProductAvaliationsCreateOrConnectWithoutImagesInput
    upsert?: ProductAvaliationsUpsertWithoutImagesInput
    disconnect?: ProductAvaliationsWhereInput | boolean
    delete?: ProductAvaliationsWhereInput | boolean
    connect?: ProductAvaliationsWhereUniqueInput
    update?: XOR<XOR<ProductAvaliationsUpdateToOneWithWhereWithoutImagesInput, ProductAvaliationsUpdateWithoutImagesInput>, ProductAvaliationsUncheckedUpdateWithoutImagesInput>
  }

  export type UserCreateNestedOneWithoutCartInput = {
    create?: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartInput
    connect?: UserWhereUniqueInput
  }

  export type CartItemsCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemsCreateWithoutCartInput, CartItemsUncheckedCreateWithoutCartInput> | CartItemsCreateWithoutCartInput[] | CartItemsUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemsCreateOrConnectWithoutCartInput | CartItemsCreateOrConnectWithoutCartInput[]
    createMany?: CartItemsCreateManyCartInputEnvelope
    connect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedOneWithoutCartInput = {
    create?: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartInput
    connect?: UserWhereUniqueInput
  }

  export type CartItemsUncheckedCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemsCreateWithoutCartInput, CartItemsUncheckedCreateWithoutCartInput> | CartItemsCreateWithoutCartInput[] | CartItemsUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemsCreateOrConnectWithoutCartInput | CartItemsCreateOrConnectWithoutCartInput[]
    createMany?: CartItemsCreateManyCartInputEnvelope
    connect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCartNestedInput = {
    create?: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartInput
    upsert?: UserUpsertWithoutCartInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCartInput, UserUpdateWithoutCartInput>, UserUncheckedUpdateWithoutCartInput>
  }

  export type CartItemsUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemsCreateWithoutCartInput, CartItemsUncheckedCreateWithoutCartInput> | CartItemsCreateWithoutCartInput[] | CartItemsUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemsCreateOrConnectWithoutCartInput | CartItemsCreateOrConnectWithoutCartInput[]
    upsert?: CartItemsUpsertWithWhereUniqueWithoutCartInput | CartItemsUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemsCreateManyCartInputEnvelope
    set?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    disconnect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    delete?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    connect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    update?: CartItemsUpdateWithWhereUniqueWithoutCartInput | CartItemsUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemsUpdateManyWithWhereWithoutCartInput | CartItemsUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemsScalarWhereInput | CartItemsScalarWhereInput[]
  }

  export type UserUncheckedUpdateOneWithoutCartNestedInput = {
    create?: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartInput
    upsert?: UserUpsertWithoutCartInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCartInput, UserUpdateWithoutCartInput>, UserUncheckedUpdateWithoutCartInput>
  }

  export type CartItemsUncheckedUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemsCreateWithoutCartInput, CartItemsUncheckedCreateWithoutCartInput> | CartItemsCreateWithoutCartInput[] | CartItemsUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemsCreateOrConnectWithoutCartInput | CartItemsCreateOrConnectWithoutCartInput[]
    upsert?: CartItemsUpsertWithWhereUniqueWithoutCartInput | CartItemsUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemsCreateManyCartInputEnvelope
    set?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    disconnect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    delete?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    connect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    update?: CartItemsUpdateWithWhereUniqueWithoutCartInput | CartItemsUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemsUpdateManyWithWhereWithoutCartInput | CartItemsUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemsScalarWhereInput | CartItemsScalarWhereInput[]
  }

  export type CartCreateNestedOneWithoutCartItemsInput = {
    create?: XOR<CartCreateWithoutCartItemsInput, CartUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutCartItemsInput
    connect?: CartWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutCartItemInput = {
    create?: XOR<ProductsCreateWithoutCartItemInput, ProductsUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutCartItemInput
    connect?: ProductsWhereUniqueInput
  }

  export type AbandonedCartCreateNestedOneWithoutCartItemsInput = {
    create?: XOR<AbandonedCartCreateWithoutCartItemsInput, AbandonedCartUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: AbandonedCartCreateOrConnectWithoutCartItemsInput
    connect?: AbandonedCartWhereUniqueInput
  }

  export type CartUpdateOneRequiredWithoutCartItemsNestedInput = {
    create?: XOR<CartCreateWithoutCartItemsInput, CartUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutCartItemsInput
    upsert?: CartUpsertWithoutCartItemsInput
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutCartItemsInput, CartUpdateWithoutCartItemsInput>, CartUncheckedUpdateWithoutCartItemsInput>
  }

  export type ProductsUpdateOneRequiredWithoutCartItemNestedInput = {
    create?: XOR<ProductsCreateWithoutCartItemInput, ProductsUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutCartItemInput
    upsert?: ProductsUpsertWithoutCartItemInput
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutCartItemInput, ProductsUpdateWithoutCartItemInput>, ProductsUncheckedUpdateWithoutCartItemInput>
  }

  export type AbandonedCartUpdateOneWithoutCartItemsNestedInput = {
    create?: XOR<AbandonedCartCreateWithoutCartItemsInput, AbandonedCartUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: AbandonedCartCreateOrConnectWithoutCartItemsInput
    upsert?: AbandonedCartUpsertWithoutCartItemsInput
    disconnect?: AbandonedCartWhereInput | boolean
    delete?: AbandonedCartWhereInput | boolean
    connect?: AbandonedCartWhereUniqueInput
    update?: XOR<XOR<AbandonedCartUpdateToOneWithWhereWithoutCartItemsInput, AbandonedCartUpdateWithoutCartItemsInput>, AbandonedCartUncheckedUpdateWithoutCartItemsInput>
  }

  export type PaymentCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput> | PaymentCreateWithoutPaymentMethodInput[] | PaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentMethodInput | PaymentCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: PaymentCreateManyPaymentMethodInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput> | PaymentCreateWithoutPaymentMethodInput[] | PaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentMethodInput | PaymentCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: PaymentCreateManyPaymentMethodInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumPaymentMethodTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethodType
  }

  export type PaymentUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput> | PaymentCreateWithoutPaymentMethodInput[] | PaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentMethodInput | PaymentCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: PaymentCreateManyPaymentMethodInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPaymentMethodInput | PaymentUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput> | PaymentCreateWithoutPaymentMethodInput[] | PaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentMethodInput | PaymentCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: PaymentCreateManyPaymentMethodInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPaymentMethodInput | PaymentUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentMethodCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<PaymentMethodCreateWithoutPaymentsInput, PaymentMethodUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutPaymentsInput
    connect?: PaymentMethodWhereUniqueInput
  }

  export type PaymentMethodUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutPaymentsInput, PaymentMethodUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutPaymentsInput
    upsert?: PaymentMethodUpsertWithoutPaymentsInput
    connect?: PaymentMethodWhereUniqueInput
    update?: XOR<XOR<PaymentMethodUpdateToOneWithWhereWithoutPaymentsInput, PaymentMethodUpdateWithoutPaymentsInput>, PaymentMethodUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrdersCreateNestedManyWithoutOrderStatusInput = {
    create?: XOR<OrdersCreateWithoutOrderStatusInput, OrdersUncheckedCreateWithoutOrderStatusInput> | OrdersCreateWithoutOrderStatusInput[] | OrdersUncheckedCreateWithoutOrderStatusInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutOrderStatusInput | OrdersCreateOrConnectWithoutOrderStatusInput[]
    createMany?: OrdersCreateManyOrderStatusInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type OrdersUncheckedCreateNestedManyWithoutOrderStatusInput = {
    create?: XOR<OrdersCreateWithoutOrderStatusInput, OrdersUncheckedCreateWithoutOrderStatusInput> | OrdersCreateWithoutOrderStatusInput[] | OrdersUncheckedCreateWithoutOrderStatusInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutOrderStatusInput | OrdersCreateOrConnectWithoutOrderStatusInput[]
    createMany?: OrdersCreateManyOrderStatusInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type EnumOrderStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatusType
  }

  export type OrdersUpdateManyWithoutOrderStatusNestedInput = {
    create?: XOR<OrdersCreateWithoutOrderStatusInput, OrdersUncheckedCreateWithoutOrderStatusInput> | OrdersCreateWithoutOrderStatusInput[] | OrdersUncheckedCreateWithoutOrderStatusInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutOrderStatusInput | OrdersCreateOrConnectWithoutOrderStatusInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutOrderStatusInput | OrdersUpsertWithWhereUniqueWithoutOrderStatusInput[]
    createMany?: OrdersCreateManyOrderStatusInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutOrderStatusInput | OrdersUpdateWithWhereUniqueWithoutOrderStatusInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutOrderStatusInput | OrdersUpdateManyWithWhereWithoutOrderStatusInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type OrdersUncheckedUpdateManyWithoutOrderStatusNestedInput = {
    create?: XOR<OrdersCreateWithoutOrderStatusInput, OrdersUncheckedCreateWithoutOrderStatusInput> | OrdersCreateWithoutOrderStatusInput[] | OrdersUncheckedCreateWithoutOrderStatusInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutOrderStatusInput | OrdersCreateOrConnectWithoutOrderStatusInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutOrderStatusInput | OrdersUpsertWithWhereUniqueWithoutOrderStatusInput[]
    createMany?: OrdersCreateManyOrderStatusInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutOrderStatusInput | OrdersUpdateWithWhereUniqueWithoutOrderStatusInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutOrderStatusInput | OrdersUpdateManyWithWhereWithoutOrderStatusInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type OrderStatusCreateNestedOneWithoutOrdersInput = {
    create?: XOR<OrderStatusCreateWithoutOrdersInput, OrderStatusUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OrderStatusCreateOrConnectWithoutOrdersInput
    connect?: OrderStatusWhereUniqueInput
  }

  export type AddressesCreateNestedOneWithoutOrderInput = {
    create?: XOR<AddressesCreateWithoutOrderInput, AddressesUncheckedCreateWithoutOrderInput>
    connectOrCreate?: AddressesCreateOrConnectWithoutOrderInput
    connect?: AddressesWhereUniqueInput
  }

  export type UserUsedCouponsCreateNestedManyWithoutOrderInput = {
    create?: XOR<UserUsedCouponsCreateWithoutOrderInput, UserUsedCouponsUncheckedCreateWithoutOrderInput> | UserUsedCouponsCreateWithoutOrderInput[] | UserUsedCouponsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: UserUsedCouponsCreateOrConnectWithoutOrderInput | UserUsedCouponsCreateOrConnectWithoutOrderInput[]
    createMany?: UserUsedCouponsCreateManyOrderInputEnvelope
    connect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
  }

  export type OrderItemsCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemsCreateWithoutOrderInput, OrderItemsUncheckedCreateWithoutOrderInput> | OrderItemsCreateWithoutOrderInput[] | OrderItemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutOrderInput | OrderItemsCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemsCreateManyOrderInputEnvelope
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
  }

  export type OrderHistoryCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderHistoryCreateWithoutOrderInput, OrderHistoryUncheckedCreateWithoutOrderInput> | OrderHistoryCreateWithoutOrderInput[] | OrderHistoryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderHistoryCreateOrConnectWithoutOrderInput | OrderHistoryCreateOrConnectWithoutOrderInput[]
    createMany?: OrderHistoryCreateManyOrderInputEnvelope
    connect?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
  }

  export type ShippingCreateNestedOneWithoutOrderInput = {
    create?: XOR<ShippingCreateWithoutOrderInput, ShippingUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ShippingCreateOrConnectWithoutOrderInput
    connect?: ShippingWhereUniqueInput
  }

  export type ReturnExchangeCreateNestedManyWithoutOrderInput = {
    create?: XOR<ReturnExchangeCreateWithoutOrderInput, ReturnExchangeUncheckedCreateWithoutOrderInput> | ReturnExchangeCreateWithoutOrderInput[] | ReturnExchangeUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReturnExchangeCreateOrConnectWithoutOrderInput | ReturnExchangeCreateOrConnectWithoutOrderInput[]
    createMany?: ReturnExchangeCreateManyOrderInputEnvelope
    connect?: ReturnExchangeWhereUniqueInput | ReturnExchangeWhereUniqueInput[]
  }

  export type UserUsedCouponsUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<UserUsedCouponsCreateWithoutOrderInput, UserUsedCouponsUncheckedCreateWithoutOrderInput> | UserUsedCouponsCreateWithoutOrderInput[] | UserUsedCouponsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: UserUsedCouponsCreateOrConnectWithoutOrderInput | UserUsedCouponsCreateOrConnectWithoutOrderInput[]
    createMany?: UserUsedCouponsCreateManyOrderInputEnvelope
    connect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
  }

  export type OrderItemsUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemsCreateWithoutOrderInput, OrderItemsUncheckedCreateWithoutOrderInput> | OrderItemsCreateWithoutOrderInput[] | OrderItemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutOrderInput | OrderItemsCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemsCreateManyOrderInputEnvelope
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
  }

  export type OrderHistoryUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderHistoryCreateWithoutOrderInput, OrderHistoryUncheckedCreateWithoutOrderInput> | OrderHistoryCreateWithoutOrderInput[] | OrderHistoryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderHistoryCreateOrConnectWithoutOrderInput | OrderHistoryCreateOrConnectWithoutOrderInput[]
    createMany?: OrderHistoryCreateManyOrderInputEnvelope
    connect?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
  }

  export type ShippingUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<ShippingCreateWithoutOrderInput, ShippingUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ShippingCreateOrConnectWithoutOrderInput
    connect?: ShippingWhereUniqueInput
  }

  export type ReturnExchangeUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ReturnExchangeCreateWithoutOrderInput, ReturnExchangeUncheckedCreateWithoutOrderInput> | ReturnExchangeCreateWithoutOrderInput[] | ReturnExchangeUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReturnExchangeCreateOrConnectWithoutOrderInput | ReturnExchangeCreateOrConnectWithoutOrderInput[]
    createMany?: ReturnExchangeCreateManyOrderInputEnvelope
    connect?: ReturnExchangeWhereUniqueInput | ReturnExchangeWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderStatusUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<OrderStatusCreateWithoutOrdersInput, OrderStatusUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OrderStatusCreateOrConnectWithoutOrdersInput
    upsert?: OrderStatusUpsertWithoutOrdersInput
    connect?: OrderStatusWhereUniqueInput
    update?: XOR<XOR<OrderStatusUpdateToOneWithWhereWithoutOrdersInput, OrderStatusUpdateWithoutOrdersInput>, OrderStatusUncheckedUpdateWithoutOrdersInput>
  }

  export type AddressesUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<AddressesCreateWithoutOrderInput, AddressesUncheckedCreateWithoutOrderInput>
    connectOrCreate?: AddressesCreateOrConnectWithoutOrderInput
    upsert?: AddressesUpsertWithoutOrderInput
    connect?: AddressesWhereUniqueInput
    update?: XOR<XOR<AddressesUpdateToOneWithWhereWithoutOrderInput, AddressesUpdateWithoutOrderInput>, AddressesUncheckedUpdateWithoutOrderInput>
  }

  export type UserUsedCouponsUpdateManyWithoutOrderNestedInput = {
    create?: XOR<UserUsedCouponsCreateWithoutOrderInput, UserUsedCouponsUncheckedCreateWithoutOrderInput> | UserUsedCouponsCreateWithoutOrderInput[] | UserUsedCouponsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: UserUsedCouponsCreateOrConnectWithoutOrderInput | UserUsedCouponsCreateOrConnectWithoutOrderInput[]
    upsert?: UserUsedCouponsUpsertWithWhereUniqueWithoutOrderInput | UserUsedCouponsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: UserUsedCouponsCreateManyOrderInputEnvelope
    set?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    disconnect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    delete?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    connect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    update?: UserUsedCouponsUpdateWithWhereUniqueWithoutOrderInput | UserUsedCouponsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: UserUsedCouponsUpdateManyWithWhereWithoutOrderInput | UserUsedCouponsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: UserUsedCouponsScalarWhereInput | UserUsedCouponsScalarWhereInput[]
  }

  export type OrderItemsUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemsCreateWithoutOrderInput, OrderItemsUncheckedCreateWithoutOrderInput> | OrderItemsCreateWithoutOrderInput[] | OrderItemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutOrderInput | OrderItemsCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemsUpsertWithWhereUniqueWithoutOrderInput | OrderItemsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemsCreateManyOrderInputEnvelope
    set?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    disconnect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    delete?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    update?: OrderItemsUpdateWithWhereUniqueWithoutOrderInput | OrderItemsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemsUpdateManyWithWhereWithoutOrderInput | OrderItemsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
  }

  export type OrderHistoryUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderHistoryCreateWithoutOrderInput, OrderHistoryUncheckedCreateWithoutOrderInput> | OrderHistoryCreateWithoutOrderInput[] | OrderHistoryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderHistoryCreateOrConnectWithoutOrderInput | OrderHistoryCreateOrConnectWithoutOrderInput[]
    upsert?: OrderHistoryUpsertWithWhereUniqueWithoutOrderInput | OrderHistoryUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderHistoryCreateManyOrderInputEnvelope
    set?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
    disconnect?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
    delete?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
    connect?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
    update?: OrderHistoryUpdateWithWhereUniqueWithoutOrderInput | OrderHistoryUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderHistoryUpdateManyWithWhereWithoutOrderInput | OrderHistoryUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderHistoryScalarWhereInput | OrderHistoryScalarWhereInput[]
  }

  export type ShippingUpdateOneWithoutOrderNestedInput = {
    create?: XOR<ShippingCreateWithoutOrderInput, ShippingUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ShippingCreateOrConnectWithoutOrderInput
    upsert?: ShippingUpsertWithoutOrderInput
    disconnect?: ShippingWhereInput | boolean
    delete?: ShippingWhereInput | boolean
    connect?: ShippingWhereUniqueInput
    update?: XOR<XOR<ShippingUpdateToOneWithWhereWithoutOrderInput, ShippingUpdateWithoutOrderInput>, ShippingUncheckedUpdateWithoutOrderInput>
  }

  export type ReturnExchangeUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ReturnExchangeCreateWithoutOrderInput, ReturnExchangeUncheckedCreateWithoutOrderInput> | ReturnExchangeCreateWithoutOrderInput[] | ReturnExchangeUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReturnExchangeCreateOrConnectWithoutOrderInput | ReturnExchangeCreateOrConnectWithoutOrderInput[]
    upsert?: ReturnExchangeUpsertWithWhereUniqueWithoutOrderInput | ReturnExchangeUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ReturnExchangeCreateManyOrderInputEnvelope
    set?: ReturnExchangeWhereUniqueInput | ReturnExchangeWhereUniqueInput[]
    disconnect?: ReturnExchangeWhereUniqueInput | ReturnExchangeWhereUniqueInput[]
    delete?: ReturnExchangeWhereUniqueInput | ReturnExchangeWhereUniqueInput[]
    connect?: ReturnExchangeWhereUniqueInput | ReturnExchangeWhereUniqueInput[]
    update?: ReturnExchangeUpdateWithWhereUniqueWithoutOrderInput | ReturnExchangeUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ReturnExchangeUpdateManyWithWhereWithoutOrderInput | ReturnExchangeUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ReturnExchangeScalarWhereInput | ReturnExchangeScalarWhereInput[]
  }

  export type UserUsedCouponsUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<UserUsedCouponsCreateWithoutOrderInput, UserUsedCouponsUncheckedCreateWithoutOrderInput> | UserUsedCouponsCreateWithoutOrderInput[] | UserUsedCouponsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: UserUsedCouponsCreateOrConnectWithoutOrderInput | UserUsedCouponsCreateOrConnectWithoutOrderInput[]
    upsert?: UserUsedCouponsUpsertWithWhereUniqueWithoutOrderInput | UserUsedCouponsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: UserUsedCouponsCreateManyOrderInputEnvelope
    set?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    disconnect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    delete?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    connect?: UserUsedCouponsWhereUniqueInput | UserUsedCouponsWhereUniqueInput[]
    update?: UserUsedCouponsUpdateWithWhereUniqueWithoutOrderInput | UserUsedCouponsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: UserUsedCouponsUpdateManyWithWhereWithoutOrderInput | UserUsedCouponsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: UserUsedCouponsScalarWhereInput | UserUsedCouponsScalarWhereInput[]
  }

  export type OrderItemsUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemsCreateWithoutOrderInput, OrderItemsUncheckedCreateWithoutOrderInput> | OrderItemsCreateWithoutOrderInput[] | OrderItemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutOrderInput | OrderItemsCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemsUpsertWithWhereUniqueWithoutOrderInput | OrderItemsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemsCreateManyOrderInputEnvelope
    set?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    disconnect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    delete?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    update?: OrderItemsUpdateWithWhereUniqueWithoutOrderInput | OrderItemsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemsUpdateManyWithWhereWithoutOrderInput | OrderItemsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
  }

  export type OrderHistoryUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderHistoryCreateWithoutOrderInput, OrderHistoryUncheckedCreateWithoutOrderInput> | OrderHistoryCreateWithoutOrderInput[] | OrderHistoryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderHistoryCreateOrConnectWithoutOrderInput | OrderHistoryCreateOrConnectWithoutOrderInput[]
    upsert?: OrderHistoryUpsertWithWhereUniqueWithoutOrderInput | OrderHistoryUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderHistoryCreateManyOrderInputEnvelope
    set?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
    disconnect?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
    delete?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
    connect?: OrderHistoryWhereUniqueInput | OrderHistoryWhereUniqueInput[]
    update?: OrderHistoryUpdateWithWhereUniqueWithoutOrderInput | OrderHistoryUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderHistoryUpdateManyWithWhereWithoutOrderInput | OrderHistoryUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderHistoryScalarWhereInput | OrderHistoryScalarWhereInput[]
  }

  export type ShippingUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<ShippingCreateWithoutOrderInput, ShippingUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ShippingCreateOrConnectWithoutOrderInput
    upsert?: ShippingUpsertWithoutOrderInput
    disconnect?: ShippingWhereInput | boolean
    delete?: ShippingWhereInput | boolean
    connect?: ShippingWhereUniqueInput
    update?: XOR<XOR<ShippingUpdateToOneWithWhereWithoutOrderInput, ShippingUpdateWithoutOrderInput>, ShippingUncheckedUpdateWithoutOrderInput>
  }

  export type ReturnExchangeUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ReturnExchangeCreateWithoutOrderInput, ReturnExchangeUncheckedCreateWithoutOrderInput> | ReturnExchangeCreateWithoutOrderInput[] | ReturnExchangeUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReturnExchangeCreateOrConnectWithoutOrderInput | ReturnExchangeCreateOrConnectWithoutOrderInput[]
    upsert?: ReturnExchangeUpsertWithWhereUniqueWithoutOrderInput | ReturnExchangeUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ReturnExchangeCreateManyOrderInputEnvelope
    set?: ReturnExchangeWhereUniqueInput | ReturnExchangeWhereUniqueInput[]
    disconnect?: ReturnExchangeWhereUniqueInput | ReturnExchangeWhereUniqueInput[]
    delete?: ReturnExchangeWhereUniqueInput | ReturnExchangeWhereUniqueInput[]
    connect?: ReturnExchangeWhereUniqueInput | ReturnExchangeWhereUniqueInput[]
    update?: ReturnExchangeUpdateWithWhereUniqueWithoutOrderInput | ReturnExchangeUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ReturnExchangeUpdateManyWithWhereWithoutOrderInput | ReturnExchangeUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ReturnExchangeScalarWhereInput | ReturnExchangeScalarWhereInput[]
  }

  export type OrdersCreateNestedOneWithoutOrderHistoryInput = {
    create?: XOR<OrdersCreateWithoutOrderHistoryInput, OrdersUncheckedCreateWithoutOrderHistoryInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutOrderHistoryInput
    connect?: OrdersWhereUniqueInput
  }

  export type OrdersUpdateOneRequiredWithoutOrderHistoryNestedInput = {
    create?: XOR<OrdersCreateWithoutOrderHistoryInput, OrdersUncheckedCreateWithoutOrderHistoryInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutOrderHistoryInput
    upsert?: OrdersUpsertWithoutOrderHistoryInput
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutOrderHistoryInput, OrdersUpdateWithoutOrderHistoryInput>, OrdersUncheckedUpdateWithoutOrderHistoryInput>
  }

  export type OrdersCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<OrdersCreateWithoutOrderItemsInput, OrdersUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutOrderItemsInput
    connect?: OrdersWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductsCreateWithoutOrderItemsInput, ProductsUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutOrderItemsInput
    connect?: ProductsWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<StoresCreateWithoutOrderItemsInput, StoresUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutOrderItemsInput
    connect?: StoresWhereUniqueInput
  }

  export type OrdersUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<OrdersCreateWithoutOrderItemsInput, OrdersUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutOrderItemsInput
    upsert?: OrdersUpsertWithoutOrderItemsInput
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutOrderItemsInput, OrdersUpdateWithoutOrderItemsInput>, OrdersUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductsUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductsCreateWithoutOrderItemsInput, ProductsUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductsUpsertWithoutOrderItemsInput
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutOrderItemsInput, ProductsUpdateWithoutOrderItemsInput>, ProductsUncheckedUpdateWithoutOrderItemsInput>
  }

  export type StoresUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<StoresCreateWithoutOrderItemsInput, StoresUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutOrderItemsInput
    upsert?: StoresUpsertWithoutOrderItemsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutOrderItemsInput, StoresUpdateWithoutOrderItemsInput>, StoresUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrdersCreateNestedOneWithoutShippingInput = {
    create?: XOR<OrdersCreateWithoutShippingInput, OrdersUncheckedCreateWithoutShippingInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutShippingInput
    connect?: OrdersWhereUniqueInput
  }

  export type OrdersUpdateOneRequiredWithoutShippingNestedInput = {
    create?: XOR<OrdersCreateWithoutShippingInput, OrdersUncheckedCreateWithoutShippingInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutShippingInput
    upsert?: OrdersUpsertWithoutShippingInput
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutShippingInput, OrdersUpdateWithoutShippingInput>, OrdersUncheckedUpdateWithoutShippingInput>
  }

  export type UserCreateNestedOneWithoutChatInput = {
    create?: XOR<UserCreateWithoutChatInput, UserUncheckedCreateWithoutChatInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatInput
    connect?: UserWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutChatInput = {
    create?: XOR<StoresCreateWithoutChatInput, StoresUncheckedCreateWithoutChatInput>
    connectOrCreate?: StoresCreateOrConnectWithoutChatInput
    connect?: StoresWhereUniqueInput
  }

  export type chatMessagesCreateNestedManyWithoutChatInput = {
    create?: XOR<chatMessagesCreateWithoutChatInput, chatMessagesUncheckedCreateWithoutChatInput> | chatMessagesCreateWithoutChatInput[] | chatMessagesUncheckedCreateWithoutChatInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutChatInput | chatMessagesCreateOrConnectWithoutChatInput[]
    createMany?: chatMessagesCreateManyChatInputEnvelope
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
  }

  export type chatMessagesUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<chatMessagesCreateWithoutChatInput, chatMessagesUncheckedCreateWithoutChatInput> | chatMessagesCreateWithoutChatInput[] | chatMessagesUncheckedCreateWithoutChatInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutChatInput | chatMessagesCreateOrConnectWithoutChatInput[]
    createMany?: chatMessagesCreateManyChatInputEnvelope
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutChatNestedInput = {
    create?: XOR<UserCreateWithoutChatInput, UserUncheckedCreateWithoutChatInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatInput
    upsert?: UserUpsertWithoutChatInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatInput, UserUpdateWithoutChatInput>, UserUncheckedUpdateWithoutChatInput>
  }

  export type StoresUpdateOneRequiredWithoutChatNestedInput = {
    create?: XOR<StoresCreateWithoutChatInput, StoresUncheckedCreateWithoutChatInput>
    connectOrCreate?: StoresCreateOrConnectWithoutChatInput
    upsert?: StoresUpsertWithoutChatInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutChatInput, StoresUpdateWithoutChatInput>, StoresUncheckedUpdateWithoutChatInput>
  }

  export type chatMessagesUpdateManyWithoutChatNestedInput = {
    create?: XOR<chatMessagesCreateWithoutChatInput, chatMessagesUncheckedCreateWithoutChatInput> | chatMessagesCreateWithoutChatInput[] | chatMessagesUncheckedCreateWithoutChatInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutChatInput | chatMessagesCreateOrConnectWithoutChatInput[]
    upsert?: chatMessagesUpsertWithWhereUniqueWithoutChatInput | chatMessagesUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: chatMessagesCreateManyChatInputEnvelope
    set?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    disconnect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    delete?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    update?: chatMessagesUpdateWithWhereUniqueWithoutChatInput | chatMessagesUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: chatMessagesUpdateManyWithWhereWithoutChatInput | chatMessagesUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: chatMessagesScalarWhereInput | chatMessagesScalarWhereInput[]
  }

  export type chatMessagesUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<chatMessagesCreateWithoutChatInput, chatMessagesUncheckedCreateWithoutChatInput> | chatMessagesCreateWithoutChatInput[] | chatMessagesUncheckedCreateWithoutChatInput[]
    connectOrCreate?: chatMessagesCreateOrConnectWithoutChatInput | chatMessagesCreateOrConnectWithoutChatInput[]
    upsert?: chatMessagesUpsertWithWhereUniqueWithoutChatInput | chatMessagesUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: chatMessagesCreateManyChatInputEnvelope
    set?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    disconnect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    delete?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    connect?: chatMessagesWhereUniqueInput | chatMessagesWhereUniqueInput[]
    update?: chatMessagesUpdateWithWhereUniqueWithoutChatInput | chatMessagesUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: chatMessagesUpdateManyWithWhereWithoutChatInput | chatMessagesUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: chatMessagesScalarWhereInput | chatMessagesScalarWhereInput[]
  }

  export type ChatCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    connect?: ChatWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<StoresCreateWithoutSentMessagesInput, StoresUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: StoresCreateOrConnectWithoutSentMessagesInput
    connect?: StoresWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<StoresCreateWithoutReceivedMessagesInput, StoresUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: StoresCreateOrConnectWithoutReceivedMessagesInput
    connect?: StoresWhereUniqueInput
  }

  export type MessageImagesCreateNestedOneWithoutMessageImageInput = {
    create?: XOR<MessageImagesCreateWithoutMessageImageInput, MessageImagesUncheckedCreateWithoutMessageImageInput>
    connectOrCreate?: MessageImagesCreateOrConnectWithoutMessageImageInput
    connect?: MessageImagesWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ChatUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    upsert?: ChatUpsertWithoutMessagesInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMessagesInput, ChatUpdateWithoutMessagesInput>, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type StoresUpdateOneWithoutSentMessagesNestedInput = {
    create?: XOR<StoresCreateWithoutSentMessagesInput, StoresUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: StoresCreateOrConnectWithoutSentMessagesInput
    upsert?: StoresUpsertWithoutSentMessagesInput
    disconnect?: StoresWhereInput | boolean
    delete?: StoresWhereInput | boolean
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutSentMessagesInput, StoresUpdateWithoutSentMessagesInput>, StoresUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type StoresUpdateOneWithoutReceivedMessagesNestedInput = {
    create?: XOR<StoresCreateWithoutReceivedMessagesInput, StoresUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: StoresCreateOrConnectWithoutReceivedMessagesInput
    upsert?: StoresUpsertWithoutReceivedMessagesInput
    disconnect?: StoresWhereInput | boolean
    delete?: StoresWhereInput | boolean
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutReceivedMessagesInput, StoresUpdateWithoutReceivedMessagesInput>, StoresUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type MessageImagesUpdateOneWithoutMessageImageNestedInput = {
    create?: XOR<MessageImagesCreateWithoutMessageImageInput, MessageImagesUncheckedCreateWithoutMessageImageInput>
    connectOrCreate?: MessageImagesCreateOrConnectWithoutMessageImageInput
    upsert?: MessageImagesUpsertWithoutMessageImageInput
    disconnect?: MessageImagesWhereInput | boolean
    delete?: MessageImagesWhereInput | boolean
    connect?: MessageImagesWhereUniqueInput
    update?: XOR<XOR<MessageImagesUpdateToOneWithWhereWithoutMessageImageInput, MessageImagesUpdateWithoutMessageImageInput>, MessageImagesUncheckedUpdateWithoutMessageImageInput>
  }

  export type chatMessagesCreateNestedOneWithoutImageInput = {
    create?: XOR<chatMessagesCreateWithoutImageInput, chatMessagesUncheckedCreateWithoutImageInput>
    connectOrCreate?: chatMessagesCreateOrConnectWithoutImageInput
    connect?: chatMessagesWhereUniqueInput
  }

  export type chatMessagesUncheckedCreateNestedOneWithoutImageInput = {
    create?: XOR<chatMessagesCreateWithoutImageInput, chatMessagesUncheckedCreateWithoutImageInput>
    connectOrCreate?: chatMessagesCreateOrConnectWithoutImageInput
    connect?: chatMessagesWhereUniqueInput
  }

  export type chatMessagesUpdateOneWithoutImageNestedInput = {
    create?: XOR<chatMessagesCreateWithoutImageInput, chatMessagesUncheckedCreateWithoutImageInput>
    connectOrCreate?: chatMessagesCreateOrConnectWithoutImageInput
    upsert?: chatMessagesUpsertWithoutImageInput
    disconnect?: chatMessagesWhereInput | boolean
    delete?: chatMessagesWhereInput | boolean
    connect?: chatMessagesWhereUniqueInput
    update?: XOR<XOR<chatMessagesUpdateToOneWithWhereWithoutImageInput, chatMessagesUpdateWithoutImageInput>, chatMessagesUncheckedUpdateWithoutImageInput>
  }

  export type chatMessagesUncheckedUpdateOneWithoutImageNestedInput = {
    create?: XOR<chatMessagesCreateWithoutImageInput, chatMessagesUncheckedCreateWithoutImageInput>
    connectOrCreate?: chatMessagesCreateOrConnectWithoutImageInput
    upsert?: chatMessagesUpsertWithoutImageInput
    disconnect?: chatMessagesWhereInput | boolean
    delete?: chatMessagesWhereInput | boolean
    connect?: chatMessagesWhereUniqueInput
    update?: XOR<XOR<chatMessagesUpdateToOneWithWhereWithoutImageInput, chatMessagesUpdateWithoutImageInput>, chatMessagesUncheckedUpdateWithoutImageInput>
  }

  export type UserCreateNestedOneWithoutTokenLoginInput = {
    create?: XOR<UserCreateWithoutTokenLoginInput, UserUncheckedCreateWithoutTokenLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokenLoginInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTokenLoginNestedInput = {
    create?: XOR<UserCreateWithoutTokenLoginInput, UserUncheckedCreateWithoutTokenLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokenLoginInput
    upsert?: UserUpsertWithoutTokenLoginInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTokenLoginInput, UserUpdateWithoutTokenLoginInput>, UserUncheckedUpdateWithoutTokenLoginInput>
  }

  export type UserCreateNestedOneWithoutConfirmationTokenInput = {
    create?: XOR<UserCreateWithoutConfirmationTokenInput, UserUncheckedCreateWithoutConfirmationTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutConfirmationTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutConfirmationTokenNestedInput = {
    create?: XOR<UserCreateWithoutConfirmationTokenInput, UserUncheckedCreateWithoutConfirmationTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutConfirmationTokenInput
    upsert?: UserUpsertWithoutConfirmationTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConfirmationTokenInput, UserUpdateWithoutConfirmationTokenInput>, UserUncheckedUpdateWithoutConfirmationTokenInput>
  }

  export type UserCreateNestedOneWithoutLogsInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    upsert?: UserUpsertWithoutLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogsInput, UserUpdateWithoutLogsInput>, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserCreateNestedOneWithoutTwoFactorAuthInput = {
    create?: XOR<UserCreateWithoutTwoFactorAuthInput, UserUncheckedCreateWithoutTwoFactorAuthInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwoFactorAuthInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTwoFactorAuthNestedInput = {
    create?: XOR<UserCreateWithoutTwoFactorAuthInput, UserUncheckedCreateWithoutTwoFactorAuthInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwoFactorAuthInput
    upsert?: UserUpsertWithoutTwoFactorAuthInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTwoFactorAuthInput, UserUpdateWithoutTwoFactorAuthInput>, UserUncheckedUpdateWithoutTwoFactorAuthInput>
  }

  export type UserCreateNestedOneWithoutAbandonedCartInput = {
    create?: XOR<UserCreateWithoutAbandonedCartInput, UserUncheckedCreateWithoutAbandonedCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutAbandonedCartInput
    connect?: UserWhereUniqueInput
  }

  export type CartItemsCreateNestedManyWithoutAbandonedCartInput = {
    create?: XOR<CartItemsCreateWithoutAbandonedCartInput, CartItemsUncheckedCreateWithoutAbandonedCartInput> | CartItemsCreateWithoutAbandonedCartInput[] | CartItemsUncheckedCreateWithoutAbandonedCartInput[]
    connectOrCreate?: CartItemsCreateOrConnectWithoutAbandonedCartInput | CartItemsCreateOrConnectWithoutAbandonedCartInput[]
    createMany?: CartItemsCreateManyAbandonedCartInputEnvelope
    connect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
  }

  export type CartItemsUncheckedCreateNestedManyWithoutAbandonedCartInput = {
    create?: XOR<CartItemsCreateWithoutAbandonedCartInput, CartItemsUncheckedCreateWithoutAbandonedCartInput> | CartItemsCreateWithoutAbandonedCartInput[] | CartItemsUncheckedCreateWithoutAbandonedCartInput[]
    connectOrCreate?: CartItemsCreateOrConnectWithoutAbandonedCartInput | CartItemsCreateOrConnectWithoutAbandonedCartInput[]
    createMany?: CartItemsCreateManyAbandonedCartInputEnvelope
    connect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAbandonedCartNestedInput = {
    create?: XOR<UserCreateWithoutAbandonedCartInput, UserUncheckedCreateWithoutAbandonedCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutAbandonedCartInput
    upsert?: UserUpsertWithoutAbandonedCartInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAbandonedCartInput, UserUpdateWithoutAbandonedCartInput>, UserUncheckedUpdateWithoutAbandonedCartInput>
  }

  export type CartItemsUpdateManyWithoutAbandonedCartNestedInput = {
    create?: XOR<CartItemsCreateWithoutAbandonedCartInput, CartItemsUncheckedCreateWithoutAbandonedCartInput> | CartItemsCreateWithoutAbandonedCartInput[] | CartItemsUncheckedCreateWithoutAbandonedCartInput[]
    connectOrCreate?: CartItemsCreateOrConnectWithoutAbandonedCartInput | CartItemsCreateOrConnectWithoutAbandonedCartInput[]
    upsert?: CartItemsUpsertWithWhereUniqueWithoutAbandonedCartInput | CartItemsUpsertWithWhereUniqueWithoutAbandonedCartInput[]
    createMany?: CartItemsCreateManyAbandonedCartInputEnvelope
    set?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    disconnect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    delete?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    connect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    update?: CartItemsUpdateWithWhereUniqueWithoutAbandonedCartInput | CartItemsUpdateWithWhereUniqueWithoutAbandonedCartInput[]
    updateMany?: CartItemsUpdateManyWithWhereWithoutAbandonedCartInput | CartItemsUpdateManyWithWhereWithoutAbandonedCartInput[]
    deleteMany?: CartItemsScalarWhereInput | CartItemsScalarWhereInput[]
  }

  export type CartItemsUncheckedUpdateManyWithoutAbandonedCartNestedInput = {
    create?: XOR<CartItemsCreateWithoutAbandonedCartInput, CartItemsUncheckedCreateWithoutAbandonedCartInput> | CartItemsCreateWithoutAbandonedCartInput[] | CartItemsUncheckedCreateWithoutAbandonedCartInput[]
    connectOrCreate?: CartItemsCreateOrConnectWithoutAbandonedCartInput | CartItemsCreateOrConnectWithoutAbandonedCartInput[]
    upsert?: CartItemsUpsertWithWhereUniqueWithoutAbandonedCartInput | CartItemsUpsertWithWhereUniqueWithoutAbandonedCartInput[]
    createMany?: CartItemsCreateManyAbandonedCartInputEnvelope
    set?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    disconnect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    delete?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    connect?: CartItemsWhereUniqueInput | CartItemsWhereUniqueInput[]
    update?: CartItemsUpdateWithWhereUniqueWithoutAbandonedCartInput | CartItemsUpdateWithWhereUniqueWithoutAbandonedCartInput[]
    updateMany?: CartItemsUpdateManyWithWhereWithoutAbandonedCartInput | CartItemsUpdateManyWithWhereWithoutAbandonedCartInput[]
    deleteMany?: CartItemsScalarWhereInput | CartItemsScalarWhereInput[]
  }

  export type OrdersCreateNestedOneWithoutReturnExchangeInput = {
    create?: XOR<OrdersCreateWithoutReturnExchangeInput, OrdersUncheckedCreateWithoutReturnExchangeInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutReturnExchangeInput
    connect?: OrdersWhereUniqueInput
  }

  export type EnumReturnExchangeStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReturnExchangeStatus
  }

  export type OrdersUpdateOneRequiredWithoutReturnExchangeNestedInput = {
    create?: XOR<OrdersCreateWithoutReturnExchangeInput, OrdersUncheckedCreateWithoutReturnExchangeInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutReturnExchangeInput
    upsert?: OrdersUpsertWithoutReturnExchangeInput
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutReturnExchangeInput, OrdersUpdateWithoutReturnExchangeInput>, OrdersUncheckedUpdateWithoutReturnExchangeInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodType | EnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodType[]
    notIn?: $Enums.PaymentMethodType[]
    not?: NestedEnumPaymentMethodTypeFilter<$PrismaModel> | $Enums.PaymentMethodType
  }

  export type NestedEnumPaymentMethodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodType | EnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodType[]
    notIn?: $Enums.PaymentMethodType[]
    not?: NestedEnumPaymentMethodTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatusType | EnumOrderStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatusType[]
    notIn?: $Enums.OrderStatusType[]
    not?: NestedEnumOrderStatusTypeFilter<$PrismaModel> | $Enums.OrderStatusType
  }

  export type NestedEnumOrderStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatusType | EnumOrderStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatusType[]
    notIn?: $Enums.OrderStatusType[]
    not?: NestedEnumOrderStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusTypeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumReturnExchangeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnExchangeStatus | EnumReturnExchangeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnExchangeStatus[]
    notIn?: $Enums.ReturnExchangeStatus[]
    not?: NestedEnumReturnExchangeStatusFilter<$PrismaModel> | $Enums.ReturnExchangeStatus
  }

  export type NestedEnumReturnExchangeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnExchangeStatus | EnumReturnExchangeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnExchangeStatus[]
    notIn?: $Enums.ReturnExchangeStatus[]
    not?: NestedEnumReturnExchangeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReturnExchangeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReturnExchangeStatusFilter<$PrismaModel>
    _max?: NestedEnumReturnExchangeStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutAdminInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AvatarUserCreateWithoutUserInput = {
    url: string
    publicId: string
  }

  export type AvatarUserUncheckedCreateWithoutUserInput = {
    id?: number
    url: string
    publicId: string
  }

  export type AvatarUserCreateOrConnectWithoutUserInput = {
    where: AvatarUserWhereUniqueInput
    create: XOR<AvatarUserCreateWithoutUserInput, AvatarUserUncheckedCreateWithoutUserInput>
  }

  export type LoginTokenCreateWithoutUserInput = {
    token: string
  }

  export type LoginTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
  }

  export type LoginTokenCreateOrConnectWithoutUserInput = {
    where: LoginTokenWhereUniqueInput
    create: XOR<LoginTokenCreateWithoutUserInput, LoginTokenUncheckedCreateWithoutUserInput>
  }

  export type ConfirmationTokenCreateWithoutUserInput = {
    token: string
  }

  export type ConfirmationTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
  }

  export type ConfirmationTokenCreateOrConnectWithoutUserInput = {
    where: ConfirmationTokenWhereUniqueInput
    create: XOR<ConfirmationTokenCreateWithoutUserInput, ConfirmationTokenUncheckedCreateWithoutUserInput>
  }

  export type AdminCreateWithoutUserInput = {

  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: number
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type AddressesCreateWithoutPrincipalOfInput = {
    cep: string
    road: string
    number: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    country?: string
    type?: string | null
    reference?: string | null
    user: UserCreateNestedOneWithoutAddressesInput
    order?: OrdersCreateNestedManyWithoutDeliveryAddressInput
  }

  export type AddressesUncheckedCreateWithoutPrincipalOfInput = {
    id?: number
    userId: number
    cep: string
    road: string
    number: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    country?: string
    type?: string | null
    reference?: string | null
    order?: OrdersUncheckedCreateNestedManyWithoutDeliveryAddressInput
  }

  export type AddressesCreateOrConnectWithoutPrincipalOfInput = {
    where: AddressesWhereUniqueInput
    create: XOR<AddressesCreateWithoutPrincipalOfInput, AddressesUncheckedCreateWithoutPrincipalOfInput>
  }

  export type AddressesCreateWithoutUserInput = {
    cep: string
    road: string
    number: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    country?: string
    type?: string | null
    reference?: string | null
    principalOf?: UserCreateNestedOneWithoutPrincipalAddressInput
    order?: OrdersCreateNestedManyWithoutDeliveryAddressInput
  }

  export type AddressesUncheckedCreateWithoutUserInput = {
    id?: number
    cep: string
    road: string
    number: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    country?: string
    type?: string | null
    reference?: string | null
    principalOf?: UserUncheckedCreateNestedOneWithoutPrincipalAddressInput
    order?: OrdersUncheckedCreateNestedManyWithoutDeliveryAddressInput
  }

  export type AddressesCreateOrConnectWithoutUserInput = {
    where: AddressesWhereUniqueInput
    create: XOR<AddressesCreateWithoutUserInput, AddressesUncheckedCreateWithoutUserInput>
  }

  export type AddressesCreateManyUserInputEnvelope = {
    data: AddressesCreateManyUserInput | AddressesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StoresCreateWithoutUserInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    avatar?: AvatarStoreCreateNestedOneWithoutStoreAvatarInput
    product?: ProductsCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsCreateNestedManyWithoutStoreInput
    coupons?: CouponsCreateNestedManyWithoutStoreInput
    chat?: ChatCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoreInput
    promotions?: PromotionCreateNestedManyWithoutStoreInput
  }

  export type StoresUncheckedCreateWithoutUserInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    avatarId?: number | null
    product?: ProductsUncheckedCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutStoreInput
    coupons?: CouponsUncheckedCreateNestedManyWithoutStoreInput
    chat?: ChatUncheckedCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoreInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoresCreateOrConnectWithoutUserInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutUserInput, StoresUncheckedCreateWithoutUserInput>
  }

  export type ProductAvaliationsCreateWithoutUserInput = {
    note: number
    avaliationDate?: Date | string
    comment?: string | null
    product: ProductsCreateNestedOneWithoutAvaliationsInput
    images?: ProductAvaliationImagesCreateNestedManyWithoutProductAvaliationInput
  }

  export type ProductAvaliationsUncheckedCreateWithoutUserInput = {
    id?: number
    productId: number
    note: number
    avaliationDate?: Date | string
    comment?: string | null
    images?: ProductAvaliationImagesUncheckedCreateNestedManyWithoutProductAvaliationInput
  }

  export type ProductAvaliationsCreateOrConnectWithoutUserInput = {
    where: ProductAvaliationsWhereUniqueInput
    create: XOR<ProductAvaliationsCreateWithoutUserInput, ProductAvaliationsUncheckedCreateWithoutUserInput>
  }

  export type ProductAvaliationsCreateManyUserInputEnvelope = {
    data: ProductAvaliationsCreateManyUserInput | ProductAvaliationsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StoreAvaliationsCreateWithoutUserInput = {
    note: number
    avaliationDate?: Date | string
    comment?: string | null
    store: StoresCreateNestedOneWithoutAvaliationsInput
    images?: StoreAvaliationImagesCreateNestedManyWithoutStoreAvaliationInput
  }

  export type StoreAvaliationsUncheckedCreateWithoutUserInput = {
    id?: number
    storeId: number
    note: number
    avaliationDate?: Date | string
    comment?: string | null
    images?: StoreAvaliationImagesUncheckedCreateNestedManyWithoutStoreAvaliationInput
  }

  export type StoreAvaliationsCreateOrConnectWithoutUserInput = {
    where: StoreAvaliationsWhereUniqueInput
    create: XOR<StoreAvaliationsCreateWithoutUserInput, StoreAvaliationsUncheckedCreateWithoutUserInput>
  }

  export type StoreAvaliationsCreateManyUserInputEnvelope = {
    data: StoreAvaliationsCreateManyUserInput | StoreAvaliationsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CartCreateWithoutUserCartInput = {
    cartItems?: CartItemsCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateWithoutUserCartInput = {
    id?: number
    cartItems?: CartItemsUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartCreateOrConnectWithoutUserCartInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutUserCartInput, CartUncheckedCreateWithoutUserCartInput>
  }

  export type OrdersCreateWithoutUserInput = {
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    orderStatus: OrderStatusCreateNestedOneWithoutOrdersInput
    deliveryAddress: AddressesCreateNestedOneWithoutOrderInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemsCreateNestedManyWithoutOrderInput
    orderHistory?: OrderHistoryCreateNestedManyWithoutOrderInput
    shipping?: ShippingCreateNestedOneWithoutOrderInput
    ReturnExchange?: ReturnExchangeCreateNestedManyWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutUserInput = {
    id?: number
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    orderStatusId: number
    deliveryAddressId: number
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutOrderInput
    orderHistory?: OrderHistoryUncheckedCreateNestedManyWithoutOrderInput
    shipping?: ShippingUncheckedCreateNestedOneWithoutOrderInput
    ReturnExchange?: ReturnExchangeUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutUserInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutUserInput, OrdersUncheckedCreateWithoutUserInput>
  }

  export type OrdersCreateManyUserInputEnvelope = {
    data: OrdersCreateManyUserInput | OrdersCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserUsedCouponsCreateWithoutUserInput = {
    usedAt?: Date | string
    coupon: CouponsCreateNestedOneWithoutUsedCouponsInput
    order?: OrdersCreateNestedOneWithoutUsedCouponsInput
  }

  export type UserUsedCouponsUncheckedCreateWithoutUserInput = {
    id?: number
    couponId: number
    usedAt?: Date | string
    orderId?: number | null
  }

  export type UserUsedCouponsCreateOrConnectWithoutUserInput = {
    where: UserUsedCouponsWhereUniqueInput
    create: XOR<UserUsedCouponsCreateWithoutUserInput, UserUsedCouponsUncheckedCreateWithoutUserInput>
  }

  export type UserUsedCouponsCreateManyUserInputEnvelope = {
    data: UserUsedCouponsCreateManyUserInput | UserUsedCouponsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutUserInput = {
    store: StoresCreateNestedOneWithoutChatInput
    messages?: chatMessagesCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutUserInput = {
    id?: number
    storeId: number
    messages?: chatMessagesUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutUserInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput>
  }

  export type ChatCreateManyUserInputEnvelope = {
    data: ChatCreateManyUserInput | ChatCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type chatMessagesCreateWithoutSenderUserInput = {
    content: string
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
    chat: ChatCreateNestedOneWithoutMessagesInput
    senderStore?: StoresCreateNestedOneWithoutSentMessagesInput
    receiverUser?: UserCreateNestedOneWithoutReceivedMessagesInput
    receiverStore?: StoresCreateNestedOneWithoutReceivedMessagesInput
    image?: MessageImagesCreateNestedOneWithoutMessageImageInput
  }

  export type chatMessagesUncheckedCreateWithoutSenderUserInput = {
    id?: number
    content: string
    chatId: number
    senderStoreId?: number | null
    receiverUserId?: number | null
    receiverStoreId?: number | null
    imageId?: number | null
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
  }

  export type chatMessagesCreateOrConnectWithoutSenderUserInput = {
    where: chatMessagesWhereUniqueInput
    create: XOR<chatMessagesCreateWithoutSenderUserInput, chatMessagesUncheckedCreateWithoutSenderUserInput>
  }

  export type chatMessagesCreateManySenderUserInputEnvelope = {
    data: chatMessagesCreateManySenderUserInput | chatMessagesCreateManySenderUserInput[]
    skipDuplicates?: boolean
  }

  export type chatMessagesCreateWithoutReceiverUserInput = {
    content: string
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
    chat: ChatCreateNestedOneWithoutMessagesInput
    senderUser?: UserCreateNestedOneWithoutSentMessagesInput
    senderStore?: StoresCreateNestedOneWithoutSentMessagesInput
    receiverStore?: StoresCreateNestedOneWithoutReceivedMessagesInput
    image?: MessageImagesCreateNestedOneWithoutMessageImageInput
  }

  export type chatMessagesUncheckedCreateWithoutReceiverUserInput = {
    id?: number
    content: string
    chatId: number
    senderUserId?: number | null
    senderStoreId?: number | null
    receiverStoreId?: number | null
    imageId?: number | null
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
  }

  export type chatMessagesCreateOrConnectWithoutReceiverUserInput = {
    where: chatMessagesWhereUniqueInput
    create: XOR<chatMessagesCreateWithoutReceiverUserInput, chatMessagesUncheckedCreateWithoutReceiverUserInput>
  }

  export type chatMessagesCreateManyReceiverUserInputEnvelope = {
    data: chatMessagesCreateManyReceiverUserInput | chatMessagesCreateManyReceiverUserInput[]
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutUserInput = {
    action: string
    tableName: string
    recordId?: number | null
    timestamp?: Date | string
    details?: string | null
  }

  export type LogUncheckedCreateWithoutUserInput = {
    id?: number
    action: string
    tableName: string
    recordId?: number | null
    timestamp?: Date | string
    details?: string | null
  }

  export type LogCreateOrConnectWithoutUserInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput>
  }

  export type LogCreateManyUserInputEnvelope = {
    data: LogCreateManyUserInput | LogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TwoFactorAuthCreateWithoutUserInput = {
    secret: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorAuthUncheckedCreateWithoutUserInput = {
    id?: number
    secret: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorAuthCreateOrConnectWithoutUserInput = {
    where: TwoFactorAuthWhereUniqueInput
    create: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput>
  }

  export type TwoFactorAuthCreateManyUserInputEnvelope = {
    data: TwoFactorAuthCreateManyUserInput | TwoFactorAuthCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WishlistCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductsCreateNestedManyWithoutWishlistsInput
  }

  export type WishlistUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductsUncheckedCreateNestedManyWithoutWishlistsInput
  }

  export type WishlistCreateOrConnectWithoutUserInput = {
    where: WishlistWhereUniqueInput
    create: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput>
  }

  export type WishlistCreateManyUserInputEnvelope = {
    data: WishlistCreateManyUserInput | WishlistCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AbandonedCartCreateWithoutUserInput = {
    abandonedAt?: Date | string
    cartItems?: CartItemsCreateNestedManyWithoutAbandonedCartInput
  }

  export type AbandonedCartUncheckedCreateWithoutUserInput = {
    id?: number
    abandonedAt?: Date | string
    cartItems?: CartItemsUncheckedCreateNestedManyWithoutAbandonedCartInput
  }

  export type AbandonedCartCreateOrConnectWithoutUserInput = {
    where: AbandonedCartWhereUniqueInput
    create: XOR<AbandonedCartCreateWithoutUserInput, AbandonedCartUncheckedCreateWithoutUserInput>
  }

  export type AbandonedCartCreateManyUserInputEnvelope = {
    data: AbandonedCartCreateManyUserInput | AbandonedCartCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AvatarUserUpsertWithoutUserInput = {
    update: XOR<AvatarUserUpdateWithoutUserInput, AvatarUserUncheckedUpdateWithoutUserInput>
    create: XOR<AvatarUserCreateWithoutUserInput, AvatarUserUncheckedCreateWithoutUserInput>
    where?: AvatarUserWhereInput
  }

  export type AvatarUserUpdateToOneWithWhereWithoutUserInput = {
    where?: AvatarUserWhereInput
    data: XOR<AvatarUserUpdateWithoutUserInput, AvatarUserUncheckedUpdateWithoutUserInput>
  }

  export type AvatarUserUpdateWithoutUserInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type AvatarUserUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type LoginTokenUpsertWithoutUserInput = {
    update: XOR<LoginTokenUpdateWithoutUserInput, LoginTokenUncheckedUpdateWithoutUserInput>
    create: XOR<LoginTokenCreateWithoutUserInput, LoginTokenUncheckedCreateWithoutUserInput>
    where?: LoginTokenWhereInput
  }

  export type LoginTokenUpdateToOneWithWhereWithoutUserInput = {
    where?: LoginTokenWhereInput
    data: XOR<LoginTokenUpdateWithoutUserInput, LoginTokenUncheckedUpdateWithoutUserInput>
  }

  export type LoginTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
  }

  export type LoginTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
  }

  export type ConfirmationTokenUpsertWithoutUserInput = {
    update: XOR<ConfirmationTokenUpdateWithoutUserInput, ConfirmationTokenUncheckedUpdateWithoutUserInput>
    create: XOR<ConfirmationTokenCreateWithoutUserInput, ConfirmationTokenUncheckedCreateWithoutUserInput>
    where?: ConfirmationTokenWhereInput
  }

  export type ConfirmationTokenUpdateToOneWithWhereWithoutUserInput = {
    where?: ConfirmationTokenWhereInput
    data: XOR<ConfirmationTokenUpdateWithoutUserInput, ConfirmationTokenUncheckedUpdateWithoutUserInput>
  }

  export type ConfirmationTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
  }

  export type ConfirmationTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {

  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type AddressesUpsertWithoutPrincipalOfInput = {
    update: XOR<AddressesUpdateWithoutPrincipalOfInput, AddressesUncheckedUpdateWithoutPrincipalOfInput>
    create: XOR<AddressesCreateWithoutPrincipalOfInput, AddressesUncheckedCreateWithoutPrincipalOfInput>
    where?: AddressesWhereInput
  }

  export type AddressesUpdateToOneWithWhereWithoutPrincipalOfInput = {
    where?: AddressesWhereInput
    data: XOR<AddressesUpdateWithoutPrincipalOfInput, AddressesUncheckedUpdateWithoutPrincipalOfInput>
  }

  export type AddressesUpdateWithoutPrincipalOfInput = {
    cep?: StringFieldUpdateOperationsInput | string
    road?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAddressesNestedInput
    order?: OrdersUpdateManyWithoutDeliveryAddressNestedInput
  }

  export type AddressesUncheckedUpdateWithoutPrincipalOfInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    road?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrdersUncheckedUpdateManyWithoutDeliveryAddressNestedInput
  }

  export type AddressesUpsertWithWhereUniqueWithoutUserInput = {
    where: AddressesWhereUniqueInput
    update: XOR<AddressesUpdateWithoutUserInput, AddressesUncheckedUpdateWithoutUserInput>
    create: XOR<AddressesCreateWithoutUserInput, AddressesUncheckedCreateWithoutUserInput>
  }

  export type AddressesUpdateWithWhereUniqueWithoutUserInput = {
    where: AddressesWhereUniqueInput
    data: XOR<AddressesUpdateWithoutUserInput, AddressesUncheckedUpdateWithoutUserInput>
  }

  export type AddressesUpdateManyWithWhereWithoutUserInput = {
    where: AddressesScalarWhereInput
    data: XOR<AddressesUpdateManyMutationInput, AddressesUncheckedUpdateManyWithoutUserInput>
  }

  export type AddressesScalarWhereInput = {
    AND?: AddressesScalarWhereInput | AddressesScalarWhereInput[]
    OR?: AddressesScalarWhereInput[]
    NOT?: AddressesScalarWhereInput | AddressesScalarWhereInput[]
    id?: IntFilter<"Addresses"> | number
    userId?: IntFilter<"Addresses"> | number
    cep?: StringFilter<"Addresses"> | string
    road?: StringFilter<"Addresses"> | string
    number?: StringFilter<"Addresses"> | string
    complement?: StringNullableFilter<"Addresses"> | string | null
    neighborhood?: StringFilter<"Addresses"> | string
    city?: StringFilter<"Addresses"> | string
    state?: StringFilter<"Addresses"> | string
    country?: StringFilter<"Addresses"> | string
    type?: StringNullableFilter<"Addresses"> | string | null
    reference?: StringNullableFilter<"Addresses"> | string | null
  }

  export type StoresUpsertWithoutUserInput = {
    update: XOR<StoresUpdateWithoutUserInput, StoresUncheckedUpdateWithoutUserInput>
    create: XOR<StoresCreateWithoutUserInput, StoresUncheckedCreateWithoutUserInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutUserInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutUserInput, StoresUncheckedUpdateWithoutUserInput>
  }

  export type StoresUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: AvatarStoreUpdateOneWithoutStoreAvatarNestedInput
    product?: ProductsUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUpdateManyWithoutStoreNestedInput
    chat?: ChatUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUpdateManyWithoutStoreNestedInput
  }

  export type StoresUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    product?: ProductsUncheckedUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUncheckedUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUncheckedUpdateManyWithoutStoreNestedInput
    chat?: ChatUncheckedUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ProductAvaliationsUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductAvaliationsWhereUniqueInput
    update: XOR<ProductAvaliationsUpdateWithoutUserInput, ProductAvaliationsUncheckedUpdateWithoutUserInput>
    create: XOR<ProductAvaliationsCreateWithoutUserInput, ProductAvaliationsUncheckedCreateWithoutUserInput>
  }

  export type ProductAvaliationsUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductAvaliationsWhereUniqueInput
    data: XOR<ProductAvaliationsUpdateWithoutUserInput, ProductAvaliationsUncheckedUpdateWithoutUserInput>
  }

  export type ProductAvaliationsUpdateManyWithWhereWithoutUserInput = {
    where: ProductAvaliationsScalarWhereInput
    data: XOR<ProductAvaliationsUpdateManyMutationInput, ProductAvaliationsUncheckedUpdateManyWithoutUserInput>
  }

  export type ProductAvaliationsScalarWhereInput = {
    AND?: ProductAvaliationsScalarWhereInput | ProductAvaliationsScalarWhereInput[]
    OR?: ProductAvaliationsScalarWhereInput[]
    NOT?: ProductAvaliationsScalarWhereInput | ProductAvaliationsScalarWhereInput[]
    id?: IntFilter<"ProductAvaliations"> | number
    userId?: IntFilter<"ProductAvaliations"> | number
    productId?: IntFilter<"ProductAvaliations"> | number
    note?: IntFilter<"ProductAvaliations"> | number
    avaliationDate?: DateTimeFilter<"ProductAvaliations"> | Date | string
    comment?: StringNullableFilter<"ProductAvaliations"> | string | null
  }

  export type StoreAvaliationsUpsertWithWhereUniqueWithoutUserInput = {
    where: StoreAvaliationsWhereUniqueInput
    update: XOR<StoreAvaliationsUpdateWithoutUserInput, StoreAvaliationsUncheckedUpdateWithoutUserInput>
    create: XOR<StoreAvaliationsCreateWithoutUserInput, StoreAvaliationsUncheckedCreateWithoutUserInput>
  }

  export type StoreAvaliationsUpdateWithWhereUniqueWithoutUserInput = {
    where: StoreAvaliationsWhereUniqueInput
    data: XOR<StoreAvaliationsUpdateWithoutUserInput, StoreAvaliationsUncheckedUpdateWithoutUserInput>
  }

  export type StoreAvaliationsUpdateManyWithWhereWithoutUserInput = {
    where: StoreAvaliationsScalarWhereInput
    data: XOR<StoreAvaliationsUpdateManyMutationInput, StoreAvaliationsUncheckedUpdateManyWithoutUserInput>
  }

  export type StoreAvaliationsScalarWhereInput = {
    AND?: StoreAvaliationsScalarWhereInput | StoreAvaliationsScalarWhereInput[]
    OR?: StoreAvaliationsScalarWhereInput[]
    NOT?: StoreAvaliationsScalarWhereInput | StoreAvaliationsScalarWhereInput[]
    id?: IntFilter<"StoreAvaliations"> | number
    userId?: IntFilter<"StoreAvaliations"> | number
    storeId?: IntFilter<"StoreAvaliations"> | number
    note?: IntFilter<"StoreAvaliations"> | number
    avaliationDate?: DateTimeFilter<"StoreAvaliations"> | Date | string
    comment?: StringNullableFilter<"StoreAvaliations"> | string | null
  }

  export type CartUpsertWithoutUserCartInput = {
    update: XOR<CartUpdateWithoutUserCartInput, CartUncheckedUpdateWithoutUserCartInput>
    create: XOR<CartCreateWithoutUserCartInput, CartUncheckedCreateWithoutUserCartInput>
    where?: CartWhereInput
  }

  export type CartUpdateToOneWithWhereWithoutUserCartInput = {
    where?: CartWhereInput
    data: XOR<CartUpdateWithoutUserCartInput, CartUncheckedUpdateWithoutUserCartInput>
  }

  export type CartUpdateWithoutUserCartInput = {
    cartItems?: CartItemsUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateWithoutUserCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    cartItems?: CartItemsUncheckedUpdateManyWithoutCartNestedInput
  }

  export type OrdersUpsertWithWhereUniqueWithoutUserInput = {
    where: OrdersWhereUniqueInput
    update: XOR<OrdersUpdateWithoutUserInput, OrdersUncheckedUpdateWithoutUserInput>
    create: XOR<OrdersCreateWithoutUserInput, OrdersUncheckedCreateWithoutUserInput>
  }

  export type OrdersUpdateWithWhereUniqueWithoutUserInput = {
    where: OrdersWhereUniqueInput
    data: XOR<OrdersUpdateWithoutUserInput, OrdersUncheckedUpdateWithoutUserInput>
  }

  export type OrdersUpdateManyWithWhereWithoutUserInput = {
    where: OrdersScalarWhereInput
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyWithoutUserInput>
  }

  export type OrdersScalarWhereInput = {
    AND?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
    OR?: OrdersScalarWhereInput[]
    NOT?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
    id?: IntFilter<"Orders"> | number
    totalValue?: DecimalFilter<"Orders"> | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFilter<"Orders"> | string
    createdAt?: DateTimeFilter<"Orders"> | Date | string
    updatedAt?: DateTimeFilter<"Orders"> | Date | string
    sendDate?: DateTimeFilter<"Orders"> | Date | string
    deliveryDate?: DateTimeFilter<"Orders"> | Date | string
    minimumDeliveryForeast?: DateTimeFilter<"Orders"> | Date | string
    maximumDeliveryForeast?: DateTimeFilter<"Orders"> | Date | string
    usedCoupon?: BoolFilter<"Orders"> | boolean
    userId?: IntFilter<"Orders"> | number
    orderStatusId?: IntFilter<"Orders"> | number
    deliveryAddressId?: IntFilter<"Orders"> | number
  }

  export type UserUsedCouponsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserUsedCouponsWhereUniqueInput
    update: XOR<UserUsedCouponsUpdateWithoutUserInput, UserUsedCouponsUncheckedUpdateWithoutUserInput>
    create: XOR<UserUsedCouponsCreateWithoutUserInput, UserUsedCouponsUncheckedCreateWithoutUserInput>
  }

  export type UserUsedCouponsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserUsedCouponsWhereUniqueInput
    data: XOR<UserUsedCouponsUpdateWithoutUserInput, UserUsedCouponsUncheckedUpdateWithoutUserInput>
  }

  export type UserUsedCouponsUpdateManyWithWhereWithoutUserInput = {
    where: UserUsedCouponsScalarWhereInput
    data: XOR<UserUsedCouponsUpdateManyMutationInput, UserUsedCouponsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserUsedCouponsScalarWhereInput = {
    AND?: UserUsedCouponsScalarWhereInput | UserUsedCouponsScalarWhereInput[]
    OR?: UserUsedCouponsScalarWhereInput[]
    NOT?: UserUsedCouponsScalarWhereInput | UserUsedCouponsScalarWhereInput[]
    id?: IntFilter<"UserUsedCoupons"> | number
    userId?: IntFilter<"UserUsedCoupons"> | number
    couponId?: IntFilter<"UserUsedCoupons"> | number
    usedAt?: DateTimeFilter<"UserUsedCoupons"> | Date | string
    orderId?: IntNullableFilter<"UserUsedCoupons"> | number | null
  }

  export type ChatUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutUserInput, ChatUncheckedUpdateWithoutUserInput>
    create: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutUserInput, ChatUncheckedUpdateWithoutUserInput>
  }

  export type ChatUpdateManyWithWhereWithoutUserInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatScalarWhereInput = {
    AND?: ChatScalarWhereInput | ChatScalarWhereInput[]
    OR?: ChatScalarWhereInput[]
    NOT?: ChatScalarWhereInput | ChatScalarWhereInput[]
    id?: IntFilter<"Chat"> | number
    userId?: IntFilter<"Chat"> | number
    storeId?: IntFilter<"Chat"> | number
  }

  export type chatMessagesUpsertWithWhereUniqueWithoutSenderUserInput = {
    where: chatMessagesWhereUniqueInput
    update: XOR<chatMessagesUpdateWithoutSenderUserInput, chatMessagesUncheckedUpdateWithoutSenderUserInput>
    create: XOR<chatMessagesCreateWithoutSenderUserInput, chatMessagesUncheckedCreateWithoutSenderUserInput>
  }

  export type chatMessagesUpdateWithWhereUniqueWithoutSenderUserInput = {
    where: chatMessagesWhereUniqueInput
    data: XOR<chatMessagesUpdateWithoutSenderUserInput, chatMessagesUncheckedUpdateWithoutSenderUserInput>
  }

  export type chatMessagesUpdateManyWithWhereWithoutSenderUserInput = {
    where: chatMessagesScalarWhereInput
    data: XOR<chatMessagesUpdateManyMutationInput, chatMessagesUncheckedUpdateManyWithoutSenderUserInput>
  }

  export type chatMessagesScalarWhereInput = {
    AND?: chatMessagesScalarWhereInput | chatMessagesScalarWhereInput[]
    OR?: chatMessagesScalarWhereInput[]
    NOT?: chatMessagesScalarWhereInput | chatMessagesScalarWhereInput[]
    id?: IntFilter<"chatMessages"> | number
    content?: StringFilter<"chatMessages"> | string
    chatId?: IntFilter<"chatMessages"> | number
    senderUserId?: IntNullableFilter<"chatMessages"> | number | null
    senderStoreId?: IntNullableFilter<"chatMessages"> | number | null
    receiverUserId?: IntNullableFilter<"chatMessages"> | number | null
    receiverStoreId?: IntNullableFilter<"chatMessages"> | number | null
    imageId?: IntNullableFilter<"chatMessages"> | number | null
    sentAt?: DateTimeFilter<"chatMessages"> | Date | string
    receivedAt?: DateTimeNullableFilter<"chatMessages"> | Date | string | null
    wasReceived?: BoolFilter<"chatMessages"> | boolean
    readAt?: DateTimeNullableFilter<"chatMessages"> | Date | string | null
    wasRead?: BoolFilter<"chatMessages"> | boolean
  }

  export type chatMessagesUpsertWithWhereUniqueWithoutReceiverUserInput = {
    where: chatMessagesWhereUniqueInput
    update: XOR<chatMessagesUpdateWithoutReceiverUserInput, chatMessagesUncheckedUpdateWithoutReceiverUserInput>
    create: XOR<chatMessagesCreateWithoutReceiverUserInput, chatMessagesUncheckedCreateWithoutReceiverUserInput>
  }

  export type chatMessagesUpdateWithWhereUniqueWithoutReceiverUserInput = {
    where: chatMessagesWhereUniqueInput
    data: XOR<chatMessagesUpdateWithoutReceiverUserInput, chatMessagesUncheckedUpdateWithoutReceiverUserInput>
  }

  export type chatMessagesUpdateManyWithWhereWithoutReceiverUserInput = {
    where: chatMessagesScalarWhereInput
    data: XOR<chatMessagesUpdateManyMutationInput, chatMessagesUncheckedUpdateManyWithoutReceiverUserInput>
  }

  export type LogUpsertWithWhereUniqueWithoutUserInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutUserInput, LogUncheckedUpdateWithoutUserInput>
    create: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput>
  }

  export type LogUpdateWithWhereUniqueWithoutUserInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutUserInput, LogUncheckedUpdateWithoutUserInput>
  }

  export type LogUpdateManyWithWhereWithoutUserInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutUserInput>
  }

  export type LogScalarWhereInput = {
    AND?: LogScalarWhereInput | LogScalarWhereInput[]
    OR?: LogScalarWhereInput[]
    NOT?: LogScalarWhereInput | LogScalarWhereInput[]
    id?: IntFilter<"Log"> | number
    action?: StringFilter<"Log"> | string
    tableName?: StringFilter<"Log"> | string
    recordId?: IntNullableFilter<"Log"> | number | null
    userId?: IntNullableFilter<"Log"> | number | null
    timestamp?: DateTimeFilter<"Log"> | Date | string
    details?: StringNullableFilter<"Log"> | string | null
  }

  export type TwoFactorAuthUpsertWithWhereUniqueWithoutUserInput = {
    where: TwoFactorAuthWhereUniqueInput
    update: XOR<TwoFactorAuthUpdateWithoutUserInput, TwoFactorAuthUncheckedUpdateWithoutUserInput>
    create: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput>
  }

  export type TwoFactorAuthUpdateWithWhereUniqueWithoutUserInput = {
    where: TwoFactorAuthWhereUniqueInput
    data: XOR<TwoFactorAuthUpdateWithoutUserInput, TwoFactorAuthUncheckedUpdateWithoutUserInput>
  }

  export type TwoFactorAuthUpdateManyWithWhereWithoutUserInput = {
    where: TwoFactorAuthScalarWhereInput
    data: XOR<TwoFactorAuthUpdateManyMutationInput, TwoFactorAuthUncheckedUpdateManyWithoutUserInput>
  }

  export type TwoFactorAuthScalarWhereInput = {
    AND?: TwoFactorAuthScalarWhereInput | TwoFactorAuthScalarWhereInput[]
    OR?: TwoFactorAuthScalarWhereInput[]
    NOT?: TwoFactorAuthScalarWhereInput | TwoFactorAuthScalarWhereInput[]
    id?: IntFilter<"TwoFactorAuth"> | number
    userId?: IntFilter<"TwoFactorAuth"> | number
    secret?: StringFilter<"TwoFactorAuth"> | string
    isEnabled?: BoolFilter<"TwoFactorAuth"> | boolean
    createdAt?: DateTimeFilter<"TwoFactorAuth"> | Date | string
    updatedAt?: DateTimeFilter<"TwoFactorAuth"> | Date | string
  }

  export type WishlistUpsertWithWhereUniqueWithoutUserInput = {
    where: WishlistWhereUniqueInput
    update: XOR<WishlistUpdateWithoutUserInput, WishlistUncheckedUpdateWithoutUserInput>
    create: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput>
  }

  export type WishlistUpdateWithWhereUniqueWithoutUserInput = {
    where: WishlistWhereUniqueInput
    data: XOR<WishlistUpdateWithoutUserInput, WishlistUncheckedUpdateWithoutUserInput>
  }

  export type WishlistUpdateManyWithWhereWithoutUserInput = {
    where: WishlistScalarWhereInput
    data: XOR<WishlistUpdateManyMutationInput, WishlistUncheckedUpdateManyWithoutUserInput>
  }

  export type WishlistScalarWhereInput = {
    AND?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
    OR?: WishlistScalarWhereInput[]
    NOT?: WishlistScalarWhereInput | WishlistScalarWhereInput[]
    id?: IntFilter<"Wishlist"> | number
    userId?: IntFilter<"Wishlist"> | number
    createdAt?: DateTimeFilter<"Wishlist"> | Date | string
    updatedAt?: DateTimeFilter<"Wishlist"> | Date | string
  }

  export type AbandonedCartUpsertWithWhereUniqueWithoutUserInput = {
    where: AbandonedCartWhereUniqueInput
    update: XOR<AbandonedCartUpdateWithoutUserInput, AbandonedCartUncheckedUpdateWithoutUserInput>
    create: XOR<AbandonedCartCreateWithoutUserInput, AbandonedCartUncheckedCreateWithoutUserInput>
  }

  export type AbandonedCartUpdateWithWhereUniqueWithoutUserInput = {
    where: AbandonedCartWhereUniqueInput
    data: XOR<AbandonedCartUpdateWithoutUserInput, AbandonedCartUncheckedUpdateWithoutUserInput>
  }

  export type AbandonedCartUpdateManyWithWhereWithoutUserInput = {
    where: AbandonedCartScalarWhereInput
    data: XOR<AbandonedCartUpdateManyMutationInput, AbandonedCartUncheckedUpdateManyWithoutUserInput>
  }

  export type AbandonedCartScalarWhereInput = {
    AND?: AbandonedCartScalarWhereInput | AbandonedCartScalarWhereInput[]
    OR?: AbandonedCartScalarWhereInput[]
    NOT?: AbandonedCartScalarWhereInput | AbandonedCartScalarWhereInput[]
    id?: IntFilter<"AbandonedCart"> | number
    userId?: IntFilter<"AbandonedCart"> | number
    abandonedAt?: DateTimeFilter<"AbandonedCart"> | Date | string
  }

  export type UserCreateWithoutAvatarInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAvatarInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAvatarInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAvatarInput, UserUncheckedCreateWithoutAvatarInput>
  }

  export type UserUpsertWithoutAvatarInput = {
    update: XOR<UserUpdateWithoutAvatarInput, UserUncheckedUpdateWithoutAvatarInput>
    create: XOR<UserCreateWithoutAvatarInput, UserUncheckedCreateWithoutAvatarInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAvatarInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAvatarInput, UserUncheckedUpdateWithoutAvatarInput>
  }

  export type UserUpdateWithoutAvatarInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAvatarInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAddressesInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddressesInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddressesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
  }

  export type UserCreateWithoutPrincipalAddressInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPrincipalAddressInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPrincipalAddressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPrincipalAddressInput, UserUncheckedCreateWithoutPrincipalAddressInput>
  }

  export type OrdersCreateWithoutDeliveryAddressInput = {
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    user: UserCreateNestedOneWithoutOrdersInput
    orderStatus: OrderStatusCreateNestedOneWithoutOrdersInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemsCreateNestedManyWithoutOrderInput
    orderHistory?: OrderHistoryCreateNestedManyWithoutOrderInput
    shipping?: ShippingCreateNestedOneWithoutOrderInput
    ReturnExchange?: ReturnExchangeCreateNestedManyWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutDeliveryAddressInput = {
    id?: number
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    userId: number
    orderStatusId: number
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutOrderInput
    orderHistory?: OrderHistoryUncheckedCreateNestedManyWithoutOrderInput
    shipping?: ShippingUncheckedCreateNestedOneWithoutOrderInput
    ReturnExchange?: ReturnExchangeUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutDeliveryAddressInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutDeliveryAddressInput, OrdersUncheckedCreateWithoutDeliveryAddressInput>
  }

  export type OrdersCreateManyDeliveryAddressInputEnvelope = {
    data: OrdersCreateManyDeliveryAddressInput | OrdersCreateManyDeliveryAddressInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAddressesInput = {
    update: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddressesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>
  }

  export type UserUpdateWithoutAddressesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutPrincipalAddressInput = {
    update: XOR<UserUpdateWithoutPrincipalAddressInput, UserUncheckedUpdateWithoutPrincipalAddressInput>
    create: XOR<UserCreateWithoutPrincipalAddressInput, UserUncheckedCreateWithoutPrincipalAddressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPrincipalAddressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPrincipalAddressInput, UserUncheckedUpdateWithoutPrincipalAddressInput>
  }

  export type UserUpdateWithoutPrincipalAddressInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPrincipalAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrdersUpsertWithWhereUniqueWithoutDeliveryAddressInput = {
    where: OrdersWhereUniqueInput
    update: XOR<OrdersUpdateWithoutDeliveryAddressInput, OrdersUncheckedUpdateWithoutDeliveryAddressInput>
    create: XOR<OrdersCreateWithoutDeliveryAddressInput, OrdersUncheckedCreateWithoutDeliveryAddressInput>
  }

  export type OrdersUpdateWithWhereUniqueWithoutDeliveryAddressInput = {
    where: OrdersWhereUniqueInput
    data: XOR<OrdersUpdateWithoutDeliveryAddressInput, OrdersUncheckedUpdateWithoutDeliveryAddressInput>
  }

  export type OrdersUpdateManyWithWhereWithoutDeliveryAddressInput = {
    where: OrdersScalarWhereInput
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyWithoutDeliveryAddressInput>
  }

  export type UserCreateWithoutUsedCouponsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUsedCouponsInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUsedCouponsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsedCouponsInput, UserUncheckedCreateWithoutUsedCouponsInput>
  }

  export type CouponsCreateWithoutUsedCouponsInput = {
    code: string
    expirationDate: Date | string
    percentageDiscount: number
    discountValue: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoresCreateNestedOneWithoutCouponsInput
  }

  export type CouponsUncheckedCreateWithoutUsedCouponsInput = {
    id?: number
    code: string
    expirationDate: Date | string
    percentageDiscount: number
    discountValue: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId: number
  }

  export type CouponsCreateOrConnectWithoutUsedCouponsInput = {
    where: CouponsWhereUniqueInput
    create: XOR<CouponsCreateWithoutUsedCouponsInput, CouponsUncheckedCreateWithoutUsedCouponsInput>
  }

  export type OrdersCreateWithoutUsedCouponsInput = {
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    user: UserCreateNestedOneWithoutOrdersInput
    orderStatus: OrderStatusCreateNestedOneWithoutOrdersInput
    deliveryAddress: AddressesCreateNestedOneWithoutOrderInput
    orderItems?: OrderItemsCreateNestedManyWithoutOrderInput
    orderHistory?: OrderHistoryCreateNestedManyWithoutOrderInput
    shipping?: ShippingCreateNestedOneWithoutOrderInput
    ReturnExchange?: ReturnExchangeCreateNestedManyWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutUsedCouponsInput = {
    id?: number
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    userId: number
    orderStatusId: number
    deliveryAddressId: number
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutOrderInput
    orderHistory?: OrderHistoryUncheckedCreateNestedManyWithoutOrderInput
    shipping?: ShippingUncheckedCreateNestedOneWithoutOrderInput
    ReturnExchange?: ReturnExchangeUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutUsedCouponsInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutUsedCouponsInput, OrdersUncheckedCreateWithoutUsedCouponsInput>
  }

  export type UserUpsertWithoutUsedCouponsInput = {
    update: XOR<UserUpdateWithoutUsedCouponsInput, UserUncheckedUpdateWithoutUsedCouponsInput>
    create: XOR<UserCreateWithoutUsedCouponsInput, UserUncheckedCreateWithoutUsedCouponsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUsedCouponsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUsedCouponsInput, UserUncheckedUpdateWithoutUsedCouponsInput>
  }

  export type UserUpdateWithoutUsedCouponsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUsedCouponsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CouponsUpsertWithoutUsedCouponsInput = {
    update: XOR<CouponsUpdateWithoutUsedCouponsInput, CouponsUncheckedUpdateWithoutUsedCouponsInput>
    create: XOR<CouponsCreateWithoutUsedCouponsInput, CouponsUncheckedCreateWithoutUsedCouponsInput>
    where?: CouponsWhereInput
  }

  export type CouponsUpdateToOneWithWhereWithoutUsedCouponsInput = {
    where?: CouponsWhereInput
    data: XOR<CouponsUpdateWithoutUsedCouponsInput, CouponsUncheckedUpdateWithoutUsedCouponsInput>
  }

  export type CouponsUpdateWithoutUsedCouponsInput = {
    code?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentageDiscount?: IntFieldUpdateOperationsInput | number
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoresUpdateOneRequiredWithoutCouponsNestedInput
  }

  export type CouponsUncheckedUpdateWithoutUsedCouponsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentageDiscount?: IntFieldUpdateOperationsInput | number
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type OrdersUpsertWithoutUsedCouponsInput = {
    update: XOR<OrdersUpdateWithoutUsedCouponsInput, OrdersUncheckedUpdateWithoutUsedCouponsInput>
    create: XOR<OrdersCreateWithoutUsedCouponsInput, OrdersUncheckedCreateWithoutUsedCouponsInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutUsedCouponsInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutUsedCouponsInput, OrdersUncheckedUpdateWithoutUsedCouponsInput>
  }

  export type OrdersUpdateWithoutUsedCouponsInput = {
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    orderStatus?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    deliveryAddress?: AddressesUpdateOneRequiredWithoutOrderNestedInput
    orderItems?: OrderItemsUpdateManyWithoutOrderNestedInput
    orderHistory?: OrderHistoryUpdateManyWithoutOrderNestedInput
    shipping?: ShippingUpdateOneWithoutOrderNestedInput
    ReturnExchange?: ReturnExchangeUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutUsedCouponsInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    orderStatusId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: IntFieldUpdateOperationsInput | number
    orderItems?: OrderItemsUncheckedUpdateManyWithoutOrderNestedInput
    orderHistory?: OrderHistoryUncheckedUpdateManyWithoutOrderNestedInput
    shipping?: ShippingUncheckedUpdateOneWithoutOrderNestedInput
    ReturnExchange?: ReturnExchangeUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserCreateWithoutStoreInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStoreInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStoreInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoreInput, UserUncheckedCreateWithoutStoreInput>
  }

  export type AvatarStoreCreateWithoutStoreAvatarInput = {
    url: string
    publicId: string
  }

  export type AvatarStoreUncheckedCreateWithoutStoreAvatarInput = {
    id?: number
    url: string
    publicId: string
  }

  export type AvatarStoreCreateOrConnectWithoutStoreAvatarInput = {
    where: AvatarStoreWhereUniqueInput
    create: XOR<AvatarStoreCreateWithoutStoreAvatarInput, AvatarStoreUncheckedCreateWithoutStoreAvatarInput>
  }

  export type ProductsCreateWithoutStoreInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    inventory?: InventoryCreateNestedOneWithoutProductInput
    images?: ProductImagesCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsCreateNestedManyWithoutProductInput
    promotions?: PromotionCreateNestedManyWithoutProductsInput
    cartItem?: CartItemsCreateNestedManyWithoutProductInput
    orderItems?: OrderItemsCreateNestedManyWithoutProductInput
    wishlists?: WishlistCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutStoreInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    images?: ProductImagesUncheckedCreateNestedManyWithoutProductInput
    category?: CategoryUncheckedCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutProductInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutProductsInput
    cartItem?: CartItemsUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutProductInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutStoreInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutStoreInput, ProductsUncheckedCreateWithoutStoreInput>
  }

  export type ProductsCreateManyStoreInputEnvelope = {
    data: ProductsCreateManyStoreInput | ProductsCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type StoreAvaliationsCreateWithoutStoreInput = {
    note: number
    avaliationDate?: Date | string
    comment?: string | null
    user: UserCreateNestedOneWithoutStoreAvaliationsInput
    images?: StoreAvaliationImagesCreateNestedManyWithoutStoreAvaliationInput
  }

  export type StoreAvaliationsUncheckedCreateWithoutStoreInput = {
    id?: number
    userId: number
    note: number
    avaliationDate?: Date | string
    comment?: string | null
    images?: StoreAvaliationImagesUncheckedCreateNestedManyWithoutStoreAvaliationInput
  }

  export type StoreAvaliationsCreateOrConnectWithoutStoreInput = {
    where: StoreAvaliationsWhereUniqueInput
    create: XOR<StoreAvaliationsCreateWithoutStoreInput, StoreAvaliationsUncheckedCreateWithoutStoreInput>
  }

  export type StoreAvaliationsCreateManyStoreInputEnvelope = {
    data: StoreAvaliationsCreateManyStoreInput | StoreAvaliationsCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type CouponsCreateWithoutStoreInput = {
    code: string
    expirationDate: Date | string
    percentageDiscount: number
    discountValue: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutCouponInput
  }

  export type CouponsUncheckedCreateWithoutStoreInput = {
    id?: number
    code: string
    expirationDate: Date | string
    percentageDiscount: number
    discountValue: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponsCreateOrConnectWithoutStoreInput = {
    where: CouponsWhereUniqueInput
    create: XOR<CouponsCreateWithoutStoreInput, CouponsUncheckedCreateWithoutStoreInput>
  }

  export type CouponsCreateManyStoreInputEnvelope = {
    data: CouponsCreateManyStoreInput | CouponsCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutStoreInput = {
    user: UserCreateNestedOneWithoutChatInput
    messages?: chatMessagesCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutStoreInput = {
    id?: number
    userId: number
    messages?: chatMessagesUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutStoreInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutStoreInput, ChatUncheckedCreateWithoutStoreInput>
  }

  export type ChatCreateManyStoreInputEnvelope = {
    data: ChatCreateManyStoreInput | ChatCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type chatMessagesCreateWithoutSenderStoreInput = {
    content: string
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
    chat: ChatCreateNestedOneWithoutMessagesInput
    senderUser?: UserCreateNestedOneWithoutSentMessagesInput
    receiverUser?: UserCreateNestedOneWithoutReceivedMessagesInput
    receiverStore?: StoresCreateNestedOneWithoutReceivedMessagesInput
    image?: MessageImagesCreateNestedOneWithoutMessageImageInput
  }

  export type chatMessagesUncheckedCreateWithoutSenderStoreInput = {
    id?: number
    content: string
    chatId: number
    senderUserId?: number | null
    receiverUserId?: number | null
    receiverStoreId?: number | null
    imageId?: number | null
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
  }

  export type chatMessagesCreateOrConnectWithoutSenderStoreInput = {
    where: chatMessagesWhereUniqueInput
    create: XOR<chatMessagesCreateWithoutSenderStoreInput, chatMessagesUncheckedCreateWithoutSenderStoreInput>
  }

  export type chatMessagesCreateManySenderStoreInputEnvelope = {
    data: chatMessagesCreateManySenderStoreInput | chatMessagesCreateManySenderStoreInput[]
    skipDuplicates?: boolean
  }

  export type chatMessagesCreateWithoutReceiverStoreInput = {
    content: string
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
    chat: ChatCreateNestedOneWithoutMessagesInput
    senderUser?: UserCreateNestedOneWithoutSentMessagesInput
    senderStore?: StoresCreateNestedOneWithoutSentMessagesInput
    receiverUser?: UserCreateNestedOneWithoutReceivedMessagesInput
    image?: MessageImagesCreateNestedOneWithoutMessageImageInput
  }

  export type chatMessagesUncheckedCreateWithoutReceiverStoreInput = {
    id?: number
    content: string
    chatId: number
    senderUserId?: number | null
    senderStoreId?: number | null
    receiverUserId?: number | null
    imageId?: number | null
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
  }

  export type chatMessagesCreateOrConnectWithoutReceiverStoreInput = {
    where: chatMessagesWhereUniqueInput
    create: XOR<chatMessagesCreateWithoutReceiverStoreInput, chatMessagesUncheckedCreateWithoutReceiverStoreInput>
  }

  export type chatMessagesCreateManyReceiverStoreInputEnvelope = {
    data: chatMessagesCreateManyReceiverStoreInput | chatMessagesCreateManyReceiverStoreInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemsCreateWithoutStoreInput = {
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    order: OrdersCreateNestedOneWithoutOrderItemsInput
    product: ProductsCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemsUncheckedCreateWithoutStoreInput = {
    id?: number
    orderId: number
    productId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
  }

  export type OrderItemsCreateOrConnectWithoutStoreInput = {
    where: OrderItemsWhereUniqueInput
    create: XOR<OrderItemsCreateWithoutStoreInput, OrderItemsUncheckedCreateWithoutStoreInput>
  }

  export type OrderItemsCreateManyStoreInputEnvelope = {
    data: OrderItemsCreateManyStoreInput | OrderItemsCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type PromotionCreateWithoutStoreInput = {
    code: string
    description: string
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductsCreateNestedManyWithoutPromotionsInput
  }

  export type PromotionUncheckedCreateWithoutStoreInput = {
    id?: number
    code: string
    description: string
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductsUncheckedCreateNestedManyWithoutPromotionsInput
  }

  export type PromotionCreateOrConnectWithoutStoreInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutStoreInput, PromotionUncheckedCreateWithoutStoreInput>
  }

  export type PromotionCreateManyStoreInputEnvelope = {
    data: PromotionCreateManyStoreInput | PromotionCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStoreInput = {
    update: XOR<UserUpdateWithoutStoreInput, UserUncheckedUpdateWithoutStoreInput>
    create: XOR<UserCreateWithoutStoreInput, UserUncheckedCreateWithoutStoreInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStoreInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStoreInput, UserUncheckedUpdateWithoutStoreInput>
  }

  export type UserUpdateWithoutStoreInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AvatarStoreUpsertWithoutStoreAvatarInput = {
    update: XOR<AvatarStoreUpdateWithoutStoreAvatarInput, AvatarStoreUncheckedUpdateWithoutStoreAvatarInput>
    create: XOR<AvatarStoreCreateWithoutStoreAvatarInput, AvatarStoreUncheckedCreateWithoutStoreAvatarInput>
    where?: AvatarStoreWhereInput
  }

  export type AvatarStoreUpdateToOneWithWhereWithoutStoreAvatarInput = {
    where?: AvatarStoreWhereInput
    data: XOR<AvatarStoreUpdateWithoutStoreAvatarInput, AvatarStoreUncheckedUpdateWithoutStoreAvatarInput>
  }

  export type AvatarStoreUpdateWithoutStoreAvatarInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type AvatarStoreUncheckedUpdateWithoutStoreAvatarInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductsUpsertWithWhereUniqueWithoutStoreInput = {
    where: ProductsWhereUniqueInput
    update: XOR<ProductsUpdateWithoutStoreInput, ProductsUncheckedUpdateWithoutStoreInput>
    create: XOR<ProductsCreateWithoutStoreInput, ProductsUncheckedCreateWithoutStoreInput>
  }

  export type ProductsUpdateWithWhereUniqueWithoutStoreInput = {
    where: ProductsWhereUniqueInput
    data: XOR<ProductsUpdateWithoutStoreInput, ProductsUncheckedUpdateWithoutStoreInput>
  }

  export type ProductsUpdateManyWithWhereWithoutStoreInput = {
    where: ProductsScalarWhereInput
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyWithoutStoreInput>
  }

  export type ProductsScalarWhereInput = {
    AND?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
    OR?: ProductsScalarWhereInput[]
    NOT?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
    id?: IntFilter<"Products"> | number
    storeId?: IntFilter<"Products"> | number
    created_at?: DateTimeFilter<"Products"> | Date | string
    updated_at?: DateTimeFilter<"Products"> | Date | string
    name?: StringFilter<"Products"> | string
    price?: DecimalFilter<"Products"> | Decimal | DecimalJsLike | number | string
  }

  export type StoreAvaliationsUpsertWithWhereUniqueWithoutStoreInput = {
    where: StoreAvaliationsWhereUniqueInput
    update: XOR<StoreAvaliationsUpdateWithoutStoreInput, StoreAvaliationsUncheckedUpdateWithoutStoreInput>
    create: XOR<StoreAvaliationsCreateWithoutStoreInput, StoreAvaliationsUncheckedCreateWithoutStoreInput>
  }

  export type StoreAvaliationsUpdateWithWhereUniqueWithoutStoreInput = {
    where: StoreAvaliationsWhereUniqueInput
    data: XOR<StoreAvaliationsUpdateWithoutStoreInput, StoreAvaliationsUncheckedUpdateWithoutStoreInput>
  }

  export type StoreAvaliationsUpdateManyWithWhereWithoutStoreInput = {
    where: StoreAvaliationsScalarWhereInput
    data: XOR<StoreAvaliationsUpdateManyMutationInput, StoreAvaliationsUncheckedUpdateManyWithoutStoreInput>
  }

  export type CouponsUpsertWithWhereUniqueWithoutStoreInput = {
    where: CouponsWhereUniqueInput
    update: XOR<CouponsUpdateWithoutStoreInput, CouponsUncheckedUpdateWithoutStoreInput>
    create: XOR<CouponsCreateWithoutStoreInput, CouponsUncheckedCreateWithoutStoreInput>
  }

  export type CouponsUpdateWithWhereUniqueWithoutStoreInput = {
    where: CouponsWhereUniqueInput
    data: XOR<CouponsUpdateWithoutStoreInput, CouponsUncheckedUpdateWithoutStoreInput>
  }

  export type CouponsUpdateManyWithWhereWithoutStoreInput = {
    where: CouponsScalarWhereInput
    data: XOR<CouponsUpdateManyMutationInput, CouponsUncheckedUpdateManyWithoutStoreInput>
  }

  export type CouponsScalarWhereInput = {
    AND?: CouponsScalarWhereInput | CouponsScalarWhereInput[]
    OR?: CouponsScalarWhereInput[]
    NOT?: CouponsScalarWhereInput | CouponsScalarWhereInput[]
    id?: IntFilter<"Coupons"> | number
    code?: StringFilter<"Coupons"> | string
    expirationDate?: DateTimeFilter<"Coupons"> | Date | string
    percentageDiscount?: IntFilter<"Coupons"> | number
    discountValue?: DecimalFilter<"Coupons"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Coupons"> | Date | string
    updatedAt?: DateTimeFilter<"Coupons"> | Date | string
    storeId?: IntFilter<"Coupons"> | number
  }

  export type ChatUpsertWithWhereUniqueWithoutStoreInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutStoreInput, ChatUncheckedUpdateWithoutStoreInput>
    create: XOR<ChatCreateWithoutStoreInput, ChatUncheckedCreateWithoutStoreInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutStoreInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutStoreInput, ChatUncheckedUpdateWithoutStoreInput>
  }

  export type ChatUpdateManyWithWhereWithoutStoreInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutStoreInput>
  }

  export type chatMessagesUpsertWithWhereUniqueWithoutSenderStoreInput = {
    where: chatMessagesWhereUniqueInput
    update: XOR<chatMessagesUpdateWithoutSenderStoreInput, chatMessagesUncheckedUpdateWithoutSenderStoreInput>
    create: XOR<chatMessagesCreateWithoutSenderStoreInput, chatMessagesUncheckedCreateWithoutSenderStoreInput>
  }

  export type chatMessagesUpdateWithWhereUniqueWithoutSenderStoreInput = {
    where: chatMessagesWhereUniqueInput
    data: XOR<chatMessagesUpdateWithoutSenderStoreInput, chatMessagesUncheckedUpdateWithoutSenderStoreInput>
  }

  export type chatMessagesUpdateManyWithWhereWithoutSenderStoreInput = {
    where: chatMessagesScalarWhereInput
    data: XOR<chatMessagesUpdateManyMutationInput, chatMessagesUncheckedUpdateManyWithoutSenderStoreInput>
  }

  export type chatMessagesUpsertWithWhereUniqueWithoutReceiverStoreInput = {
    where: chatMessagesWhereUniqueInput
    update: XOR<chatMessagesUpdateWithoutReceiverStoreInput, chatMessagesUncheckedUpdateWithoutReceiverStoreInput>
    create: XOR<chatMessagesCreateWithoutReceiverStoreInput, chatMessagesUncheckedCreateWithoutReceiverStoreInput>
  }

  export type chatMessagesUpdateWithWhereUniqueWithoutReceiverStoreInput = {
    where: chatMessagesWhereUniqueInput
    data: XOR<chatMessagesUpdateWithoutReceiverStoreInput, chatMessagesUncheckedUpdateWithoutReceiverStoreInput>
  }

  export type chatMessagesUpdateManyWithWhereWithoutReceiverStoreInput = {
    where: chatMessagesScalarWhereInput
    data: XOR<chatMessagesUpdateManyMutationInput, chatMessagesUncheckedUpdateManyWithoutReceiverStoreInput>
  }

  export type OrderItemsUpsertWithWhereUniqueWithoutStoreInput = {
    where: OrderItemsWhereUniqueInput
    update: XOR<OrderItemsUpdateWithoutStoreInput, OrderItemsUncheckedUpdateWithoutStoreInput>
    create: XOR<OrderItemsCreateWithoutStoreInput, OrderItemsUncheckedCreateWithoutStoreInput>
  }

  export type OrderItemsUpdateWithWhereUniqueWithoutStoreInput = {
    where: OrderItemsWhereUniqueInput
    data: XOR<OrderItemsUpdateWithoutStoreInput, OrderItemsUncheckedUpdateWithoutStoreInput>
  }

  export type OrderItemsUpdateManyWithWhereWithoutStoreInput = {
    where: OrderItemsScalarWhereInput
    data: XOR<OrderItemsUpdateManyMutationInput, OrderItemsUncheckedUpdateManyWithoutStoreInput>
  }

  export type OrderItemsScalarWhereInput = {
    AND?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
    OR?: OrderItemsScalarWhereInput[]
    NOT?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
    id?: IntFilter<"OrderItems"> | number
    orderId?: IntFilter<"OrderItems"> | number
    productId?: IntFilter<"OrderItems"> | number
    storeId?: IntFilter<"OrderItems"> | number
    quantity?: IntFilter<"OrderItems"> | number
    price?: DecimalFilter<"OrderItems"> | Decimal | DecimalJsLike | number | string
  }

  export type PromotionUpsertWithWhereUniqueWithoutStoreInput = {
    where: PromotionWhereUniqueInput
    update: XOR<PromotionUpdateWithoutStoreInput, PromotionUncheckedUpdateWithoutStoreInput>
    create: XOR<PromotionCreateWithoutStoreInput, PromotionUncheckedCreateWithoutStoreInput>
  }

  export type PromotionUpdateWithWhereUniqueWithoutStoreInput = {
    where: PromotionWhereUniqueInput
    data: XOR<PromotionUpdateWithoutStoreInput, PromotionUncheckedUpdateWithoutStoreInput>
  }

  export type PromotionUpdateManyWithWhereWithoutStoreInput = {
    where: PromotionScalarWhereInput
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyWithoutStoreInput>
  }

  export type PromotionScalarWhereInput = {
    AND?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
    OR?: PromotionScalarWhereInput[]
    NOT?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
    id?: IntFilter<"Promotion"> | number
    code?: StringFilter<"Promotion"> | string
    description?: StringFilter<"Promotion"> | string
    discountType?: StringFilter<"Promotion"> | string
    discountValue?: DecimalFilter<"Promotion"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    storeId?: IntFilter<"Promotion"> | number
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
  }

  export type StoresCreateWithoutAvatarInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    user: UserCreateNestedOneWithoutStoreInput
    product?: ProductsCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsCreateNestedManyWithoutStoreInput
    coupons?: CouponsCreateNestedManyWithoutStoreInput
    chat?: ChatCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoreInput
    promotions?: PromotionCreateNestedManyWithoutStoreInput
  }

  export type StoresUncheckedCreateWithoutAvatarInput = {
    id?: number
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    product?: ProductsUncheckedCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutStoreInput
    coupons?: CouponsUncheckedCreateNestedManyWithoutStoreInput
    chat?: ChatUncheckedCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoreInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoresCreateOrConnectWithoutAvatarInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutAvatarInput, StoresUncheckedCreateWithoutAvatarInput>
  }

  export type StoresUpsertWithoutAvatarInput = {
    update: XOR<StoresUpdateWithoutAvatarInput, StoresUncheckedUpdateWithoutAvatarInput>
    create: XOR<StoresCreateWithoutAvatarInput, StoresUncheckedCreateWithoutAvatarInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutAvatarInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutAvatarInput, StoresUncheckedUpdateWithoutAvatarInput>
  }

  export type StoresUpdateWithoutAvatarInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStoreNestedInput
    product?: ProductsUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUpdateManyWithoutStoreNestedInput
    chat?: ChatUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUpdateManyWithoutStoreNestedInput
  }

  export type StoresUncheckedUpdateWithoutAvatarInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductsUncheckedUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUncheckedUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUncheckedUpdateManyWithoutStoreNestedInput
    chat?: ChatUncheckedUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type UserCreateWithoutStoreAvaliationsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStoreAvaliationsInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStoreAvaliationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoreAvaliationsInput, UserUncheckedCreateWithoutStoreAvaliationsInput>
  }

  export type StoresCreateWithoutAvaliationsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    user: UserCreateNestedOneWithoutStoreInput
    avatar?: AvatarStoreCreateNestedOneWithoutStoreAvatarInput
    product?: ProductsCreateNestedManyWithoutStoreInput
    coupons?: CouponsCreateNestedManyWithoutStoreInput
    chat?: ChatCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoreInput
    promotions?: PromotionCreateNestedManyWithoutStoreInput
  }

  export type StoresUncheckedCreateWithoutAvaliationsInput = {
    id?: number
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    avatarId?: number | null
    product?: ProductsUncheckedCreateNestedManyWithoutStoreInput
    coupons?: CouponsUncheckedCreateNestedManyWithoutStoreInput
    chat?: ChatUncheckedCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoreInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoresCreateOrConnectWithoutAvaliationsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutAvaliationsInput, StoresUncheckedCreateWithoutAvaliationsInput>
  }

  export type StoreAvaliationImagesCreateWithoutStoreAvaliationInput = {
    url: string
    publicId: string
  }

  export type StoreAvaliationImagesUncheckedCreateWithoutStoreAvaliationInput = {
    id?: number
    url: string
    publicId: string
  }

  export type StoreAvaliationImagesCreateOrConnectWithoutStoreAvaliationInput = {
    where: StoreAvaliationImagesWhereUniqueInput
    create: XOR<StoreAvaliationImagesCreateWithoutStoreAvaliationInput, StoreAvaliationImagesUncheckedCreateWithoutStoreAvaliationInput>
  }

  export type StoreAvaliationImagesCreateManyStoreAvaliationInputEnvelope = {
    data: StoreAvaliationImagesCreateManyStoreAvaliationInput | StoreAvaliationImagesCreateManyStoreAvaliationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStoreAvaliationsInput = {
    update: XOR<UserUpdateWithoutStoreAvaliationsInput, UserUncheckedUpdateWithoutStoreAvaliationsInput>
    create: XOR<UserCreateWithoutStoreAvaliationsInput, UserUncheckedCreateWithoutStoreAvaliationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStoreAvaliationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStoreAvaliationsInput, UserUncheckedUpdateWithoutStoreAvaliationsInput>
  }

  export type UserUpdateWithoutStoreAvaliationsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStoreAvaliationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StoresUpsertWithoutAvaliationsInput = {
    update: XOR<StoresUpdateWithoutAvaliationsInput, StoresUncheckedUpdateWithoutAvaliationsInput>
    create: XOR<StoresCreateWithoutAvaliationsInput, StoresUncheckedCreateWithoutAvaliationsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutAvaliationsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutAvaliationsInput, StoresUncheckedUpdateWithoutAvaliationsInput>
  }

  export type StoresUpdateWithoutAvaliationsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStoreNestedInput
    avatar?: AvatarStoreUpdateOneWithoutStoreAvatarNestedInput
    product?: ProductsUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUpdateManyWithoutStoreNestedInput
    chat?: ChatUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUpdateManyWithoutStoreNestedInput
  }

  export type StoresUncheckedUpdateWithoutAvaliationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    product?: ProductsUncheckedUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUncheckedUpdateManyWithoutStoreNestedInput
    chat?: ChatUncheckedUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreAvaliationImagesUpsertWithWhereUniqueWithoutStoreAvaliationInput = {
    where: StoreAvaliationImagesWhereUniqueInput
    update: XOR<StoreAvaliationImagesUpdateWithoutStoreAvaliationInput, StoreAvaliationImagesUncheckedUpdateWithoutStoreAvaliationInput>
    create: XOR<StoreAvaliationImagesCreateWithoutStoreAvaliationInput, StoreAvaliationImagesUncheckedCreateWithoutStoreAvaliationInput>
  }

  export type StoreAvaliationImagesUpdateWithWhereUniqueWithoutStoreAvaliationInput = {
    where: StoreAvaliationImagesWhereUniqueInput
    data: XOR<StoreAvaliationImagesUpdateWithoutStoreAvaliationInput, StoreAvaliationImagesUncheckedUpdateWithoutStoreAvaliationInput>
  }

  export type StoreAvaliationImagesUpdateManyWithWhereWithoutStoreAvaliationInput = {
    where: StoreAvaliationImagesScalarWhereInput
    data: XOR<StoreAvaliationImagesUpdateManyMutationInput, StoreAvaliationImagesUncheckedUpdateManyWithoutStoreAvaliationInput>
  }

  export type StoreAvaliationImagesScalarWhereInput = {
    AND?: StoreAvaliationImagesScalarWhereInput | StoreAvaliationImagesScalarWhereInput[]
    OR?: StoreAvaliationImagesScalarWhereInput[]
    NOT?: StoreAvaliationImagesScalarWhereInput | StoreAvaliationImagesScalarWhereInput[]
    id?: IntFilter<"StoreAvaliationImages"> | number
    url?: StringFilter<"StoreAvaliationImages"> | string
    publicId?: StringFilter<"StoreAvaliationImages"> | string
    storeAvaliationId?: IntNullableFilter<"StoreAvaliationImages"> | number | null
  }

  export type StoreAvaliationsCreateWithoutImagesInput = {
    note: number
    avaliationDate?: Date | string
    comment?: string | null
    user: UserCreateNestedOneWithoutStoreAvaliationsInput
    store: StoresCreateNestedOneWithoutAvaliationsInput
  }

  export type StoreAvaliationsUncheckedCreateWithoutImagesInput = {
    id?: number
    userId: number
    storeId: number
    note: number
    avaliationDate?: Date | string
    comment?: string | null
  }

  export type StoreAvaliationsCreateOrConnectWithoutImagesInput = {
    where: StoreAvaliationsWhereUniqueInput
    create: XOR<StoreAvaliationsCreateWithoutImagesInput, StoreAvaliationsUncheckedCreateWithoutImagesInput>
  }

  export type StoreAvaliationsUpsertWithoutImagesInput = {
    update: XOR<StoreAvaliationsUpdateWithoutImagesInput, StoreAvaliationsUncheckedUpdateWithoutImagesInput>
    create: XOR<StoreAvaliationsCreateWithoutImagesInput, StoreAvaliationsUncheckedCreateWithoutImagesInput>
    where?: StoreAvaliationsWhereInput
  }

  export type StoreAvaliationsUpdateToOneWithWhereWithoutImagesInput = {
    where?: StoreAvaliationsWhereInput
    data: XOR<StoreAvaliationsUpdateWithoutImagesInput, StoreAvaliationsUncheckedUpdateWithoutImagesInput>
  }

  export type StoreAvaliationsUpdateWithoutImagesInput = {
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStoreAvaliationsNestedInput
    store?: StoresUpdateOneRequiredWithoutAvaliationsNestedInput
  }

  export type StoreAvaliationsUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoresCreateWithoutCouponsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    user: UserCreateNestedOneWithoutStoreInput
    avatar?: AvatarStoreCreateNestedOneWithoutStoreAvatarInput
    product?: ProductsCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsCreateNestedManyWithoutStoreInput
    chat?: ChatCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoreInput
    promotions?: PromotionCreateNestedManyWithoutStoreInput
  }

  export type StoresUncheckedCreateWithoutCouponsInput = {
    id?: number
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    avatarId?: number | null
    product?: ProductsUncheckedCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutStoreInput
    chat?: ChatUncheckedCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoreInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoresCreateOrConnectWithoutCouponsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutCouponsInput, StoresUncheckedCreateWithoutCouponsInput>
  }

  export type UserUsedCouponsCreateWithoutCouponInput = {
    usedAt?: Date | string
    user: UserCreateNestedOneWithoutUsedCouponsInput
    order?: OrdersCreateNestedOneWithoutUsedCouponsInput
  }

  export type UserUsedCouponsUncheckedCreateWithoutCouponInput = {
    id?: number
    userId: number
    usedAt?: Date | string
    orderId?: number | null
  }

  export type UserUsedCouponsCreateOrConnectWithoutCouponInput = {
    where: UserUsedCouponsWhereUniqueInput
    create: XOR<UserUsedCouponsCreateWithoutCouponInput, UserUsedCouponsUncheckedCreateWithoutCouponInput>
  }

  export type UserUsedCouponsCreateManyCouponInputEnvelope = {
    data: UserUsedCouponsCreateManyCouponInput | UserUsedCouponsCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type StoresUpsertWithoutCouponsInput = {
    update: XOR<StoresUpdateWithoutCouponsInput, StoresUncheckedUpdateWithoutCouponsInput>
    create: XOR<StoresCreateWithoutCouponsInput, StoresUncheckedCreateWithoutCouponsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutCouponsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutCouponsInput, StoresUncheckedUpdateWithoutCouponsInput>
  }

  export type StoresUpdateWithoutCouponsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStoreNestedInput
    avatar?: AvatarStoreUpdateOneWithoutStoreAvatarNestedInput
    product?: ProductsUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUpdateManyWithoutStoreNestedInput
    chat?: ChatUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUpdateManyWithoutStoreNestedInput
  }

  export type StoresUncheckedUpdateWithoutCouponsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    product?: ProductsUncheckedUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUncheckedUpdateManyWithoutStoreNestedInput
    chat?: ChatUncheckedUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type UserUsedCouponsUpsertWithWhereUniqueWithoutCouponInput = {
    where: UserUsedCouponsWhereUniqueInput
    update: XOR<UserUsedCouponsUpdateWithoutCouponInput, UserUsedCouponsUncheckedUpdateWithoutCouponInput>
    create: XOR<UserUsedCouponsCreateWithoutCouponInput, UserUsedCouponsUncheckedCreateWithoutCouponInput>
  }

  export type UserUsedCouponsUpdateWithWhereUniqueWithoutCouponInput = {
    where: UserUsedCouponsWhereUniqueInput
    data: XOR<UserUsedCouponsUpdateWithoutCouponInput, UserUsedCouponsUncheckedUpdateWithoutCouponInput>
  }

  export type UserUsedCouponsUpdateManyWithWhereWithoutCouponInput = {
    where: UserUsedCouponsScalarWhereInput
    data: XOR<UserUsedCouponsUpdateManyMutationInput, UserUsedCouponsUncheckedUpdateManyWithoutCouponInput>
  }

  export type StoresCreateWithoutProductInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    user: UserCreateNestedOneWithoutStoreInput
    avatar?: AvatarStoreCreateNestedOneWithoutStoreAvatarInput
    avaliations?: StoreAvaliationsCreateNestedManyWithoutStoreInput
    coupons?: CouponsCreateNestedManyWithoutStoreInput
    chat?: ChatCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoreInput
    promotions?: PromotionCreateNestedManyWithoutStoreInput
  }

  export type StoresUncheckedCreateWithoutProductInput = {
    id?: number
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    avatarId?: number | null
    avaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutStoreInput
    coupons?: CouponsUncheckedCreateNestedManyWithoutStoreInput
    chat?: ChatUncheckedCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoreInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoresCreateOrConnectWithoutProductInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutProductInput, StoresUncheckedCreateWithoutProductInput>
  }

  export type InventoryCreateWithoutProductInput = {
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUncheckedCreateWithoutProductInput = {
    id?: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryCreateOrConnectWithoutProductInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
  }

  export type ProductImagesCreateWithoutProductInput = {
    url: string
    publicId: string
  }

  export type ProductImagesUncheckedCreateWithoutProductInput = {
    id?: number
    url: string
    publicId: string
  }

  export type ProductImagesCreateOrConnectWithoutProductInput = {
    where: ProductImagesWhereUniqueInput
    create: XOR<ProductImagesCreateWithoutProductInput, ProductImagesUncheckedCreateWithoutProductInput>
  }

  export type ProductImagesCreateManyProductInputEnvelope = {
    data: ProductImagesCreateManyProductInput | ProductImagesCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutProductInput = {
    name: string
  }

  export type CategoryUncheckedCreateWithoutProductInput = {
    id?: number
    name: string
  }

  export type CategoryCreateOrConnectWithoutProductInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductInput, CategoryUncheckedCreateWithoutProductInput>
  }

  export type ProductAvaliationsCreateWithoutProductInput = {
    note: number
    avaliationDate?: Date | string
    comment?: string | null
    user: UserCreateNestedOneWithoutProductAvaliationsInput
    images?: ProductAvaliationImagesCreateNestedManyWithoutProductAvaliationInput
  }

  export type ProductAvaliationsUncheckedCreateWithoutProductInput = {
    id?: number
    userId: number
    note: number
    avaliationDate?: Date | string
    comment?: string | null
    images?: ProductAvaliationImagesUncheckedCreateNestedManyWithoutProductAvaliationInput
  }

  export type ProductAvaliationsCreateOrConnectWithoutProductInput = {
    where: ProductAvaliationsWhereUniqueInput
    create: XOR<ProductAvaliationsCreateWithoutProductInput, ProductAvaliationsUncheckedCreateWithoutProductInput>
  }

  export type ProductAvaliationsCreateManyProductInputEnvelope = {
    data: ProductAvaliationsCreateManyProductInput | ProductAvaliationsCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type PromotionCreateWithoutProductsInput = {
    code: string
    description: string
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoresCreateNestedOneWithoutPromotionsInput
  }

  export type PromotionUncheckedCreateWithoutProductsInput = {
    id?: number
    code: string
    description: string
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    storeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionCreateOrConnectWithoutProductsInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutProductsInput, PromotionUncheckedCreateWithoutProductsInput>
  }

  export type CartItemsCreateWithoutProductInput = {
    quantidade: number
    cart: CartCreateNestedOneWithoutCartItemsInput
    AbandonedCart?: AbandonedCartCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemsUncheckedCreateWithoutProductInput = {
    id?: number
    cartId: number
    quantidade: number
    abandonedCartId?: number | null
  }

  export type CartItemsCreateOrConnectWithoutProductInput = {
    where: CartItemsWhereUniqueInput
    create: XOR<CartItemsCreateWithoutProductInput, CartItemsUncheckedCreateWithoutProductInput>
  }

  export type CartItemsCreateManyProductInputEnvelope = {
    data: CartItemsCreateManyProductInput | CartItemsCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemsCreateWithoutProductInput = {
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    order: OrdersCreateNestedOneWithoutOrderItemsInput
    store: StoresCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemsUncheckedCreateWithoutProductInput = {
    id?: number
    orderId: number
    storeId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
  }

  export type OrderItemsCreateOrConnectWithoutProductInput = {
    where: OrderItemsWhereUniqueInput
    create: XOR<OrderItemsCreateWithoutProductInput, OrderItemsUncheckedCreateWithoutProductInput>
  }

  export type OrderItemsCreateManyProductInputEnvelope = {
    data: OrderItemsCreateManyProductInput | OrderItemsCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type WishlistCreateWithoutProductsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWishlistInput
  }

  export type WishlistUncheckedCreateWithoutProductsInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistCreateOrConnectWithoutProductsInput = {
    where: WishlistWhereUniqueInput
    create: XOR<WishlistCreateWithoutProductsInput, WishlistUncheckedCreateWithoutProductsInput>
  }

  export type StoresUpsertWithoutProductInput = {
    update: XOR<StoresUpdateWithoutProductInput, StoresUncheckedUpdateWithoutProductInput>
    create: XOR<StoresCreateWithoutProductInput, StoresUncheckedCreateWithoutProductInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutProductInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutProductInput, StoresUncheckedUpdateWithoutProductInput>
  }

  export type StoresUpdateWithoutProductInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStoreNestedInput
    avatar?: AvatarStoreUpdateOneWithoutStoreAvatarNestedInput
    avaliations?: StoreAvaliationsUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUpdateManyWithoutStoreNestedInput
    chat?: ChatUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUpdateManyWithoutStoreNestedInput
  }

  export type StoresUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avaliations?: StoreAvaliationsUncheckedUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUncheckedUpdateManyWithoutStoreNestedInput
    chat?: ChatUncheckedUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type InventoryUpsertWithoutProductInput = {
    update: XOR<InventoryUpdateWithoutProductInput, InventoryUncheckedUpdateWithoutProductInput>
    create: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutProductInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutProductInput, InventoryUncheckedUpdateWithoutProductInput>
  }

  export type InventoryUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImagesUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductImagesWhereUniqueInput
    update: XOR<ProductImagesUpdateWithoutProductInput, ProductImagesUncheckedUpdateWithoutProductInput>
    create: XOR<ProductImagesCreateWithoutProductInput, ProductImagesUncheckedCreateWithoutProductInput>
  }

  export type ProductImagesUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductImagesWhereUniqueInput
    data: XOR<ProductImagesUpdateWithoutProductInput, ProductImagesUncheckedUpdateWithoutProductInput>
  }

  export type ProductImagesUpdateManyWithWhereWithoutProductInput = {
    where: ProductImagesScalarWhereInput
    data: XOR<ProductImagesUpdateManyMutationInput, ProductImagesUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductImagesScalarWhereInput = {
    AND?: ProductImagesScalarWhereInput | ProductImagesScalarWhereInput[]
    OR?: ProductImagesScalarWhereInput[]
    NOT?: ProductImagesScalarWhereInput | ProductImagesScalarWhereInput[]
    id?: IntFilter<"ProductImages"> | number
    url?: StringFilter<"ProductImages"> | string
    publicId?: StringFilter<"ProductImages"> | string
    productId?: IntNullableFilter<"ProductImages"> | number | null
  }

  export type CategoryUpsertWithWhereUniqueWithoutProductInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutProductInput, CategoryUncheckedUpdateWithoutProductInput>
    create: XOR<CategoryCreateWithoutProductInput, CategoryUncheckedCreateWithoutProductInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutProductInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutProductInput, CategoryUncheckedUpdateWithoutProductInput>
  }

  export type CategoryUpdateManyWithWhereWithoutProductInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutProductInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
  }

  export type ProductAvaliationsUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductAvaliationsWhereUniqueInput
    update: XOR<ProductAvaliationsUpdateWithoutProductInput, ProductAvaliationsUncheckedUpdateWithoutProductInput>
    create: XOR<ProductAvaliationsCreateWithoutProductInput, ProductAvaliationsUncheckedCreateWithoutProductInput>
  }

  export type ProductAvaliationsUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductAvaliationsWhereUniqueInput
    data: XOR<ProductAvaliationsUpdateWithoutProductInput, ProductAvaliationsUncheckedUpdateWithoutProductInput>
  }

  export type ProductAvaliationsUpdateManyWithWhereWithoutProductInput = {
    where: ProductAvaliationsScalarWhereInput
    data: XOR<ProductAvaliationsUpdateManyMutationInput, ProductAvaliationsUncheckedUpdateManyWithoutProductInput>
  }

  export type PromotionUpsertWithWhereUniqueWithoutProductsInput = {
    where: PromotionWhereUniqueInput
    update: XOR<PromotionUpdateWithoutProductsInput, PromotionUncheckedUpdateWithoutProductsInput>
    create: XOR<PromotionCreateWithoutProductsInput, PromotionUncheckedCreateWithoutProductsInput>
  }

  export type PromotionUpdateWithWhereUniqueWithoutProductsInput = {
    where: PromotionWhereUniqueInput
    data: XOR<PromotionUpdateWithoutProductsInput, PromotionUncheckedUpdateWithoutProductsInput>
  }

  export type PromotionUpdateManyWithWhereWithoutProductsInput = {
    where: PromotionScalarWhereInput
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyWithoutProductsInput>
  }

  export type CartItemsUpsertWithWhereUniqueWithoutProductInput = {
    where: CartItemsWhereUniqueInput
    update: XOR<CartItemsUpdateWithoutProductInput, CartItemsUncheckedUpdateWithoutProductInput>
    create: XOR<CartItemsCreateWithoutProductInput, CartItemsUncheckedCreateWithoutProductInput>
  }

  export type CartItemsUpdateWithWhereUniqueWithoutProductInput = {
    where: CartItemsWhereUniqueInput
    data: XOR<CartItemsUpdateWithoutProductInput, CartItemsUncheckedUpdateWithoutProductInput>
  }

  export type CartItemsUpdateManyWithWhereWithoutProductInput = {
    where: CartItemsScalarWhereInput
    data: XOR<CartItemsUpdateManyMutationInput, CartItemsUncheckedUpdateManyWithoutProductInput>
  }

  export type CartItemsScalarWhereInput = {
    AND?: CartItemsScalarWhereInput | CartItemsScalarWhereInput[]
    OR?: CartItemsScalarWhereInput[]
    NOT?: CartItemsScalarWhereInput | CartItemsScalarWhereInput[]
    id?: IntFilter<"CartItems"> | number
    cartId?: IntFilter<"CartItems"> | number
    productId?: IntFilter<"CartItems"> | number
    quantidade?: IntFilter<"CartItems"> | number
    abandonedCartId?: IntNullableFilter<"CartItems"> | number | null
  }

  export type OrderItemsUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemsWhereUniqueInput
    update: XOR<OrderItemsUpdateWithoutProductInput, OrderItemsUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemsCreateWithoutProductInput, OrderItemsUncheckedCreateWithoutProductInput>
  }

  export type OrderItemsUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemsWhereUniqueInput
    data: XOR<OrderItemsUpdateWithoutProductInput, OrderItemsUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemsUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemsScalarWhereInput
    data: XOR<OrderItemsUpdateManyMutationInput, OrderItemsUncheckedUpdateManyWithoutProductInput>
  }

  export type WishlistUpsertWithWhereUniqueWithoutProductsInput = {
    where: WishlistWhereUniqueInput
    update: XOR<WishlistUpdateWithoutProductsInput, WishlistUncheckedUpdateWithoutProductsInput>
    create: XOR<WishlistCreateWithoutProductsInput, WishlistUncheckedCreateWithoutProductsInput>
  }

  export type WishlistUpdateWithWhereUniqueWithoutProductsInput = {
    where: WishlistWhereUniqueInput
    data: XOR<WishlistUpdateWithoutProductsInput, WishlistUncheckedUpdateWithoutProductsInput>
  }

  export type WishlistUpdateManyWithWhereWithoutProductsInput = {
    where: WishlistScalarWhereInput
    data: XOR<WishlistUpdateManyMutationInput, WishlistUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductsCreateWithoutImagesInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    store: StoresCreateNestedOneWithoutProductInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    category?: CategoryCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsCreateNestedManyWithoutProductInput
    promotions?: PromotionCreateNestedManyWithoutProductsInput
    cartItem?: CartItemsCreateNestedManyWithoutProductInput
    orderItems?: OrderItemsCreateNestedManyWithoutProductInput
    wishlists?: WishlistCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutImagesInput = {
    id?: number
    storeId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    category?: CategoryUncheckedCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutProductInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutProductsInput
    cartItem?: CartItemsUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutProductInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutImagesInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutImagesInput, ProductsUncheckedCreateWithoutImagesInput>
  }

  export type ProductsUpsertWithoutImagesInput = {
    update: XOR<ProductsUpdateWithoutImagesInput, ProductsUncheckedUpdateWithoutImagesInput>
    create: XOR<ProductsCreateWithoutImagesInput, ProductsUncheckedCreateWithoutImagesInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutImagesInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutImagesInput, ProductsUncheckedUpdateWithoutImagesInput>
  }

  export type ProductsUpdateWithoutImagesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    store?: StoresUpdateOneRequiredWithoutProductNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    category?: CategoryUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUpdateManyWithoutProductNestedInput
    promotions?: PromotionUpdateManyWithoutProductsNestedInput
    cartItem?: CartItemsUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemsUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    category?: CategoryUncheckedUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUncheckedUpdateManyWithoutProductNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutProductsNestedInput
    cartItem?: CartItemsUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type UserCreateWithoutWishlistInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWishlistInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWishlistInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>
  }

  export type ProductsCreateWithoutWishlistsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    store: StoresCreateNestedOneWithoutProductInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    images?: ProductImagesCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsCreateNestedManyWithoutProductInput
    promotions?: PromotionCreateNestedManyWithoutProductsInput
    cartItem?: CartItemsCreateNestedManyWithoutProductInput
    orderItems?: OrderItemsCreateNestedManyWithoutProductInput
  }

  export type ProductsUncheckedCreateWithoutWishlistsInput = {
    id?: number
    storeId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    images?: ProductImagesUncheckedCreateNestedManyWithoutProductInput
    category?: CategoryUncheckedCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutProductInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutProductsInput
    cartItem?: CartItemsUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductsCreateOrConnectWithoutWishlistsInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutWishlistsInput, ProductsUncheckedCreateWithoutWishlistsInput>
  }

  export type UserUpsertWithoutWishlistInput = {
    update: XOR<UserUpdateWithoutWishlistInput, UserUncheckedUpdateWithoutWishlistInput>
    create: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWishlistInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWishlistInput, UserUncheckedUpdateWithoutWishlistInput>
  }

  export type UserUpdateWithoutWishlistInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWishlistInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductsUpsertWithWhereUniqueWithoutWishlistsInput = {
    where: ProductsWhereUniqueInput
    update: XOR<ProductsUpdateWithoutWishlistsInput, ProductsUncheckedUpdateWithoutWishlistsInput>
    create: XOR<ProductsCreateWithoutWishlistsInput, ProductsUncheckedCreateWithoutWishlistsInput>
  }

  export type ProductsUpdateWithWhereUniqueWithoutWishlistsInput = {
    where: ProductsWhereUniqueInput
    data: XOR<ProductsUpdateWithoutWishlistsInput, ProductsUncheckedUpdateWithoutWishlistsInput>
  }

  export type ProductsUpdateManyWithWhereWithoutWishlistsInput = {
    where: ProductsScalarWhereInput
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyWithoutWishlistsInput>
  }

  export type ProductsCreateWithoutInventoryInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    store: StoresCreateNestedOneWithoutProductInput
    images?: ProductImagesCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsCreateNestedManyWithoutProductInput
    promotions?: PromotionCreateNestedManyWithoutProductsInput
    cartItem?: CartItemsCreateNestedManyWithoutProductInput
    orderItems?: OrderItemsCreateNestedManyWithoutProductInput
    wishlists?: WishlistCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutInventoryInput = {
    id?: number
    storeId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    images?: ProductImagesUncheckedCreateNestedManyWithoutProductInput
    category?: CategoryUncheckedCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutProductInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutProductsInput
    cartItem?: CartItemsUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutProductInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutInventoryInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutInventoryInput, ProductsUncheckedCreateWithoutInventoryInput>
  }

  export type ProductsUpsertWithoutInventoryInput = {
    update: XOR<ProductsUpdateWithoutInventoryInput, ProductsUncheckedUpdateWithoutInventoryInput>
    create: XOR<ProductsCreateWithoutInventoryInput, ProductsUncheckedCreateWithoutInventoryInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutInventoryInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutInventoryInput, ProductsUncheckedUpdateWithoutInventoryInput>
  }

  export type ProductsUpdateWithoutInventoryInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    store?: StoresUpdateOneRequiredWithoutProductNestedInput
    images?: ProductImagesUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUpdateManyWithoutProductNestedInput
    promotions?: PromotionUpdateManyWithoutProductsNestedInput
    cartItem?: CartItemsUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemsUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    images?: ProductImagesUncheckedUpdateManyWithoutProductNestedInput
    category?: CategoryUncheckedUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUncheckedUpdateManyWithoutProductNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutProductsNestedInput
    cartItem?: CartItemsUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type StoresCreateWithoutPromotionsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    user: UserCreateNestedOneWithoutStoreInput
    avatar?: AvatarStoreCreateNestedOneWithoutStoreAvatarInput
    product?: ProductsCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsCreateNestedManyWithoutStoreInput
    coupons?: CouponsCreateNestedManyWithoutStoreInput
    chat?: ChatCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoreInput
  }

  export type StoresUncheckedCreateWithoutPromotionsInput = {
    id?: number
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    avatarId?: number | null
    product?: ProductsUncheckedCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutStoreInput
    coupons?: CouponsUncheckedCreateNestedManyWithoutStoreInput
    chat?: ChatUncheckedCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoresCreateOrConnectWithoutPromotionsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutPromotionsInput, StoresUncheckedCreateWithoutPromotionsInput>
  }

  export type ProductsCreateWithoutPromotionsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    store: StoresCreateNestedOneWithoutProductInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    images?: ProductImagesCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsCreateNestedManyWithoutProductInput
    cartItem?: CartItemsCreateNestedManyWithoutProductInput
    orderItems?: OrderItemsCreateNestedManyWithoutProductInput
    wishlists?: WishlistCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutPromotionsInput = {
    id?: number
    storeId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    images?: ProductImagesUncheckedCreateNestedManyWithoutProductInput
    category?: CategoryUncheckedCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutProductInput
    cartItem?: CartItemsUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutProductInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutPromotionsInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutPromotionsInput, ProductsUncheckedCreateWithoutPromotionsInput>
  }

  export type StoresUpsertWithoutPromotionsInput = {
    update: XOR<StoresUpdateWithoutPromotionsInput, StoresUncheckedUpdateWithoutPromotionsInput>
    create: XOR<StoresCreateWithoutPromotionsInput, StoresUncheckedCreateWithoutPromotionsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutPromotionsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutPromotionsInput, StoresUncheckedUpdateWithoutPromotionsInput>
  }

  export type StoresUpdateWithoutPromotionsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStoreNestedInput
    avatar?: AvatarStoreUpdateOneWithoutStoreAvatarNestedInput
    product?: ProductsUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUpdateManyWithoutStoreNestedInput
    chat?: ChatUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoreNestedInput
  }

  export type StoresUncheckedUpdateWithoutPromotionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    product?: ProductsUncheckedUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUncheckedUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUncheckedUpdateManyWithoutStoreNestedInput
    chat?: ChatUncheckedUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ProductsUpsertWithWhereUniqueWithoutPromotionsInput = {
    where: ProductsWhereUniqueInput
    update: XOR<ProductsUpdateWithoutPromotionsInput, ProductsUncheckedUpdateWithoutPromotionsInput>
    create: XOR<ProductsCreateWithoutPromotionsInput, ProductsUncheckedCreateWithoutPromotionsInput>
  }

  export type ProductsUpdateWithWhereUniqueWithoutPromotionsInput = {
    where: ProductsWhereUniqueInput
    data: XOR<ProductsUpdateWithoutPromotionsInput, ProductsUncheckedUpdateWithoutPromotionsInput>
  }

  export type ProductsUpdateManyWithWhereWithoutPromotionsInput = {
    where: ProductsScalarWhereInput
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyWithoutPromotionsInput>
  }

  export type ProductsCreateWithoutCategoryInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    store: StoresCreateNestedOneWithoutProductInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    images?: ProductImagesCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsCreateNestedManyWithoutProductInput
    promotions?: PromotionCreateNestedManyWithoutProductsInput
    cartItem?: CartItemsCreateNestedManyWithoutProductInput
    orderItems?: OrderItemsCreateNestedManyWithoutProductInput
    wishlists?: WishlistCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutCategoryInput = {
    id?: number
    storeId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    images?: ProductImagesUncheckedCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutProductInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutProductsInput
    cartItem?: CartItemsUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutProductInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutCategoryInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutCategoryInput, ProductsUncheckedCreateWithoutCategoryInput>
  }

  export type ProductsUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductsWhereUniqueInput
    update: XOR<ProductsUpdateWithoutCategoryInput, ProductsUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductsCreateWithoutCategoryInput, ProductsUncheckedCreateWithoutCategoryInput>
  }

  export type ProductsUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductsWhereUniqueInput
    data: XOR<ProductsUpdateWithoutCategoryInput, ProductsUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductsUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductsScalarWhereInput
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyWithoutCategoryInput>
  }

  export type UserCreateWithoutProductAvaliationsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductAvaliationsInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductAvaliationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductAvaliationsInput, UserUncheckedCreateWithoutProductAvaliationsInput>
  }

  export type ProductsCreateWithoutAvaliationsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    store: StoresCreateNestedOneWithoutProductInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    images?: ProductImagesCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedManyWithoutProductInput
    promotions?: PromotionCreateNestedManyWithoutProductsInput
    cartItem?: CartItemsCreateNestedManyWithoutProductInput
    orderItems?: OrderItemsCreateNestedManyWithoutProductInput
    wishlists?: WishlistCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutAvaliationsInput = {
    id?: number
    storeId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    images?: ProductImagesUncheckedCreateNestedManyWithoutProductInput
    category?: CategoryUncheckedCreateNestedManyWithoutProductInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutProductsInput
    cartItem?: CartItemsUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutProductInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutAvaliationsInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutAvaliationsInput, ProductsUncheckedCreateWithoutAvaliationsInput>
  }

  export type ProductAvaliationImagesCreateWithoutProductAvaliationInput = {
    url: string
    publicId: string
  }

  export type ProductAvaliationImagesUncheckedCreateWithoutProductAvaliationInput = {
    id?: number
    url: string
    publicId: string
  }

  export type ProductAvaliationImagesCreateOrConnectWithoutProductAvaliationInput = {
    where: ProductAvaliationImagesWhereUniqueInput
    create: XOR<ProductAvaliationImagesCreateWithoutProductAvaliationInput, ProductAvaliationImagesUncheckedCreateWithoutProductAvaliationInput>
  }

  export type ProductAvaliationImagesCreateManyProductAvaliationInputEnvelope = {
    data: ProductAvaliationImagesCreateManyProductAvaliationInput | ProductAvaliationImagesCreateManyProductAvaliationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProductAvaliationsInput = {
    update: XOR<UserUpdateWithoutProductAvaliationsInput, UserUncheckedUpdateWithoutProductAvaliationsInput>
    create: XOR<UserCreateWithoutProductAvaliationsInput, UserUncheckedCreateWithoutProductAvaliationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductAvaliationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductAvaliationsInput, UserUncheckedUpdateWithoutProductAvaliationsInput>
  }

  export type UserUpdateWithoutProductAvaliationsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductAvaliationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductsUpsertWithoutAvaliationsInput = {
    update: XOR<ProductsUpdateWithoutAvaliationsInput, ProductsUncheckedUpdateWithoutAvaliationsInput>
    create: XOR<ProductsCreateWithoutAvaliationsInput, ProductsUncheckedCreateWithoutAvaliationsInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutAvaliationsInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutAvaliationsInput, ProductsUncheckedUpdateWithoutAvaliationsInput>
  }

  export type ProductsUpdateWithoutAvaliationsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    store?: StoresUpdateOneRequiredWithoutProductNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    images?: ProductImagesUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateManyWithoutProductNestedInput
    promotions?: PromotionUpdateManyWithoutProductsNestedInput
    cartItem?: CartItemsUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemsUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutAvaliationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    images?: ProductImagesUncheckedUpdateManyWithoutProductNestedInput
    category?: CategoryUncheckedUpdateManyWithoutProductNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutProductsNestedInput
    cartItem?: CartItemsUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductAvaliationImagesUpsertWithWhereUniqueWithoutProductAvaliationInput = {
    where: ProductAvaliationImagesWhereUniqueInput
    update: XOR<ProductAvaliationImagesUpdateWithoutProductAvaliationInput, ProductAvaliationImagesUncheckedUpdateWithoutProductAvaliationInput>
    create: XOR<ProductAvaliationImagesCreateWithoutProductAvaliationInput, ProductAvaliationImagesUncheckedCreateWithoutProductAvaliationInput>
  }

  export type ProductAvaliationImagesUpdateWithWhereUniqueWithoutProductAvaliationInput = {
    where: ProductAvaliationImagesWhereUniqueInput
    data: XOR<ProductAvaliationImagesUpdateWithoutProductAvaliationInput, ProductAvaliationImagesUncheckedUpdateWithoutProductAvaliationInput>
  }

  export type ProductAvaliationImagesUpdateManyWithWhereWithoutProductAvaliationInput = {
    where: ProductAvaliationImagesScalarWhereInput
    data: XOR<ProductAvaliationImagesUpdateManyMutationInput, ProductAvaliationImagesUncheckedUpdateManyWithoutProductAvaliationInput>
  }

  export type ProductAvaliationImagesScalarWhereInput = {
    AND?: ProductAvaliationImagesScalarWhereInput | ProductAvaliationImagesScalarWhereInput[]
    OR?: ProductAvaliationImagesScalarWhereInput[]
    NOT?: ProductAvaliationImagesScalarWhereInput | ProductAvaliationImagesScalarWhereInput[]
    id?: IntFilter<"ProductAvaliationImages"> | number
    url?: StringFilter<"ProductAvaliationImages"> | string
    publicId?: StringFilter<"ProductAvaliationImages"> | string
    productAvaliationId?: IntNullableFilter<"ProductAvaliationImages"> | number | null
  }

  export type ProductAvaliationsCreateWithoutImagesInput = {
    note: number
    avaliationDate?: Date | string
    comment?: string | null
    user: UserCreateNestedOneWithoutProductAvaliationsInput
    product: ProductsCreateNestedOneWithoutAvaliationsInput
  }

  export type ProductAvaliationsUncheckedCreateWithoutImagesInput = {
    id?: number
    userId: number
    productId: number
    note: number
    avaliationDate?: Date | string
    comment?: string | null
  }

  export type ProductAvaliationsCreateOrConnectWithoutImagesInput = {
    where: ProductAvaliationsWhereUniqueInput
    create: XOR<ProductAvaliationsCreateWithoutImagesInput, ProductAvaliationsUncheckedCreateWithoutImagesInput>
  }

  export type ProductAvaliationsUpsertWithoutImagesInput = {
    update: XOR<ProductAvaliationsUpdateWithoutImagesInput, ProductAvaliationsUncheckedUpdateWithoutImagesInput>
    create: XOR<ProductAvaliationsCreateWithoutImagesInput, ProductAvaliationsUncheckedCreateWithoutImagesInput>
    where?: ProductAvaliationsWhereInput
  }

  export type ProductAvaliationsUpdateToOneWithWhereWithoutImagesInput = {
    where?: ProductAvaliationsWhereInput
    data: XOR<ProductAvaliationsUpdateWithoutImagesInput, ProductAvaliationsUncheckedUpdateWithoutImagesInput>
  }

  export type ProductAvaliationsUpdateWithoutImagesInput = {
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutProductAvaliationsNestedInput
    product?: ProductsUpdateOneRequiredWithoutAvaliationsNestedInput
  }

  export type ProductAvaliationsUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutCartInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCartInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCartInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
  }

  export type CartItemsCreateWithoutCartInput = {
    quantidade: number
    product: ProductsCreateNestedOneWithoutCartItemInput
    AbandonedCart?: AbandonedCartCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemsUncheckedCreateWithoutCartInput = {
    id?: number
    productId: number
    quantidade: number
    abandonedCartId?: number | null
  }

  export type CartItemsCreateOrConnectWithoutCartInput = {
    where: CartItemsWhereUniqueInput
    create: XOR<CartItemsCreateWithoutCartInput, CartItemsUncheckedCreateWithoutCartInput>
  }

  export type CartItemsCreateManyCartInputEnvelope = {
    data: CartItemsCreateManyCartInput | CartItemsCreateManyCartInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCartInput = {
    update: XOR<UserUpdateWithoutCartInput, UserUncheckedUpdateWithoutCartInput>
    create: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCartInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCartInput, UserUncheckedUpdateWithoutCartInput>
  }

  export type UserUpdateWithoutCartInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CartItemsUpsertWithWhereUniqueWithoutCartInput = {
    where: CartItemsWhereUniqueInput
    update: XOR<CartItemsUpdateWithoutCartInput, CartItemsUncheckedUpdateWithoutCartInput>
    create: XOR<CartItemsCreateWithoutCartInput, CartItemsUncheckedCreateWithoutCartInput>
  }

  export type CartItemsUpdateWithWhereUniqueWithoutCartInput = {
    where: CartItemsWhereUniqueInput
    data: XOR<CartItemsUpdateWithoutCartInput, CartItemsUncheckedUpdateWithoutCartInput>
  }

  export type CartItemsUpdateManyWithWhereWithoutCartInput = {
    where: CartItemsScalarWhereInput
    data: XOR<CartItemsUpdateManyMutationInput, CartItemsUncheckedUpdateManyWithoutCartInput>
  }

  export type CartCreateWithoutCartItemsInput = {
    userCart?: UserCreateNestedOneWithoutCartInput
  }

  export type CartUncheckedCreateWithoutCartItemsInput = {
    id?: number
    userCart?: UserUncheckedCreateNestedOneWithoutCartInput
  }

  export type CartCreateOrConnectWithoutCartItemsInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutCartItemsInput, CartUncheckedCreateWithoutCartItemsInput>
  }

  export type ProductsCreateWithoutCartItemInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    store: StoresCreateNestedOneWithoutProductInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    images?: ProductImagesCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsCreateNestedManyWithoutProductInput
    promotions?: PromotionCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemsCreateNestedManyWithoutProductInput
    wishlists?: WishlistCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutCartItemInput = {
    id?: number
    storeId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    images?: ProductImagesUncheckedCreateNestedManyWithoutProductInput
    category?: CategoryUncheckedCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutProductInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutProductsInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutProductInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutCartItemInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutCartItemInput, ProductsUncheckedCreateWithoutCartItemInput>
  }

  export type AbandonedCartCreateWithoutCartItemsInput = {
    abandonedAt?: Date | string
    user: UserCreateNestedOneWithoutAbandonedCartInput
  }

  export type AbandonedCartUncheckedCreateWithoutCartItemsInput = {
    id?: number
    userId: number
    abandonedAt?: Date | string
  }

  export type AbandonedCartCreateOrConnectWithoutCartItemsInput = {
    where: AbandonedCartWhereUniqueInput
    create: XOR<AbandonedCartCreateWithoutCartItemsInput, AbandonedCartUncheckedCreateWithoutCartItemsInput>
  }

  export type CartUpsertWithoutCartItemsInput = {
    update: XOR<CartUpdateWithoutCartItemsInput, CartUncheckedUpdateWithoutCartItemsInput>
    create: XOR<CartCreateWithoutCartItemsInput, CartUncheckedCreateWithoutCartItemsInput>
    where?: CartWhereInput
  }

  export type CartUpdateToOneWithWhereWithoutCartItemsInput = {
    where?: CartWhereInput
    data: XOR<CartUpdateWithoutCartItemsInput, CartUncheckedUpdateWithoutCartItemsInput>
  }

  export type CartUpdateWithoutCartItemsInput = {
    userCart?: UserUpdateOneWithoutCartNestedInput
  }

  export type CartUncheckedUpdateWithoutCartItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userCart?: UserUncheckedUpdateOneWithoutCartNestedInput
  }

  export type ProductsUpsertWithoutCartItemInput = {
    update: XOR<ProductsUpdateWithoutCartItemInput, ProductsUncheckedUpdateWithoutCartItemInput>
    create: XOR<ProductsCreateWithoutCartItemInput, ProductsUncheckedCreateWithoutCartItemInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutCartItemInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutCartItemInput, ProductsUncheckedUpdateWithoutCartItemInput>
  }

  export type ProductsUpdateWithoutCartItemInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    store?: StoresUpdateOneRequiredWithoutProductNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    images?: ProductImagesUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUpdateManyWithoutProductNestedInput
    promotions?: PromotionUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemsUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutCartItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    images?: ProductImagesUncheckedUpdateManyWithoutProductNestedInput
    category?: CategoryUncheckedUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUncheckedUpdateManyWithoutProductNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutProductsNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type AbandonedCartUpsertWithoutCartItemsInput = {
    update: XOR<AbandonedCartUpdateWithoutCartItemsInput, AbandonedCartUncheckedUpdateWithoutCartItemsInput>
    create: XOR<AbandonedCartCreateWithoutCartItemsInput, AbandonedCartUncheckedCreateWithoutCartItemsInput>
    where?: AbandonedCartWhereInput
  }

  export type AbandonedCartUpdateToOneWithWhereWithoutCartItemsInput = {
    where?: AbandonedCartWhereInput
    data: XOR<AbandonedCartUpdateWithoutCartItemsInput, AbandonedCartUncheckedUpdateWithoutCartItemsInput>
  }

  export type AbandonedCartUpdateWithoutCartItemsInput = {
    abandonedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAbandonedCartNestedInput
  }

  export type AbandonedCartUncheckedUpdateWithoutCartItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    abandonedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateWithoutPaymentMethodInput = {
    valor: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
  }

  export type PaymentUncheckedCreateWithoutPaymentMethodInput = {
    id?: number
    valor: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
  }

  export type PaymentCreateOrConnectWithoutPaymentMethodInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput>
  }

  export type PaymentCreateManyPaymentMethodInputEnvelope = {
    data: PaymentCreateManyPaymentMethodInput | PaymentCreateManyPaymentMethodInput[]
    skipDuplicates?: boolean
  }

  export type PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutPaymentMethodInput, PaymentUncheckedUpdateWithoutPaymentMethodInput>
    create: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutPaymentMethodInput, PaymentUncheckedUpdateWithoutPaymentMethodInput>
  }

  export type PaymentUpdateManyWithWhereWithoutPaymentMethodInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPaymentMethodInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    valor?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethodId?: IntFilter<"Payment"> | number
  }

  export type PaymentMethodCreateWithoutPaymentsInput = {
    method: $Enums.PaymentMethodType
  }

  export type PaymentMethodUncheckedCreateWithoutPaymentsInput = {
    id?: number
    method: $Enums.PaymentMethodType
  }

  export type PaymentMethodCreateOrConnectWithoutPaymentsInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutPaymentsInput, PaymentMethodUncheckedCreateWithoutPaymentsInput>
  }

  export type PaymentMethodUpsertWithoutPaymentsInput = {
    update: XOR<PaymentMethodUpdateWithoutPaymentsInput, PaymentMethodUncheckedUpdateWithoutPaymentsInput>
    create: XOR<PaymentMethodCreateWithoutPaymentsInput, PaymentMethodUncheckedCreateWithoutPaymentsInput>
    where?: PaymentMethodWhereInput
  }

  export type PaymentMethodUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: PaymentMethodWhereInput
    data: XOR<PaymentMethodUpdateWithoutPaymentsInput, PaymentMethodUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentMethodUpdateWithoutPaymentsInput = {
    method?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
  }

  export type PaymentMethodUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
  }

  export type OrdersCreateWithoutOrderStatusInput = {
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    user: UserCreateNestedOneWithoutOrdersInput
    deliveryAddress: AddressesCreateNestedOneWithoutOrderInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemsCreateNestedManyWithoutOrderInput
    orderHistory?: OrderHistoryCreateNestedManyWithoutOrderInput
    shipping?: ShippingCreateNestedOneWithoutOrderInput
    ReturnExchange?: ReturnExchangeCreateNestedManyWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutOrderStatusInput = {
    id?: number
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    userId: number
    deliveryAddressId: number
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutOrderInput
    orderHistory?: OrderHistoryUncheckedCreateNestedManyWithoutOrderInput
    shipping?: ShippingUncheckedCreateNestedOneWithoutOrderInput
    ReturnExchange?: ReturnExchangeUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutOrderStatusInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutOrderStatusInput, OrdersUncheckedCreateWithoutOrderStatusInput>
  }

  export type OrdersCreateManyOrderStatusInputEnvelope = {
    data: OrdersCreateManyOrderStatusInput | OrdersCreateManyOrderStatusInput[]
    skipDuplicates?: boolean
  }

  export type OrdersUpsertWithWhereUniqueWithoutOrderStatusInput = {
    where: OrdersWhereUniqueInput
    update: XOR<OrdersUpdateWithoutOrderStatusInput, OrdersUncheckedUpdateWithoutOrderStatusInput>
    create: XOR<OrdersCreateWithoutOrderStatusInput, OrdersUncheckedCreateWithoutOrderStatusInput>
  }

  export type OrdersUpdateWithWhereUniqueWithoutOrderStatusInput = {
    where: OrdersWhereUniqueInput
    data: XOR<OrdersUpdateWithoutOrderStatusInput, OrdersUncheckedUpdateWithoutOrderStatusInput>
  }

  export type OrdersUpdateManyWithWhereWithoutOrderStatusInput = {
    where: OrdersScalarWhereInput
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyWithoutOrderStatusInput>
  }

  export type UserCreateWithoutOrdersInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type OrderStatusCreateWithoutOrdersInput = {
    Status: $Enums.OrderStatusType
  }

  export type OrderStatusUncheckedCreateWithoutOrdersInput = {
    id?: number
    Status: $Enums.OrderStatusType
  }

  export type OrderStatusCreateOrConnectWithoutOrdersInput = {
    where: OrderStatusWhereUniqueInput
    create: XOR<OrderStatusCreateWithoutOrdersInput, OrderStatusUncheckedCreateWithoutOrdersInput>
  }

  export type AddressesCreateWithoutOrderInput = {
    cep: string
    road: string
    number: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    country?: string
    type?: string | null
    reference?: string | null
    user: UserCreateNestedOneWithoutAddressesInput
    principalOf?: UserCreateNestedOneWithoutPrincipalAddressInput
  }

  export type AddressesUncheckedCreateWithoutOrderInput = {
    id?: number
    userId: number
    cep: string
    road: string
    number: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    country?: string
    type?: string | null
    reference?: string | null
    principalOf?: UserUncheckedCreateNestedOneWithoutPrincipalAddressInput
  }

  export type AddressesCreateOrConnectWithoutOrderInput = {
    where: AddressesWhereUniqueInput
    create: XOR<AddressesCreateWithoutOrderInput, AddressesUncheckedCreateWithoutOrderInput>
  }

  export type UserUsedCouponsCreateWithoutOrderInput = {
    usedAt?: Date | string
    user: UserCreateNestedOneWithoutUsedCouponsInput
    coupon: CouponsCreateNestedOneWithoutUsedCouponsInput
  }

  export type UserUsedCouponsUncheckedCreateWithoutOrderInput = {
    id?: number
    userId: number
    couponId: number
    usedAt?: Date | string
  }

  export type UserUsedCouponsCreateOrConnectWithoutOrderInput = {
    where: UserUsedCouponsWhereUniqueInput
    create: XOR<UserUsedCouponsCreateWithoutOrderInput, UserUsedCouponsUncheckedCreateWithoutOrderInput>
  }

  export type UserUsedCouponsCreateManyOrderInputEnvelope = {
    data: UserUsedCouponsCreateManyOrderInput | UserUsedCouponsCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemsCreateWithoutOrderInput = {
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    product: ProductsCreateNestedOneWithoutOrderItemsInput
    store: StoresCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemsUncheckedCreateWithoutOrderInput = {
    id?: number
    productId: number
    storeId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
  }

  export type OrderItemsCreateOrConnectWithoutOrderInput = {
    where: OrderItemsWhereUniqueInput
    create: XOR<OrderItemsCreateWithoutOrderInput, OrderItemsUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemsCreateManyOrderInputEnvelope = {
    data: OrderItemsCreateManyOrderInput | OrderItemsCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderHistoryCreateWithoutOrderInput = {
    action: string
    updatedAt?: Date | string
  }

  export type OrderHistoryUncheckedCreateWithoutOrderInput = {
    id?: number
    action: string
    updatedAt?: Date | string
  }

  export type OrderHistoryCreateOrConnectWithoutOrderInput = {
    where: OrderHistoryWhereUniqueInput
    create: XOR<OrderHistoryCreateWithoutOrderInput, OrderHistoryUncheckedCreateWithoutOrderInput>
  }

  export type OrderHistoryCreateManyOrderInputEnvelope = {
    data: OrderHistoryCreateManyOrderInput | OrderHistoryCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ShippingCreateWithoutOrderInput = {
    shippingMethod: string
    shippingCost: Decimal | DecimalJsLike | number | string
    estimatedDelivery: Date | string
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingUncheckedCreateWithoutOrderInput = {
    id?: number
    shippingMethod: string
    shippingCost: Decimal | DecimalJsLike | number | string
    estimatedDelivery: Date | string
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingCreateOrConnectWithoutOrderInput = {
    where: ShippingWhereUniqueInput
    create: XOR<ShippingCreateWithoutOrderInput, ShippingUncheckedCreateWithoutOrderInput>
  }

  export type ReturnExchangeCreateWithoutOrderInput = {
    reason: string
    status: $Enums.ReturnExchangeStatus
    requestedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ReturnExchangeUncheckedCreateWithoutOrderInput = {
    id?: number
    reason: string
    status: $Enums.ReturnExchangeStatus
    requestedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ReturnExchangeCreateOrConnectWithoutOrderInput = {
    where: ReturnExchangeWhereUniqueInput
    create: XOR<ReturnExchangeCreateWithoutOrderInput, ReturnExchangeUncheckedCreateWithoutOrderInput>
  }

  export type ReturnExchangeCreateManyOrderInputEnvelope = {
    data: ReturnExchangeCreateManyOrderInput | ReturnExchangeCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderStatusUpsertWithoutOrdersInput = {
    update: XOR<OrderStatusUpdateWithoutOrdersInput, OrderStatusUncheckedUpdateWithoutOrdersInput>
    create: XOR<OrderStatusCreateWithoutOrdersInput, OrderStatusUncheckedCreateWithoutOrdersInput>
    where?: OrderStatusWhereInput
  }

  export type OrderStatusUpdateToOneWithWhereWithoutOrdersInput = {
    where?: OrderStatusWhereInput
    data: XOR<OrderStatusUpdateWithoutOrdersInput, OrderStatusUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderStatusUpdateWithoutOrdersInput = {
    Status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
  }

  export type OrderStatusUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    Status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
  }

  export type AddressesUpsertWithoutOrderInput = {
    update: XOR<AddressesUpdateWithoutOrderInput, AddressesUncheckedUpdateWithoutOrderInput>
    create: XOR<AddressesCreateWithoutOrderInput, AddressesUncheckedCreateWithoutOrderInput>
    where?: AddressesWhereInput
  }

  export type AddressesUpdateToOneWithWhereWithoutOrderInput = {
    where?: AddressesWhereInput
    data: XOR<AddressesUpdateWithoutOrderInput, AddressesUncheckedUpdateWithoutOrderInput>
  }

  export type AddressesUpdateWithoutOrderInput = {
    cep?: StringFieldUpdateOperationsInput | string
    road?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAddressesNestedInput
    principalOf?: UserUpdateOneWithoutPrincipalAddressNestedInput
  }

  export type AddressesUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    road?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    principalOf?: UserUncheckedUpdateOneWithoutPrincipalAddressNestedInput
  }

  export type UserUsedCouponsUpsertWithWhereUniqueWithoutOrderInput = {
    where: UserUsedCouponsWhereUniqueInput
    update: XOR<UserUsedCouponsUpdateWithoutOrderInput, UserUsedCouponsUncheckedUpdateWithoutOrderInput>
    create: XOR<UserUsedCouponsCreateWithoutOrderInput, UserUsedCouponsUncheckedCreateWithoutOrderInput>
  }

  export type UserUsedCouponsUpdateWithWhereUniqueWithoutOrderInput = {
    where: UserUsedCouponsWhereUniqueInput
    data: XOR<UserUsedCouponsUpdateWithoutOrderInput, UserUsedCouponsUncheckedUpdateWithoutOrderInput>
  }

  export type UserUsedCouponsUpdateManyWithWhereWithoutOrderInput = {
    where: UserUsedCouponsScalarWhereInput
    data: XOR<UserUsedCouponsUpdateManyMutationInput, UserUsedCouponsUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderItemsUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemsWhereUniqueInput
    update: XOR<OrderItemsUpdateWithoutOrderInput, OrderItemsUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemsCreateWithoutOrderInput, OrderItemsUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemsUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemsWhereUniqueInput
    data: XOR<OrderItemsUpdateWithoutOrderInput, OrderItemsUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemsUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemsScalarWhereInput
    data: XOR<OrderItemsUpdateManyMutationInput, OrderItemsUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderHistoryUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderHistoryWhereUniqueInput
    update: XOR<OrderHistoryUpdateWithoutOrderInput, OrderHistoryUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderHistoryCreateWithoutOrderInput, OrderHistoryUncheckedCreateWithoutOrderInput>
  }

  export type OrderHistoryUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderHistoryWhereUniqueInput
    data: XOR<OrderHistoryUpdateWithoutOrderInput, OrderHistoryUncheckedUpdateWithoutOrderInput>
  }

  export type OrderHistoryUpdateManyWithWhereWithoutOrderInput = {
    where: OrderHistoryScalarWhereInput
    data: XOR<OrderHistoryUpdateManyMutationInput, OrderHistoryUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderHistoryScalarWhereInput = {
    AND?: OrderHistoryScalarWhereInput | OrderHistoryScalarWhereInput[]
    OR?: OrderHistoryScalarWhereInput[]
    NOT?: OrderHistoryScalarWhereInput | OrderHistoryScalarWhereInput[]
    id?: IntFilter<"OrderHistory"> | number
    orderId?: IntFilter<"OrderHistory"> | number
    action?: StringFilter<"OrderHistory"> | string
    updatedAt?: DateTimeFilter<"OrderHistory"> | Date | string
  }

  export type ShippingUpsertWithoutOrderInput = {
    update: XOR<ShippingUpdateWithoutOrderInput, ShippingUncheckedUpdateWithoutOrderInput>
    create: XOR<ShippingCreateWithoutOrderInput, ShippingUncheckedCreateWithoutOrderInput>
    where?: ShippingWhereInput
  }

  export type ShippingUpdateToOneWithWhereWithoutOrderInput = {
    where?: ShippingWhereInput
    data: XOR<ShippingUpdateWithoutOrderInput, ShippingUncheckedUpdateWithoutOrderInput>
  }

  export type ShippingUpdateWithoutOrderInput = {
    shippingMethod?: StringFieldUpdateOperationsInput | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedDelivery?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    shippingMethod?: StringFieldUpdateOperationsInput | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedDelivery?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnExchangeUpsertWithWhereUniqueWithoutOrderInput = {
    where: ReturnExchangeWhereUniqueInput
    update: XOR<ReturnExchangeUpdateWithoutOrderInput, ReturnExchangeUncheckedUpdateWithoutOrderInput>
    create: XOR<ReturnExchangeCreateWithoutOrderInput, ReturnExchangeUncheckedCreateWithoutOrderInput>
  }

  export type ReturnExchangeUpdateWithWhereUniqueWithoutOrderInput = {
    where: ReturnExchangeWhereUniqueInput
    data: XOR<ReturnExchangeUpdateWithoutOrderInput, ReturnExchangeUncheckedUpdateWithoutOrderInput>
  }

  export type ReturnExchangeUpdateManyWithWhereWithoutOrderInput = {
    where: ReturnExchangeScalarWhereInput
    data: XOR<ReturnExchangeUpdateManyMutationInput, ReturnExchangeUncheckedUpdateManyWithoutOrderInput>
  }

  export type ReturnExchangeScalarWhereInput = {
    AND?: ReturnExchangeScalarWhereInput | ReturnExchangeScalarWhereInput[]
    OR?: ReturnExchangeScalarWhereInput[]
    NOT?: ReturnExchangeScalarWhereInput | ReturnExchangeScalarWhereInput[]
    id?: IntFilter<"ReturnExchange"> | number
    orderId?: IntFilter<"ReturnExchange"> | number
    reason?: StringFilter<"ReturnExchange"> | string
    status?: EnumReturnExchangeStatusFilter<"ReturnExchange"> | $Enums.ReturnExchangeStatus
    requestedAt?: DateTimeFilter<"ReturnExchange"> | Date | string
    completedAt?: DateTimeNullableFilter<"ReturnExchange"> | Date | string | null
  }

  export type OrdersCreateWithoutOrderHistoryInput = {
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    user: UserCreateNestedOneWithoutOrdersInput
    orderStatus: OrderStatusCreateNestedOneWithoutOrdersInput
    deliveryAddress: AddressesCreateNestedOneWithoutOrderInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemsCreateNestedManyWithoutOrderInput
    shipping?: ShippingCreateNestedOneWithoutOrderInput
    ReturnExchange?: ReturnExchangeCreateNestedManyWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutOrderHistoryInput = {
    id?: number
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    userId: number
    orderStatusId: number
    deliveryAddressId: number
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutOrderInput
    shipping?: ShippingUncheckedCreateNestedOneWithoutOrderInput
    ReturnExchange?: ReturnExchangeUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutOrderHistoryInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutOrderHistoryInput, OrdersUncheckedCreateWithoutOrderHistoryInput>
  }

  export type OrdersUpsertWithoutOrderHistoryInput = {
    update: XOR<OrdersUpdateWithoutOrderHistoryInput, OrdersUncheckedUpdateWithoutOrderHistoryInput>
    create: XOR<OrdersCreateWithoutOrderHistoryInput, OrdersUncheckedCreateWithoutOrderHistoryInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutOrderHistoryInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutOrderHistoryInput, OrdersUncheckedUpdateWithoutOrderHistoryInput>
  }

  export type OrdersUpdateWithoutOrderHistoryInput = {
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    orderStatus?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    deliveryAddress?: AddressesUpdateOneRequiredWithoutOrderNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemsUpdateManyWithoutOrderNestedInput
    shipping?: ShippingUpdateOneWithoutOrderNestedInput
    ReturnExchange?: ReturnExchangeUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutOrderHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    orderStatusId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: IntFieldUpdateOperationsInput | number
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutOrderNestedInput
    shipping?: ShippingUncheckedUpdateOneWithoutOrderNestedInput
    ReturnExchange?: ReturnExchangeUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrdersCreateWithoutOrderItemsInput = {
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    user: UserCreateNestedOneWithoutOrdersInput
    orderStatus: OrderStatusCreateNestedOneWithoutOrdersInput
    deliveryAddress: AddressesCreateNestedOneWithoutOrderInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutOrderInput
    orderHistory?: OrderHistoryCreateNestedManyWithoutOrderInput
    shipping?: ShippingCreateNestedOneWithoutOrderInput
    ReturnExchange?: ReturnExchangeCreateNestedManyWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    userId: number
    orderStatusId: number
    deliveryAddressId: number
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutOrderInput
    orderHistory?: OrderHistoryUncheckedCreateNestedManyWithoutOrderInput
    shipping?: ShippingUncheckedCreateNestedOneWithoutOrderInput
    ReturnExchange?: ReturnExchangeUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutOrderItemsInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutOrderItemsInput, OrdersUncheckedCreateWithoutOrderItemsInput>
  }

  export type ProductsCreateWithoutOrderItemsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    store: StoresCreateNestedOneWithoutProductInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    images?: ProductImagesCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsCreateNestedManyWithoutProductInput
    promotions?: PromotionCreateNestedManyWithoutProductsInput
    cartItem?: CartItemsCreateNestedManyWithoutProductInput
    wishlists?: WishlistCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    storeId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    images?: ProductImagesUncheckedCreateNestedManyWithoutProductInput
    category?: CategoryUncheckedCreateNestedManyWithoutProductInput
    avaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutProductInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutProductsInput
    cartItem?: CartItemsUncheckedCreateNestedManyWithoutProductInput
    wishlists?: WishlistUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutOrderItemsInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutOrderItemsInput, ProductsUncheckedCreateWithoutOrderItemsInput>
  }

  export type StoresCreateWithoutOrderItemsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    user: UserCreateNestedOneWithoutStoreInput
    avatar?: AvatarStoreCreateNestedOneWithoutStoreAvatarInput
    product?: ProductsCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsCreateNestedManyWithoutStoreInput
    coupons?: CouponsCreateNestedManyWithoutStoreInput
    chat?: ChatCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverStoreInput
    promotions?: PromotionCreateNestedManyWithoutStoreInput
  }

  export type StoresUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    avatarId?: number | null
    product?: ProductsUncheckedCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutStoreInput
    coupons?: CouponsUncheckedCreateNestedManyWithoutStoreInput
    chat?: ChatUncheckedCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverStoreInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoresCreateOrConnectWithoutOrderItemsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutOrderItemsInput, StoresUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrdersUpsertWithoutOrderItemsInput = {
    update: XOR<OrdersUpdateWithoutOrderItemsInput, OrdersUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<OrdersCreateWithoutOrderItemsInput, OrdersUncheckedCreateWithoutOrderItemsInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutOrderItemsInput, OrdersUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrdersUpdateWithoutOrderItemsInput = {
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    orderStatus?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    deliveryAddress?: AddressesUpdateOneRequiredWithoutOrderNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutOrderNestedInput
    orderHistory?: OrderHistoryUpdateManyWithoutOrderNestedInput
    shipping?: ShippingUpdateOneWithoutOrderNestedInput
    ReturnExchange?: ReturnExchangeUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    orderStatusId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: IntFieldUpdateOperationsInput | number
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutOrderNestedInput
    orderHistory?: OrderHistoryUncheckedUpdateManyWithoutOrderNestedInput
    shipping?: ShippingUncheckedUpdateOneWithoutOrderNestedInput
    ReturnExchange?: ReturnExchangeUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductsUpsertWithoutOrderItemsInput = {
    update: XOR<ProductsUpdateWithoutOrderItemsInput, ProductsUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductsCreateWithoutOrderItemsInput, ProductsUncheckedCreateWithoutOrderItemsInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutOrderItemsInput, ProductsUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductsUpdateWithoutOrderItemsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    store?: StoresUpdateOneRequiredWithoutProductNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    images?: ProductImagesUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUpdateManyWithoutProductNestedInput
    promotions?: PromotionUpdateManyWithoutProductsNestedInput
    cartItem?: CartItemsUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    images?: ProductImagesUncheckedUpdateManyWithoutProductNestedInput
    category?: CategoryUncheckedUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUncheckedUpdateManyWithoutProductNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutProductsNestedInput
    cartItem?: CartItemsUncheckedUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type StoresUpsertWithoutOrderItemsInput = {
    update: XOR<StoresUpdateWithoutOrderItemsInput, StoresUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<StoresCreateWithoutOrderItemsInput, StoresUncheckedCreateWithoutOrderItemsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutOrderItemsInput, StoresUncheckedUpdateWithoutOrderItemsInput>
  }

  export type StoresUpdateWithoutOrderItemsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStoreNestedInput
    avatar?: AvatarStoreUpdateOneWithoutStoreAvatarNestedInput
    product?: ProductsUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUpdateManyWithoutStoreNestedInput
    chat?: ChatUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverStoreNestedInput
    promotions?: PromotionUpdateManyWithoutStoreNestedInput
  }

  export type StoresUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    product?: ProductsUncheckedUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUncheckedUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUncheckedUpdateManyWithoutStoreNestedInput
    chat?: ChatUncheckedUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverStoreNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type OrdersCreateWithoutShippingInput = {
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    user: UserCreateNestedOneWithoutOrdersInput
    orderStatus: OrderStatusCreateNestedOneWithoutOrdersInput
    deliveryAddress: AddressesCreateNestedOneWithoutOrderInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemsCreateNestedManyWithoutOrderInput
    orderHistory?: OrderHistoryCreateNestedManyWithoutOrderInput
    ReturnExchange?: ReturnExchangeCreateNestedManyWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutShippingInput = {
    id?: number
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    userId: number
    orderStatusId: number
    deliveryAddressId: number
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutOrderInput
    orderHistory?: OrderHistoryUncheckedCreateNestedManyWithoutOrderInput
    ReturnExchange?: ReturnExchangeUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutShippingInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutShippingInput, OrdersUncheckedCreateWithoutShippingInput>
  }

  export type OrdersUpsertWithoutShippingInput = {
    update: XOR<OrdersUpdateWithoutShippingInput, OrdersUncheckedUpdateWithoutShippingInput>
    create: XOR<OrdersCreateWithoutShippingInput, OrdersUncheckedCreateWithoutShippingInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutShippingInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutShippingInput, OrdersUncheckedUpdateWithoutShippingInput>
  }

  export type OrdersUpdateWithoutShippingInput = {
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    orderStatus?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    deliveryAddress?: AddressesUpdateOneRequiredWithoutOrderNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemsUpdateManyWithoutOrderNestedInput
    orderHistory?: OrderHistoryUpdateManyWithoutOrderNestedInput
    ReturnExchange?: ReturnExchangeUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutShippingInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    orderStatusId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: IntFieldUpdateOperationsInput | number
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutOrderNestedInput
    orderHistory?: OrderHistoryUncheckedUpdateManyWithoutOrderNestedInput
    ReturnExchange?: ReturnExchangeUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserCreateWithoutChatInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatInput, UserUncheckedCreateWithoutChatInput>
  }

  export type StoresCreateWithoutChatInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    user: UserCreateNestedOneWithoutStoreInput
    avatar?: AvatarStoreCreateNestedOneWithoutStoreAvatarInput
    product?: ProductsCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsCreateNestedManyWithoutStoreInput
    coupons?: CouponsCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoreInput
    promotions?: PromotionCreateNestedManyWithoutStoreInput
  }

  export type StoresUncheckedCreateWithoutChatInput = {
    id?: number
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    avatarId?: number | null
    product?: ProductsUncheckedCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutStoreInput
    coupons?: CouponsUncheckedCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderStoreInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoreInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoresCreateOrConnectWithoutChatInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutChatInput, StoresUncheckedCreateWithoutChatInput>
  }

  export type chatMessagesCreateWithoutChatInput = {
    content: string
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
    senderUser?: UserCreateNestedOneWithoutSentMessagesInput
    senderStore?: StoresCreateNestedOneWithoutSentMessagesInput
    receiverUser?: UserCreateNestedOneWithoutReceivedMessagesInput
    receiverStore?: StoresCreateNestedOneWithoutReceivedMessagesInput
    image?: MessageImagesCreateNestedOneWithoutMessageImageInput
  }

  export type chatMessagesUncheckedCreateWithoutChatInput = {
    id?: number
    content: string
    senderUserId?: number | null
    senderStoreId?: number | null
    receiverUserId?: number | null
    receiverStoreId?: number | null
    imageId?: number | null
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
  }

  export type chatMessagesCreateOrConnectWithoutChatInput = {
    where: chatMessagesWhereUniqueInput
    create: XOR<chatMessagesCreateWithoutChatInput, chatMessagesUncheckedCreateWithoutChatInput>
  }

  export type chatMessagesCreateManyChatInputEnvelope = {
    data: chatMessagesCreateManyChatInput | chatMessagesCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutChatInput = {
    update: XOR<UserUpdateWithoutChatInput, UserUncheckedUpdateWithoutChatInput>
    create: XOR<UserCreateWithoutChatInput, UserUncheckedCreateWithoutChatInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatInput, UserUncheckedUpdateWithoutChatInput>
  }

  export type UserUpdateWithoutChatInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StoresUpsertWithoutChatInput = {
    update: XOR<StoresUpdateWithoutChatInput, StoresUncheckedUpdateWithoutChatInput>
    create: XOR<StoresCreateWithoutChatInput, StoresUncheckedCreateWithoutChatInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutChatInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutChatInput, StoresUncheckedUpdateWithoutChatInput>
  }

  export type StoresUpdateWithoutChatInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStoreNestedInput
    avatar?: AvatarStoreUpdateOneWithoutStoreAvatarNestedInput
    product?: ProductsUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUpdateManyWithoutStoreNestedInput
  }

  export type StoresUncheckedUpdateWithoutChatInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    product?: ProductsUncheckedUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUncheckedUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUncheckedUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderStoreNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type chatMessagesUpsertWithWhereUniqueWithoutChatInput = {
    where: chatMessagesWhereUniqueInput
    update: XOR<chatMessagesUpdateWithoutChatInput, chatMessagesUncheckedUpdateWithoutChatInput>
    create: XOR<chatMessagesCreateWithoutChatInput, chatMessagesUncheckedCreateWithoutChatInput>
  }

  export type chatMessagesUpdateWithWhereUniqueWithoutChatInput = {
    where: chatMessagesWhereUniqueInput
    data: XOR<chatMessagesUpdateWithoutChatInput, chatMessagesUncheckedUpdateWithoutChatInput>
  }

  export type chatMessagesUpdateManyWithWhereWithoutChatInput = {
    where: chatMessagesScalarWhereInput
    data: XOR<chatMessagesUpdateManyMutationInput, chatMessagesUncheckedUpdateManyWithoutChatInput>
  }

  export type ChatCreateWithoutMessagesInput = {
    user: UserCreateNestedOneWithoutChatInput
    store: StoresCreateNestedOneWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutMessagesInput = {
    id?: number
    userId: number
    storeId: number
  }

  export type ChatCreateOrConnectWithoutMessagesInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type StoresCreateWithoutSentMessagesInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    user: UserCreateNestedOneWithoutStoreInput
    avatar?: AvatarStoreCreateNestedOneWithoutStoreAvatarInput
    product?: ProductsCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsCreateNestedManyWithoutStoreInput
    coupons?: CouponsCreateNestedManyWithoutStoreInput
    chat?: ChatCreateNestedManyWithoutStoreInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoreInput
    promotions?: PromotionCreateNestedManyWithoutStoreInput
  }

  export type StoresUncheckedCreateWithoutSentMessagesInput = {
    id?: number
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    avatarId?: number | null
    product?: ProductsUncheckedCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutStoreInput
    coupons?: CouponsUncheckedCreateNestedManyWithoutStoreInput
    chat?: ChatUncheckedCreateNestedManyWithoutStoreInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverStoreInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoreInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoresCreateOrConnectWithoutSentMessagesInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutSentMessagesInput, StoresUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type StoresCreateWithoutReceivedMessagesInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    user: UserCreateNestedOneWithoutStoreInput
    avatar?: AvatarStoreCreateNestedOneWithoutStoreAvatarInput
    product?: ProductsCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsCreateNestedManyWithoutStoreInput
    coupons?: CouponsCreateNestedManyWithoutStoreInput
    chat?: ChatCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderStoreInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoreInput
    promotions?: PromotionCreateNestedManyWithoutStoreInput
  }

  export type StoresUncheckedCreateWithoutReceivedMessagesInput = {
    id?: number
    userId: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cnpj?: string | null
    avatarId?: number | null
    product?: ProductsUncheckedCreateNestedManyWithoutStoreInput
    avaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutStoreInput
    coupons?: CouponsUncheckedCreateNestedManyWithoutStoreInput
    chat?: ChatUncheckedCreateNestedManyWithoutStoreInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderStoreInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoreInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoresCreateOrConnectWithoutReceivedMessagesInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutReceivedMessagesInput, StoresUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type MessageImagesCreateWithoutMessageImageInput = {
    url: string
    publicId: string
  }

  export type MessageImagesUncheckedCreateWithoutMessageImageInput = {
    id?: number
    url: string
    publicId: string
  }

  export type MessageImagesCreateOrConnectWithoutMessageImageInput = {
    where: MessageImagesWhereUniqueInput
    create: XOR<MessageImagesCreateWithoutMessageImageInput, MessageImagesUncheckedCreateWithoutMessageImageInput>
  }

  export type ChatUpsertWithoutMessagesInput = {
    update: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatUpdateWithoutMessagesInput = {
    user?: UserUpdateOneRequiredWithoutChatNestedInput
    store?: StoresUpdateOneRequiredWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StoresUpsertWithoutSentMessagesInput = {
    update: XOR<StoresUpdateWithoutSentMessagesInput, StoresUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<StoresCreateWithoutSentMessagesInput, StoresUncheckedCreateWithoutSentMessagesInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutSentMessagesInput, StoresUncheckedUpdateWithoutSentMessagesInput>
  }

  export type StoresUpdateWithoutSentMessagesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStoreNestedInput
    avatar?: AvatarStoreUpdateOneWithoutStoreAvatarNestedInput
    product?: ProductsUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUpdateManyWithoutStoreNestedInput
    chat?: ChatUpdateManyWithoutStoreNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUpdateManyWithoutStoreNestedInput
  }

  export type StoresUncheckedUpdateWithoutSentMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    product?: ProductsUncheckedUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUncheckedUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUncheckedUpdateManyWithoutStoreNestedInput
    chat?: ChatUncheckedUpdateManyWithoutStoreNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverStoreNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StoresUpsertWithoutReceivedMessagesInput = {
    update: XOR<StoresUpdateWithoutReceivedMessagesInput, StoresUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<StoresCreateWithoutReceivedMessagesInput, StoresUncheckedCreateWithoutReceivedMessagesInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutReceivedMessagesInput, StoresUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type StoresUpdateWithoutReceivedMessagesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStoreNestedInput
    avatar?: AvatarStoreUpdateOneWithoutStoreAvatarNestedInput
    product?: ProductsUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUpdateManyWithoutStoreNestedInput
    chat?: ChatUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderStoreNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUpdateManyWithoutStoreNestedInput
  }

  export type StoresUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    product?: ProductsUncheckedUpdateManyWithoutStoreNestedInput
    avaliations?: StoreAvaliationsUncheckedUpdateManyWithoutStoreNestedInput
    coupons?: CouponsUncheckedUpdateManyWithoutStoreNestedInput
    chat?: ChatUncheckedUpdateManyWithoutStoreNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderStoreNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoreNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type MessageImagesUpsertWithoutMessageImageInput = {
    update: XOR<MessageImagesUpdateWithoutMessageImageInput, MessageImagesUncheckedUpdateWithoutMessageImageInput>
    create: XOR<MessageImagesCreateWithoutMessageImageInput, MessageImagesUncheckedCreateWithoutMessageImageInput>
    where?: MessageImagesWhereInput
  }

  export type MessageImagesUpdateToOneWithWhereWithoutMessageImageInput = {
    where?: MessageImagesWhereInput
    data: XOR<MessageImagesUpdateWithoutMessageImageInput, MessageImagesUncheckedUpdateWithoutMessageImageInput>
  }

  export type MessageImagesUpdateWithoutMessageImageInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageImagesUncheckedUpdateWithoutMessageImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type chatMessagesCreateWithoutImageInput = {
    content: string
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
    chat: ChatCreateNestedOneWithoutMessagesInput
    senderUser?: UserCreateNestedOneWithoutSentMessagesInput
    senderStore?: StoresCreateNestedOneWithoutSentMessagesInput
    receiverUser?: UserCreateNestedOneWithoutReceivedMessagesInput
    receiverStore?: StoresCreateNestedOneWithoutReceivedMessagesInput
  }

  export type chatMessagesUncheckedCreateWithoutImageInput = {
    id?: number
    content: string
    chatId: number
    senderUserId?: number | null
    senderStoreId?: number | null
    receiverUserId?: number | null
    receiverStoreId?: number | null
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
  }

  export type chatMessagesCreateOrConnectWithoutImageInput = {
    where: chatMessagesWhereUniqueInput
    create: XOR<chatMessagesCreateWithoutImageInput, chatMessagesUncheckedCreateWithoutImageInput>
  }

  export type chatMessagesUpsertWithoutImageInput = {
    update: XOR<chatMessagesUpdateWithoutImageInput, chatMessagesUncheckedUpdateWithoutImageInput>
    create: XOR<chatMessagesCreateWithoutImageInput, chatMessagesUncheckedCreateWithoutImageInput>
    where?: chatMessagesWhereInput
  }

  export type chatMessagesUpdateToOneWithWhereWithoutImageInput = {
    where?: chatMessagesWhereInput
    data: XOR<chatMessagesUpdateWithoutImageInput, chatMessagesUncheckedUpdateWithoutImageInput>
  }

  export type chatMessagesUpdateWithoutImageInput = {
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
    senderUser?: UserUpdateOneWithoutSentMessagesNestedInput
    senderStore?: StoresUpdateOneWithoutSentMessagesNestedInput
    receiverUser?: UserUpdateOneWithoutReceivedMessagesNestedInput
    receiverStore?: StoresUpdateOneWithoutReceivedMessagesNestedInput
  }

  export type chatMessagesUncheckedUpdateWithoutImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    chatId?: IntFieldUpdateOperationsInput | number
    senderUserId?: NullableIntFieldUpdateOperationsInput | number | null
    senderStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateWithoutTokenLoginInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTokenLoginInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTokenLoginInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTokenLoginInput, UserUncheckedCreateWithoutTokenLoginInput>
  }

  export type UserUpsertWithoutTokenLoginInput = {
    update: XOR<UserUpdateWithoutTokenLoginInput, UserUncheckedUpdateWithoutTokenLoginInput>
    create: XOR<UserCreateWithoutTokenLoginInput, UserUncheckedCreateWithoutTokenLoginInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTokenLoginInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTokenLoginInput, UserUncheckedUpdateWithoutTokenLoginInput>
  }

  export type UserUpdateWithoutTokenLoginInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTokenLoginInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutConfirmationTokenInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConfirmationTokenInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConfirmationTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConfirmationTokenInput, UserUncheckedCreateWithoutConfirmationTokenInput>
  }

  export type UserUpsertWithoutConfirmationTokenInput = {
    update: XOR<UserUpdateWithoutConfirmationTokenInput, UserUncheckedUpdateWithoutConfirmationTokenInput>
    create: XOR<UserCreateWithoutConfirmationTokenInput, UserUncheckedCreateWithoutConfirmationTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConfirmationTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConfirmationTokenInput, UserUncheckedUpdateWithoutConfirmationTokenInput>
  }

  export type UserUpdateWithoutConfirmationTokenInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConfirmationTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLogsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type UserUpsertWithoutLogsInput = {
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateWithoutLogsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTwoFactorAuthInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTwoFactorAuthInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    AbandonedCart?: AbandonedCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTwoFactorAuthInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTwoFactorAuthInput, UserUncheckedCreateWithoutTwoFactorAuthInput>
  }

  export type UserUpsertWithoutTwoFactorAuthInput = {
    update: XOR<UserUpdateWithoutTwoFactorAuthInput, UserUncheckedUpdateWithoutTwoFactorAuthInput>
    create: XOR<UserCreateWithoutTwoFactorAuthInput, UserUncheckedCreateWithoutTwoFactorAuthInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTwoFactorAuthInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTwoFactorAuthInput, UserUncheckedUpdateWithoutTwoFactorAuthInput>
  }

  export type UserUpdateWithoutTwoFactorAuthInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTwoFactorAuthInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    AbandonedCart?: AbandonedCartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAbandonedCartInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    avatar?: AvatarUserCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    principalAddress?: AddressesCreateNestedOneWithoutPrincipalOfInput
    addresses?: AddressesCreateNestedManyWithoutUserInput
    store?: StoresCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsCreateNestedManyWithoutUserInput
    cart: CartCreateNestedOneWithoutUserCartInput
    orders?: OrdersCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesCreateNestedManyWithoutReceiverUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthCreateNestedManyWithoutUserInput
    Wishlist?: WishlistCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAbandonedCartInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    cpf: string
    email: string
    password: string
    bornDate: Date | string
    avatarId?: number | null
    principalAddressId?: number | null
    cartId: number
    avatar?: AvatarUserUncheckedCreateNestedOneWithoutUserInput
    tokenLogin?: LoginTokenUncheckedCreateNestedOneWithoutUserInput
    confirmationToken?: ConfirmationTokenUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    addresses?: AddressesUncheckedCreateNestedManyWithoutUserInput
    store?: StoresUncheckedCreateNestedOneWithoutUserInput
    productAvaliations?: ProductAvaliationsUncheckedCreateNestedManyWithoutUserInput
    storeAvaliations?: StoreAvaliationsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrdersUncheckedCreateNestedManyWithoutUserInput
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: chatMessagesUncheckedCreateNestedManyWithoutSenderUserInput
    receivedMessages?: chatMessagesUncheckedCreateNestedManyWithoutReceiverUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    TwoFactorAuth?: TwoFactorAuthUncheckedCreateNestedManyWithoutUserInput
    Wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAbandonedCartInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAbandonedCartInput, UserUncheckedCreateWithoutAbandonedCartInput>
  }

  export type CartItemsCreateWithoutAbandonedCartInput = {
    quantidade: number
    cart: CartCreateNestedOneWithoutCartItemsInput
    product: ProductsCreateNestedOneWithoutCartItemInput
  }

  export type CartItemsUncheckedCreateWithoutAbandonedCartInput = {
    id?: number
    cartId: number
    productId: number
    quantidade: number
  }

  export type CartItemsCreateOrConnectWithoutAbandonedCartInput = {
    where: CartItemsWhereUniqueInput
    create: XOR<CartItemsCreateWithoutAbandonedCartInput, CartItemsUncheckedCreateWithoutAbandonedCartInput>
  }

  export type CartItemsCreateManyAbandonedCartInputEnvelope = {
    data: CartItemsCreateManyAbandonedCartInput | CartItemsCreateManyAbandonedCartInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAbandonedCartInput = {
    update: XOR<UserUpdateWithoutAbandonedCartInput, UserUncheckedUpdateWithoutAbandonedCartInput>
    create: XOR<UserCreateWithoutAbandonedCartInput, UserUncheckedCreateWithoutAbandonedCartInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAbandonedCartInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAbandonedCartInput, UserUncheckedUpdateWithoutAbandonedCartInput>
  }

  export type UserUpdateWithoutAbandonedCartInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    avatar?: AvatarUserUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    principalAddress?: AddressesUpdateOneWithoutPrincipalOfNestedInput
    addresses?: AddressesUpdateManyWithoutUserNestedInput
    store?: StoresUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneRequiredWithoutUserCartNestedInput
    orders?: OrdersUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAbandonedCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    bornDate?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarId?: NullableIntFieldUpdateOperationsInput | number | null
    principalAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    cartId?: IntFieldUpdateOperationsInput | number
    avatar?: AvatarUserUncheckedUpdateOneWithoutUserNestedInput
    tokenLogin?: LoginTokenUncheckedUpdateOneWithoutUserNestedInput
    confirmationToken?: ConfirmationTokenUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    addresses?: AddressesUncheckedUpdateManyWithoutUserNestedInput
    store?: StoresUncheckedUpdateOneWithoutUserNestedInput
    productAvaliations?: ProductAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    storeAvaliations?: StoreAvaliationsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutUserNestedInput
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: chatMessagesUncheckedUpdateManyWithoutSenderUserNestedInput
    receivedMessages?: chatMessagesUncheckedUpdateManyWithoutReceiverUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    TwoFactorAuth?: TwoFactorAuthUncheckedUpdateManyWithoutUserNestedInput
    Wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CartItemsUpsertWithWhereUniqueWithoutAbandonedCartInput = {
    where: CartItemsWhereUniqueInput
    update: XOR<CartItemsUpdateWithoutAbandonedCartInput, CartItemsUncheckedUpdateWithoutAbandonedCartInput>
    create: XOR<CartItemsCreateWithoutAbandonedCartInput, CartItemsUncheckedCreateWithoutAbandonedCartInput>
  }

  export type CartItemsUpdateWithWhereUniqueWithoutAbandonedCartInput = {
    where: CartItemsWhereUniqueInput
    data: XOR<CartItemsUpdateWithoutAbandonedCartInput, CartItemsUncheckedUpdateWithoutAbandonedCartInput>
  }

  export type CartItemsUpdateManyWithWhereWithoutAbandonedCartInput = {
    where: CartItemsScalarWhereInput
    data: XOR<CartItemsUpdateManyMutationInput, CartItemsUncheckedUpdateManyWithoutAbandonedCartInput>
  }

  export type OrdersCreateWithoutReturnExchangeInput = {
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    user: UserCreateNestedOneWithoutOrdersInput
    orderStatus: OrderStatusCreateNestedOneWithoutOrdersInput
    deliveryAddress: AddressesCreateNestedOneWithoutOrderInput
    usedCoupons?: UserUsedCouponsCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemsCreateNestedManyWithoutOrderInput
    orderHistory?: OrderHistoryCreateNestedManyWithoutOrderInput
    shipping?: ShippingCreateNestedOneWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutReturnExchangeInput = {
    id?: number
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    userId: number
    orderStatusId: number
    deliveryAddressId: number
    usedCoupons?: UserUsedCouponsUncheckedCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutOrderInput
    orderHistory?: OrderHistoryUncheckedCreateNestedManyWithoutOrderInput
    shipping?: ShippingUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutReturnExchangeInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutReturnExchangeInput, OrdersUncheckedCreateWithoutReturnExchangeInput>
  }

  export type OrdersUpsertWithoutReturnExchangeInput = {
    update: XOR<OrdersUpdateWithoutReturnExchangeInput, OrdersUncheckedUpdateWithoutReturnExchangeInput>
    create: XOR<OrdersCreateWithoutReturnExchangeInput, OrdersUncheckedCreateWithoutReturnExchangeInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutReturnExchangeInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutReturnExchangeInput, OrdersUncheckedUpdateWithoutReturnExchangeInput>
  }

  export type OrdersUpdateWithoutReturnExchangeInput = {
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    orderStatus?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    deliveryAddress?: AddressesUpdateOneRequiredWithoutOrderNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemsUpdateManyWithoutOrderNestedInput
    orderHistory?: OrderHistoryUpdateManyWithoutOrderNestedInput
    shipping?: ShippingUpdateOneWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutReturnExchangeInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    orderStatusId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: IntFieldUpdateOperationsInput | number
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutOrderNestedInput
    orderHistory?: OrderHistoryUncheckedUpdateManyWithoutOrderNestedInput
    shipping?: ShippingUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type AddressesCreateManyUserInput = {
    id?: number
    cep: string
    road: string
    number: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    country?: string
    type?: string | null
    reference?: string | null
  }

  export type ProductAvaliationsCreateManyUserInput = {
    id?: number
    productId: number
    note: number
    avaliationDate?: Date | string
    comment?: string | null
  }

  export type StoreAvaliationsCreateManyUserInput = {
    id?: number
    storeId: number
    note: number
    avaliationDate?: Date | string
    comment?: string | null
  }

  export type OrdersCreateManyUserInput = {
    id?: number
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    orderStatusId: number
    deliveryAddressId: number
  }

  export type UserUsedCouponsCreateManyUserInput = {
    id?: number
    couponId: number
    usedAt?: Date | string
    orderId?: number | null
  }

  export type ChatCreateManyUserInput = {
    id?: number
    storeId: number
  }

  export type chatMessagesCreateManySenderUserInput = {
    id?: number
    content: string
    chatId: number
    senderStoreId?: number | null
    receiverUserId?: number | null
    receiverStoreId?: number | null
    imageId?: number | null
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
  }

  export type chatMessagesCreateManyReceiverUserInput = {
    id?: number
    content: string
    chatId: number
    senderUserId?: number | null
    senderStoreId?: number | null
    receiverStoreId?: number | null
    imageId?: number | null
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
  }

  export type LogCreateManyUserInput = {
    id?: number
    action: string
    tableName: string
    recordId?: number | null
    timestamp?: Date | string
    details?: string | null
  }

  export type TwoFactorAuthCreateManyUserInput = {
    id?: number
    secret: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AbandonedCartCreateManyUserInput = {
    id?: number
    abandonedAt?: Date | string
  }

  export type AddressesUpdateWithoutUserInput = {
    cep?: StringFieldUpdateOperationsInput | string
    road?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    principalOf?: UserUpdateOneWithoutPrincipalAddressNestedInput
    order?: OrdersUpdateManyWithoutDeliveryAddressNestedInput
  }

  export type AddressesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    road?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    principalOf?: UserUncheckedUpdateOneWithoutPrincipalAddressNestedInput
    order?: OrdersUncheckedUpdateManyWithoutDeliveryAddressNestedInput
  }

  export type AddressesUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    road?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductAvaliationsUpdateWithoutUserInput = {
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductsUpdateOneRequiredWithoutAvaliationsNestedInput
    images?: ProductAvaliationImagesUpdateManyWithoutProductAvaliationNestedInput
  }

  export type ProductAvaliationsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductAvaliationImagesUncheckedUpdateManyWithoutProductAvaliationNestedInput
  }

  export type ProductAvaliationsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreAvaliationsUpdateWithoutUserInput = {
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    store?: StoresUpdateOneRequiredWithoutAvaliationsNestedInput
    images?: StoreAvaliationImagesUpdateManyWithoutStoreAvaliationNestedInput
  }

  export type StoreAvaliationsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: StoreAvaliationImagesUncheckedUpdateManyWithoutStoreAvaliationNestedInput
  }

  export type StoreAvaliationsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrdersUpdateWithoutUserInput = {
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    orderStatus?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    deliveryAddress?: AddressesUpdateOneRequiredWithoutOrderNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemsUpdateManyWithoutOrderNestedInput
    orderHistory?: OrderHistoryUpdateManyWithoutOrderNestedInput
    shipping?: ShippingUpdateOneWithoutOrderNestedInput
    ReturnExchange?: ReturnExchangeUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    orderStatusId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: IntFieldUpdateOperationsInput | number
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutOrderNestedInput
    orderHistory?: OrderHistoryUncheckedUpdateManyWithoutOrderNestedInput
    shipping?: ShippingUncheckedUpdateOneWithoutOrderNestedInput
    ReturnExchange?: ReturnExchangeUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    orderStatusId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUsedCouponsUpdateWithoutUserInput = {
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon?: CouponsUpdateOneRequiredWithoutUsedCouponsNestedInput
    order?: OrdersUpdateOneWithoutUsedCouponsNestedInput
  }

  export type UserUsedCouponsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    couponId?: IntFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUsedCouponsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    couponId?: IntFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ChatUpdateWithoutUserInput = {
    store?: StoresUpdateOneRequiredWithoutChatNestedInput
    messages?: chatMessagesUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    messages?: chatMessagesUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type chatMessagesUpdateWithoutSenderUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
    senderStore?: StoresUpdateOneWithoutSentMessagesNestedInput
    receiverUser?: UserUpdateOneWithoutReceivedMessagesNestedInput
    receiverStore?: StoresUpdateOneWithoutReceivedMessagesNestedInput
    image?: MessageImagesUpdateOneWithoutMessageImageNestedInput
  }

  export type chatMessagesUncheckedUpdateWithoutSenderUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    chatId?: IntFieldUpdateOperationsInput | number
    senderStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chatMessagesUncheckedUpdateManyWithoutSenderUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    chatId?: IntFieldUpdateOperationsInput | number
    senderStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chatMessagesUpdateWithoutReceiverUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
    senderUser?: UserUpdateOneWithoutSentMessagesNestedInput
    senderStore?: StoresUpdateOneWithoutSentMessagesNestedInput
    receiverStore?: StoresUpdateOneWithoutReceivedMessagesNestedInput
    image?: MessageImagesUpdateOneWithoutMessageImageNestedInput
  }

  export type chatMessagesUncheckedUpdateWithoutReceiverUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    chatId?: IntFieldUpdateOperationsInput | number
    senderUserId?: NullableIntFieldUpdateOperationsInput | number | null
    senderStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chatMessagesUncheckedUpdateManyWithoutReceiverUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    chatId?: IntFieldUpdateOperationsInput | number
    senderUserId?: NullableIntFieldUpdateOperationsInput | number | null
    senderStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LogUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TwoFactorAuthUpdateWithoutUserInput = {
    secret?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAuthUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    secret?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAuthUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    secret?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductsUpdateManyWithoutWishlistsNestedInput
  }

  export type WishlistUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductsUncheckedUpdateManyWithoutWishlistsNestedInput
  }

  export type WishlistUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AbandonedCartUpdateWithoutUserInput = {
    abandonedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemsUpdateManyWithoutAbandonedCartNestedInput
  }

  export type AbandonedCartUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    abandonedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemsUncheckedUpdateManyWithoutAbandonedCartNestedInput
  }

  export type AbandonedCartUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    abandonedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdersCreateManyDeliveryAddressInput = {
    id?: number
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    userId: number
    orderStatusId: number
  }

  export type OrdersUpdateWithoutDeliveryAddressInput = {
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    orderStatus?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemsUpdateManyWithoutOrderNestedInput
    orderHistory?: OrderHistoryUpdateManyWithoutOrderNestedInput
    shipping?: ShippingUpdateOneWithoutOrderNestedInput
    ReturnExchange?: ReturnExchangeUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutDeliveryAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    orderStatusId?: IntFieldUpdateOperationsInput | number
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutOrderNestedInput
    orderHistory?: OrderHistoryUncheckedUpdateManyWithoutOrderNestedInput
    shipping?: ShippingUncheckedUpdateOneWithoutOrderNestedInput
    ReturnExchange?: ReturnExchangeUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateManyWithoutDeliveryAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    orderStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductsCreateManyStoreInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    price: Decimal | DecimalJsLike | number | string
  }

  export type StoreAvaliationsCreateManyStoreInput = {
    id?: number
    userId: number
    note: number
    avaliationDate?: Date | string
    comment?: string | null
  }

  export type CouponsCreateManyStoreInput = {
    id?: number
    code: string
    expirationDate: Date | string
    percentageDiscount: number
    discountValue: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatCreateManyStoreInput = {
    id?: number
    userId: number
  }

  export type chatMessagesCreateManySenderStoreInput = {
    id?: number
    content: string
    chatId: number
    senderUserId?: number | null
    receiverUserId?: number | null
    receiverStoreId?: number | null
    imageId?: number | null
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
  }

  export type chatMessagesCreateManyReceiverStoreInput = {
    id?: number
    content: string
    chatId: number
    senderUserId?: number | null
    senderStoreId?: number | null
    receiverUserId?: number | null
    imageId?: number | null
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
  }

  export type OrderItemsCreateManyStoreInput = {
    id?: number
    orderId: number
    productId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
  }

  export type PromotionCreateManyStoreInput = {
    id?: number
    code: string
    description: string
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductsUpdateWithoutStoreInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    images?: ProductImagesUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUpdateManyWithoutProductNestedInput
    promotions?: PromotionUpdateManyWithoutProductsNestedInput
    cartItem?: CartItemsUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemsUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    images?: ProductImagesUncheckedUpdateManyWithoutProductNestedInput
    category?: CategoryUncheckedUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUncheckedUpdateManyWithoutProductNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutProductsNestedInput
    cartItem?: CartItemsUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateManyWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StoreAvaliationsUpdateWithoutStoreInput = {
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStoreAvaliationsNestedInput
    images?: StoreAvaliationImagesUpdateManyWithoutStoreAvaliationNestedInput
  }

  export type StoreAvaliationsUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: StoreAvaliationImagesUncheckedUpdateManyWithoutStoreAvaliationNestedInput
  }

  export type StoreAvaliationsUncheckedUpdateManyWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CouponsUpdateWithoutStoreInput = {
    code?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentageDiscount?: IntFieldUpdateOperationsInput | number
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupons?: UserUsedCouponsUpdateManyWithoutCouponNestedInput
  }

  export type CouponsUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentageDiscount?: IntFieldUpdateOperationsInput | number
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type CouponsUncheckedUpdateManyWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentageDiscount?: IntFieldUpdateOperationsInput | number
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUpdateWithoutStoreInput = {
    user?: UserUpdateOneRequiredWithoutChatNestedInput
    messages?: chatMessagesUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    messages?: chatMessagesUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type chatMessagesUpdateWithoutSenderStoreInput = {
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
    senderUser?: UserUpdateOneWithoutSentMessagesNestedInput
    receiverUser?: UserUpdateOneWithoutReceivedMessagesNestedInput
    receiverStore?: StoresUpdateOneWithoutReceivedMessagesNestedInput
    image?: MessageImagesUpdateOneWithoutMessageImageNestedInput
  }

  export type chatMessagesUncheckedUpdateWithoutSenderStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    chatId?: IntFieldUpdateOperationsInput | number
    senderUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chatMessagesUncheckedUpdateManyWithoutSenderStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    chatId?: IntFieldUpdateOperationsInput | number
    senderUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chatMessagesUpdateWithoutReceiverStoreInput = {
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
    senderUser?: UserUpdateOneWithoutSentMessagesNestedInput
    senderStore?: StoresUpdateOneWithoutSentMessagesNestedInput
    receiverUser?: UserUpdateOneWithoutReceivedMessagesNestedInput
    image?: MessageImagesUpdateOneWithoutMessageImageNestedInput
  }

  export type chatMessagesUncheckedUpdateWithoutReceiverStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    chatId?: IntFieldUpdateOperationsInput | number
    senderUserId?: NullableIntFieldUpdateOperationsInput | number | null
    senderStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverUserId?: NullableIntFieldUpdateOperationsInput | number | null
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chatMessagesUncheckedUpdateManyWithoutReceiverStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    chatId?: IntFieldUpdateOperationsInput | number
    senderUserId?: NullableIntFieldUpdateOperationsInput | number | null
    senderStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverUserId?: NullableIntFieldUpdateOperationsInput | number | null
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderItemsUpdateWithoutStoreInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: OrdersUpdateOneRequiredWithoutOrderItemsNestedInput
    product?: ProductsUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemsUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type OrderItemsUncheckedUpdateManyWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PromotionUpdateWithoutStoreInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductsUpdateManyWithoutPromotionsNestedInput
  }

  export type PromotionUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductsUncheckedUpdateManyWithoutPromotionsNestedInput
  }

  export type PromotionUncheckedUpdateManyWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreAvaliationImagesCreateManyStoreAvaliationInput = {
    id?: number
    url: string
    publicId: string
  }

  export type StoreAvaliationImagesUpdateWithoutStoreAvaliationInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type StoreAvaliationImagesUncheckedUpdateWithoutStoreAvaliationInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type StoreAvaliationImagesUncheckedUpdateManyWithoutStoreAvaliationInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUsedCouponsCreateManyCouponInput = {
    id?: number
    userId: number
    usedAt?: Date | string
    orderId?: number | null
  }

  export type UserUsedCouponsUpdateWithoutCouponInput = {
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUsedCouponsNestedInput
    order?: OrdersUpdateOneWithoutUsedCouponsNestedInput
  }

  export type UserUsedCouponsUncheckedUpdateWithoutCouponInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUsedCouponsUncheckedUpdateManyWithoutCouponInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductImagesCreateManyProductInput = {
    id?: number
    url: string
    publicId: string
  }

  export type ProductAvaliationsCreateManyProductInput = {
    id?: number
    userId: number
    note: number
    avaliationDate?: Date | string
    comment?: string | null
  }

  export type CartItemsCreateManyProductInput = {
    id?: number
    cartId: number
    quantidade: number
    abandonedCartId?: number | null
  }

  export type OrderItemsCreateManyProductInput = {
    id?: number
    orderId: number
    storeId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
  }

  export type ProductImagesUpdateWithoutProductInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductImagesUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductImagesUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUpdateWithoutProductInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProductAvaliationsUpdateWithoutProductInput = {
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutProductAvaliationsNestedInput
    images?: ProductAvaliationImagesUpdateManyWithoutProductAvaliationNestedInput
  }

  export type ProductAvaliationsUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductAvaliationImagesUncheckedUpdateManyWithoutProductAvaliationNestedInput
  }

  export type ProductAvaliationsUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    note?: IntFieldUpdateOperationsInput | number
    avaliationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromotionUpdateWithoutProductsInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoresUpdateOneRequiredWithoutPromotionsNestedInput
  }

  export type PromotionUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemsUpdateWithoutProductInput = {
    quantidade?: IntFieldUpdateOperationsInput | number
    cart?: CartUpdateOneRequiredWithoutCartItemsNestedInput
    AbandonedCart?: AbandonedCartUpdateOneWithoutCartItemsNestedInput
  }

  export type CartItemsUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    cartId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    abandonedCartId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CartItemsUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    cartId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    abandonedCartId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderItemsUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: OrdersUpdateOneRequiredWithoutOrderItemsNestedInput
    store?: StoresUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemsUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type OrderItemsUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type WishlistUpdateWithoutProductsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWishlistNestedInput
  }

  export type WishlistUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductsUpdateWithoutWishlistsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    store?: StoresUpdateOneRequiredWithoutProductNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    images?: ProductImagesUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUpdateManyWithoutProductNestedInput
    promotions?: PromotionUpdateManyWithoutProductsNestedInput
    cartItem?: CartItemsUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemsUpdateManyWithoutProductNestedInput
  }

  export type ProductsUncheckedUpdateWithoutWishlistsInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    images?: ProductImagesUncheckedUpdateManyWithoutProductNestedInput
    category?: CategoryUncheckedUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUncheckedUpdateManyWithoutProductNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutProductsNestedInput
    cartItem?: CartItemsUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductsUncheckedUpdateManyWithoutWishlistsInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProductsUpdateWithoutPromotionsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    store?: StoresUpdateOneRequiredWithoutProductNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    images?: ProductImagesUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUpdateManyWithoutProductNestedInput
    cartItem?: CartItemsUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemsUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutPromotionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    images?: ProductImagesUncheckedUpdateManyWithoutProductNestedInput
    category?: CategoryUncheckedUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUncheckedUpdateManyWithoutProductNestedInput
    cartItem?: CartItemsUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateManyWithoutPromotionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProductsUpdateWithoutCategoryInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    store?: StoresUpdateOneRequiredWithoutProductNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    images?: ProductImagesUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUpdateManyWithoutProductNestedInput
    promotions?: PromotionUpdateManyWithoutProductsNestedInput
    cartItem?: CartItemsUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemsUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    images?: ProductImagesUncheckedUpdateManyWithoutProductNestedInput
    avaliations?: ProductAvaliationsUncheckedUpdateManyWithoutProductNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutProductsNestedInput
    cartItem?: CartItemsUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutProductNestedInput
    wishlists?: WishlistUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProductAvaliationImagesCreateManyProductAvaliationInput = {
    id?: number
    url: string
    publicId: string
  }

  export type ProductAvaliationImagesUpdateWithoutProductAvaliationInput = {
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductAvaliationImagesUncheckedUpdateWithoutProductAvaliationInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductAvaliationImagesUncheckedUpdateManyWithoutProductAvaliationInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
  }

  export type CartItemsCreateManyCartInput = {
    id?: number
    productId: number
    quantidade: number
    abandonedCartId?: number | null
  }

  export type CartItemsUpdateWithoutCartInput = {
    quantidade?: IntFieldUpdateOperationsInput | number
    product?: ProductsUpdateOneRequiredWithoutCartItemNestedInput
    AbandonedCart?: AbandonedCartUpdateOneWithoutCartItemsNestedInput
  }

  export type CartItemsUncheckedUpdateWithoutCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    abandonedCartId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CartItemsUncheckedUpdateManyWithoutCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    abandonedCartId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentCreateManyPaymentMethodInput = {
    id?: number
    valor: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
  }

  export type PaymentUpdateWithoutPaymentMethodInput = {
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutPaymentMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdersCreateManyOrderStatusInput = {
    id?: number
    totalValue: Decimal | DecimalJsLike | number | string
    trackingCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sendDate: Date | string
    deliveryDate: Date | string
    minimumDeliveryForeast: Date | string
    maximumDeliveryForeast: Date | string
    usedCoupon?: boolean
    userId: number
    deliveryAddressId: number
  }

  export type OrdersUpdateWithoutOrderStatusInput = {
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    deliveryAddress?: AddressesUpdateOneRequiredWithoutOrderNestedInput
    usedCoupons?: UserUsedCouponsUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemsUpdateManyWithoutOrderNestedInput
    orderHistory?: OrderHistoryUpdateManyWithoutOrderNestedInput
    shipping?: ShippingUpdateOneWithoutOrderNestedInput
    ReturnExchange?: ReturnExchangeUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutOrderStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: IntFieldUpdateOperationsInput | number
    usedCoupons?: UserUsedCouponsUncheckedUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutOrderNestedInput
    orderHistory?: OrderHistoryUncheckedUpdateManyWithoutOrderNestedInput
    shipping?: ShippingUncheckedUpdateOneWithoutOrderNestedInput
    ReturnExchange?: ReturnExchangeUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateManyWithoutOrderStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackingCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sendDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minimumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    maximumDeliveryForeast?: DateTimeFieldUpdateOperationsInput | Date | string
    usedCoupon?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUsedCouponsCreateManyOrderInput = {
    id?: number
    userId: number
    couponId: number
    usedAt?: Date | string
  }

  export type OrderItemsCreateManyOrderInput = {
    id?: number
    productId: number
    storeId: number
    quantity: number
    price: Decimal | DecimalJsLike | number | string
  }

  export type OrderHistoryCreateManyOrderInput = {
    id?: number
    action: string
    updatedAt?: Date | string
  }

  export type ReturnExchangeCreateManyOrderInput = {
    id?: number
    reason: string
    status: $Enums.ReturnExchangeStatus
    requestedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type UserUsedCouponsUpdateWithoutOrderInput = {
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUsedCouponsNestedInput
    coupon?: CouponsUpdateOneRequiredWithoutUsedCouponsNestedInput
  }

  export type UserUsedCouponsUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    couponId?: IntFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUsedCouponsUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    couponId?: IntFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemsUpdateWithoutOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product?: ProductsUpdateOneRequiredWithoutOrderItemsNestedInput
    store?: StoresUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemsUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type OrderItemsUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type OrderHistoryUpdateWithoutOrderInput = {
    action?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderHistoryUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderHistoryUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnExchangeUpdateWithoutOrderInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReturnExchangeStatusFieldUpdateOperationsInput | $Enums.ReturnExchangeStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReturnExchangeUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReturnExchangeStatusFieldUpdateOperationsInput | $Enums.ReturnExchangeStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReturnExchangeUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReturnExchangeStatusFieldUpdateOperationsInput | $Enums.ReturnExchangeStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chatMessagesCreateManyChatInput = {
    id?: number
    content: string
    senderUserId?: number | null
    senderStoreId?: number | null
    receiverUserId?: number | null
    receiverStoreId?: number | null
    imageId?: number | null
    sentAt?: Date | string
    receivedAt?: Date | string | null
    wasReceived?: boolean
    readAt?: Date | string | null
    wasRead?: boolean
  }

  export type chatMessagesUpdateWithoutChatInput = {
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
    senderUser?: UserUpdateOneWithoutSentMessagesNestedInput
    senderStore?: StoresUpdateOneWithoutSentMessagesNestedInput
    receiverUser?: UserUpdateOneWithoutReceivedMessagesNestedInput
    receiverStore?: StoresUpdateOneWithoutReceivedMessagesNestedInput
    image?: MessageImagesUpdateOneWithoutMessageImageNestedInput
  }

  export type chatMessagesUncheckedUpdateWithoutChatInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    senderUserId?: NullableIntFieldUpdateOperationsInput | number | null
    senderStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chatMessagesUncheckedUpdateManyWithoutChatInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    senderUserId?: NullableIntFieldUpdateOperationsInput | number | null
    senderStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receiverStoreId?: NullableIntFieldUpdateOperationsInput | number | null
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasReceived?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wasRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CartItemsCreateManyAbandonedCartInput = {
    id?: number
    cartId: number
    productId: number
    quantidade: number
  }

  export type CartItemsUpdateWithoutAbandonedCartInput = {
    quantidade?: IntFieldUpdateOperationsInput | number
    cart?: CartUpdateOneRequiredWithoutCartItemsNestedInput
    product?: ProductsUpdateOneRequiredWithoutCartItemNestedInput
  }

  export type CartItemsUncheckedUpdateWithoutAbandonedCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    cartId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
  }

  export type CartItemsUncheckedUpdateManyWithoutAbandonedCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    cartId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}